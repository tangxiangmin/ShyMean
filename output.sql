INSERT INTO shymean_article SET `title` = 'BOM基础知识', `created_at` = 1487247143, `category` = 'JavaScript', `tags` = 'BOM, 读书笔记', `content` = '\r\n\r\n刚学JS的时候就买了一本《JavaScr权威指南》放在那里，当时就被这一千多页的厚度给唬住了。咬着牙看完了第一部分，也就是JavaScript语言核心；而JS的DOM部分，是在《DOM编程艺术》中学习的。关于BOM这一部分，却仅仅只是在工作中遇见了才去查资料，导致忽略了很多基础知识。\r\n前几天入手了Kindle，看的第一本书就是《JavaScr权威指南》，阅读电子书的一个好处就是能够在不知不觉中把这么厚的书给消灭掉，缺点是不容易折回去反复阅读。因此，总归是要做点笔记的。\r\n<!--more-->\r\n\r\nBOM常规的叫法是\"浏览器对象模型\"，在解释他跟DOM（文档对象模型）的区别之前，我们需要了解他们的老大，也就是`Window`对象。\r\n\r\n## Window对象\r\n\r\nWindow对象表示一个浏览器窗口，它是整个浏览器Javascript的全局对象。换句话说，我们在浏览器中使用JS，就必须依赖当前浏览器所定义的Window对象的特性和提供的接口（这就是不同浏览器存在JS兼容性的原因）。\r\n\r\n我们常使用的定时器(`setInterval`，`setTimeout`)和对话框(`alert`，`confirm`，`prompt`)都是Window对象的方法。由于在当前窗口Window对象是全局对象，因此这些方法均可以作为全局函数进行调用。\r\nWindow对象有一个最重要的属性`document`，这个属性表示窗口中的文档对象，也就是我们所熟悉的`DOM`，通过DOM，我们可以访问文档对象中的节点并进行相关操作，DOM对象实在是太重要了，以至于JS编程的焦点基本放在了这上面。\r\n此外，Window对象还定义了一些其他的属性，用于提供访问浏览器组件的接口，这些属性组成了本文的主角`BOM`，主要包括：\r\n* location位置对象\r\n* history历史纪录对象\r\n* navigator浏览器对象\r\n* screen显示器对象\r\n\r\n下面主要整理关于这些对象的基础知识，随便打开一个控制台输入`console.dir(属性名)`即可查看相关对象的信息。\r\n\r\n## location\r\n`window.location`引用Location位置对象，这里的位置不是地理位置而是浏览器地址栏的信息，即当前窗口所显示文档的URL地址。\r\n\r\n通过Location对象的相关属性，我们可以获取网页的路径`pathname`，协议`protocol`，端口号`port`和GET参数`search`等信息。而URL位置对象最主要的用途就是跳转到新页面了，可以使用`assign()`方法或者`replace()`方法来进行页面跳转，他们的区别在于：\r\n* replace方法会在载入新文档之前从浏览历史中把当前页面删除\r\n* assign方法会直接载入一个新的文档，如果在新文档点击了后退按钮把浏览器带回原始文档，某些时候原始文档的相同脚本文件会再次载入新文档（我们就再也回不去了~~）。\r\n\r\n此外，还可以使用`reload()`方法来刷新当前页面。\r\n\r\n### href\r\n而最常用的属性应该是`href`了，这个属性包含了当前页面URL的完整文本，而通过对该属性进行重新赋值，我们也可以直接使浏览器跳转到新的页面（并且这种做法更为传统）。\r\n```\r\n// 同理，由于是window对象的属性，因此可以直接作为全局变量使用\r\n\r\n// 绝对路径\r\nlocation.href = \'https://www.google.com.hk\';\r\n\r\n// 相对路径，会根据当前URL进行解析\r\nlocation.href = \'1.html\'\r\n```\r\n\r\n比较有意思的是,location对象的`toString`方法也会返回href的值，也就是说，在上面为href赋值的时候，可以使用location来代替location.href\r\n```\r\nconsole.log(location == location.href); // true\r\n\r\nlocation = \'1.html\'; // 隐式调用toStirng()并执行跳转\r\n```\r\n\r\n另外，纯粹的片段标识符(`#`)是也是相对URL的一种类型，如果改变的是片段标识符，不会让浏览器载入新文档（本来就不代表新文档），而是让页面滚动到文档的对应位置，哈没错，这就是`<a>`的锚点：使用`id`属性作锚点标记\r\n，通过向URL插入片段标识符使页面滚动到锚点处。如果没有任何标记（只有一个孤零零的#号），那么会返回到文档开始处。\r\n\r\n## history\r\nhistory用来管理浏览器的浏览历史，哈这是一个关于保护个人隐私的问题，我们可以通过`history.length`来访问历史纪录中的元素数量，却不能访问已保存的URL。\r\n我们主要使用history来模拟浏览器工具栏中的前进，后退和刷新按钮。\r\n```javascript\r\nhistory.back(); // 后退\r\nhistory.forward(); // 前进\r\n```\r\n而更通用的方法是`go()`，通过传入的参数（一个整数数字），我们可以在历史列表中向前（正参数）或向后（负参数）跳过任意条历史纪录，甚至可以传入0使页面刷新。\r\n\r\n需要注意的是，如果当前页面包含多个子窗口`iframe`，则子窗口的浏览记录会按时间顺序穿插在主窗口的历史纪录中，这导致如果在主窗口调用`hsitory.back()`，子窗口往回跳转而主窗口的页面保持不变\r\n\r\nHTML5还引进了两个新的方法`pushState()`和`replaceState()`，这两个方法允许我们逐条地添加和修改历史记录条目，这两个方法可以干很多事情，先把他们放一放...\r\n\r\n## 浏览器\r\n### Navigator\r\n浏览器对象包含了当前页面所运行的浏览器厂商和版本信息，很早之前的“浏览器嗅探”，就是根据浏览器的版本做不同的兼容处理（之前那个学校的网站项目我还用过，万恶的IE~）。navigator对象并不是经常用到，主要属性有浏览器全称`appName`，厂商和版本`appVersuib`，操作系统`platform`。我打算在博客中使用这些信息作为评论的用户信息。\r\n\r\n### screen\r\n屏幕对象主要包括了浏览器运行的屏幕窗口的显示大小和可用的颜色数量等信息。屏幕的尺寸宽`screen.width`和高`screen.height`可以用来检测当前设备的分辨率信息，从而作为某些样式和动画的依据（比如滚动加载，rem布局等）。\r\n\r\n';
INSERT INTO shymean_article SET `title` = 'CSS文本样式', `created_at` = 1470833570, `category` = 'CSS', `tags` = '样式', `content` = '\r\n最近偶然发现，定宽容器中的的文字，如果中文会自动换行，英文不会自动换行。原本只是为了解决这个问题，后逐渐深入css文字处理，发现这里面另有乾坤。\r\n\r\n<!--more-->\r\n为了便于理解，我将文字处理，分为了字体与文本这两块：\r\n* 字体包括字体，颜色，大小，字样，加粗等\r\n* 文本内容杂而多，大致分为如下部分:\r\n\t* 文本区域尺寸，包括行高\r\n    * 文本排版，包括大小写，对齐，间距，缩进\r\n    * 文本换行，包括溢出，换行\r\n    * 文本装饰，包括下划线，阴影\r\n\r\n## 字体\r\n关于字体样式，整理了下面几点：\r\n* `font-family`可以设置多个字体，使用逗号分隔，浏览器按顺序查找对应字体，如果系统存在对应字体则使用，如果不存在则查询下一个字体，依次类推；\r\n* 关于字体颜色，常见的一个BUG是突然发现页面上字体不显示，这种情况下可以检测字体颜色是否与背景色一致；\r\n* `font-style`设置字体倾斜，如果对应字体的font-family没有设计斜体，指定italic也会应用oblique；\r\n* `font-weight`可以设置数值，范围为100-900的整百位数（实际上100到300可能映射到同样的字体粗细上面）；\r\n* 字体大小除了应用在常规的文章排版上，现在正逐渐流行基于`rem`的移动端自适应布局。\r\n* 提到字体，就不能不提到字体图标，常见的如[fontawesome](http://fontawesome.io/),[iconfont](http://www.iconfont.cn/)等，可以通过设置字体样式达到之前必须使用精灵图才能实现的效果，十分方便。\r\n\r\n## 文本\r\n### 行高\r\n行高是刚接触CSS就学习的一个属性，然而对它的了解却仅限于设置文字居中，这实在是惭愧得很，这里有一篇关于行高的[详解博客](http://www.cnblogs.com/dolphinX/p/3236686.html)。\r\n\r\n首先需要明白的是文字的__顶线__，__中线__，__基线__和__底线__：指文本行从上到下的四条基准线，跟`vertical-align`的属性值相对应，（大概可以想象成写英文单词时的四线本）。\r\n\r\n然后需要明白的是文字的__行高__，__字体大小__和__行距__这三个概念：\r\n* 行高指上下文本行之间基线的竖直距离；\r\n* 字体大小指该行文本行顶线到底线的竖直距离；\r\n* 行距指上一行文本行的底线到下一行文本行的顶线之间的距离，即（行高-字体大小）；\r\n\r\n最后是__内容区__，__行内框__和__行框__这三个概念：\r\n* 内容区指文本行顶线和底线所撑开的范围，即由字体大小决定；\r\n* 行内框是一个浏览器渲染模型（类似于BFC，这里应该叫IFC）。在没有设定行高的时候，行内框与内容与大小相同；设定行高时，行内框大小也不会发生变化，而是在其上下增加半行距；\r\n* 行框也是一个浏览器渲染模型，每行文本行都有自己的行框，其高度等于该行所有内联元素行内框的最大值；\r\n\r\n搞定上面的几个概念，终于能够明白行高了。前面提到行高指的是两行文本行之间基线的竖直距离，两行文本行之间的行距是行高与文本字体大小之差。\r\n\r\n可以使用比例指定行高大小为字体的倍数，关于行高的继承性，有一个小小的坑，在子元素并未继承父元素字体大小的情况下：\r\n* 如果行高使用的是百分数，则会先将父容器的行高计算出来在继承给子元素（即百分数*父容器字体大小）；\r\n* 如果行高使用的小数，则会直接将该乘积因子继承给子元素，再计算子元素的行高（即小数*子容器字体大小）；\r\n\r\n### 排版\r\n关于排版这几个属性，日常用的也不是很多，简单了解一下：\r\n* 使用text-transform进行文本大小写转换；\r\n* 使用text-align设置文本内中对齐方式，需要注意的是这条属性对于图片等内联-块状元素也是同样生效的；\r\n* 关于文本间距，又分为字间距(letter-spacing)和词间距(word-spacing)，区分这两种间距十分容易，字间距在一组连续的字中生效，词间距在两个以空格分隔的词组间生效：\r\n* 使用text-indent设置文本缩进大小，一般使用em表示相对缩进几个字符，手册上说text-indent是一个复合属性，一个很少用的到属性值each-line表示对每行强制换行的文本都执行对应大小的缩进，但是很多浏览器都不支持（所以并没有什么用处）；\r\n\r\n### 换行\r\n文本换行是之前很少注意到的一个地方，最近的项目中却频繁出现了类似的要求:处理定宽标题中多余的文字，处理某个网站英文版本导航栏由于单词过长导致的排版问题。突然又会想起之前遇到的“包含块内的p内的字是中文会自动换行，是英文不会自动换行”的问题。基于上述原因，因此开始学习相关内容，这篇文章的初衷也源于此。\r\n接下来讨论的换行主要是针对西文字符的，因为亚洲文字文本拥有默认的white-space:normal,当遇到文本框边界时自动换行，而默认的非亚洲文本并不会自动换行，直接溢出整个文本框。\r\n换行有两个属性(word-wrap和word-break)，这两者都指定了文本换行的规则，但是又有不同：\r\n\r\n#### word-break\r\nword-break的换行属性值有`normal`,`break-all`和`keep-all`三个：\r\n* break-all表示允许非亚洲语言文本行可以在任意字符间换行，即当该文本行放不下最后一个单词时会打断该单词\r\n* keep-all会检测该行文本是否有足够的空间容纳最后的那个单词，如果不能，则该单词会换行显示，如果第二行整行都不能放下这个单词，那也不会再换行，而是直接溢出\r\n* normal表示依照空格换行，与keep-all类似，具体的区别我还真没弄明白\r\n\r\n#### word-warp\r\nword-warp的换行属性值有normal和break-word两个：\r\n* normal与上面的keep-all类似，如果第二行整行不能放下这个单词就会溢出，\r\n* break-word表示文本会在边界换行，与keep-all类似，但是如果第二行整行都不能放下这个单词，则会打断该单词并实现换行效果。\r\n\r\n#### 处理文本溢出\r\n设置word-break:break-all之后单词会非常生硬地换行，而平常书本上的换行单词都有短横线连接符，可以使用hyphens属性实现，但是目前的谷歌浏览器不支持。\r\n```\r\n    .elp {\r\n        -moz-hyphens: auto;\r\n        -ms-hyphens: auto;\r\n        -webkit-hyphens: auto;\r\n        hyphens: auto;\r\n\t}\r\n```\r\n然后就是解决文本溢出的问题，常用的方法是：\r\n```\r\n    .elp {\r\n        white-space: nowrap; \r\n        overflow: hidden; \r\n        text-overflow: ellipsis;\r\n    }\r\n```\r\n其中white-space属性是用来设置文本内的空格处理方式，下面是几个常用的属性值（详情参加手册）：\r\n* pre 不合并文字间的空白距离，当文字超出边界时不换行，也就是说会解析HTML代码中的所有空白（包括为了清晰代码格式而使用的缩进）；\r\n* nowrap 强制在同一行内显示所有文本，合并文本间的多余空白（即存在空格则会保留一个空格），直到文本结束或者遭遇br对象；\r\n* pre-wrap 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行，但是长单词在换行之后仍然可能溢出文本框\r\n* pre-line 保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行。\r\n而上面处理文本溢出的方法采用的就是忽略全部空格，因此这样只能实现处理一行文本溢出的情况，关于多行文本溢出,可以使用下面这段CSS样式，需要注意的是该方法只能在webkit内核的浏览器下才能生效，希望以后标准能够加入到所有浏览器中。如果考虑兼容性的化可以使用JS实现该效果。\r\n```\r\n    .elp {\r\n        width: 100px;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        display: -webkit-box;\r\n        -webkit-line-clamp:3;\r\n        -webkit-box-orient: vertical;\r\n    }\r\n```\r\n\r\n### 文本装饰和阴影\r\n这个就很熟悉了吧，最常见的文本装饰就是a标签的默认下划线，而关于字体阴影是CSS3新增的属性，这个在另外的文章里面再谈吧。\r\n\r\n## 最后\r\n关于文本样式最后需要注意一点：貌似所有的文本样式都是可以继承的，因此为父容器指定公共的字体样式是很明智的做法。但是，并不能完全依赖于继承样式，否则就会困惑于为什么“a标签的字体样式为什么与父容器的字体样式不一致，我明明设置了呀”这样的问题，而关于这个问题，只需要明白继承样式的优先级非常低就很清晰了。';
INSERT INTO shymean_article SET `title` = 'CSS继承与权重值', `created_at` = 1465040502, `category` = 'CSS', `tags` = '样式', `content` = '\r\nCSS中所说的继承与其它面向对象的编程语言所说的继承属性是完全不同的。这种“奇特”的继承属性在某些时候会带来一些麻烦。因此，弄清楚继承的机制，了解哪些属性可以被继承是很有必要的（因为并不是所有的属性都会被继承）。\r\n<!--more-->\r\n## 继承\r\n继承机制是基于元素的，块状元素里面可以嵌套块及内联元素，但是内联元素并不能嵌套块状元素。此外块与内联元素又可以相互转换，因此需要牢记各种能被继承的属性，不能能继承的属性，内联元素能继承的属性，块状元素能继承的属性等等花式规定。\r\n### 继承属性分类\r\n下面的继承属性总结来源于网络，出处已不可考。\r\n* 不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。\r\n* 所有元素可继承：visibility和cursor。\r\n* 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。\r\n* 块状元素可继承：text-indent和text-align。\r\n* 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。\r\n* 表格元素可继承：border-collapse。\r\n\r\n### 关于继承性的思考\r\n书里面关于继承的解释只点到了一点点：影响文本外观的样式，如字体颜色值，字体，字体大小，字体宽度，字体样式等都可以被继承，其他的属性比如边框等不能被继承...上面的资料总结的还是挺详细的，有些属性我甚至都没用到过。可以看见可以继承的属性的确大多数都是内联元素的字体样式等，而跟定位布局相关的属性是无法被继承的，我的理解就是布局需要自己手动去设计，而文本外观等可以选择让浏览器帮我们完成，如果需要可以自己另外更改。\r\n\r\n## 权重值\r\n了解了继承性之后，需要考虑的问题是：当多个样式同时应用到同一个对象上时，这些样式的优先级比较。\r\n### 权重值计算\r\n样式表中权重值ABCD的比较:\r\n* 如果是内联样式，千位+1；\r\n* 如果有id选择器，百位+1；\r\n* 如果有类、伪类或者属性选择器，十位+1；\r\n* 如果有标签名或伪元素选择器，个位+1；\r\n最后依次比较对应位置上的数字大小，需要注意的是并不会十进制进位（不是单纯的比较最后总数大小，虽然书上是这么说的，但是貌似不是完全正确。），也就是说0，0，1，0与0，0，0，11比较的话，前者的权重值仍然比后面高（但是一般应该没有连续嵌套11个标签名的做法吧，大概会被打死的...）\r\n对于!important，其权重值非常高，但是只当其是唯一存在的时候才有效果，当多次指定时将会抵消，仍按照上述计算公式计算比较。一般不使用！Important，前辈的经验。\r\n* 当多个规则应用在同一个元素上时，权重越高的样式将被优先采用；\r\n* 当权重值相同的时候，在样式表中后定义的样式将覆盖先前定义的样式；\r\n\r\n### 继承的权重值\r\n但是！！！继承而来的属性值权重值是非常低的，权重值永远低于明确指定到元素的定义。只有当一个元素的某个属性没有被直接指定时，才会继承父级元素的值，也就是说可以使用一个更“具体的”选择符属性覆盖继承自祖先的属性而忽略权重值的问题。比如下面的代码：\r\n```\r\n\t#r{color：red}\r\n    span{color:blue}\r\n\r\n\t<p id=\"r\"><span> hello</span></p>\r\n```\r\n尽管前者的权重值远大于后者，但是span里面的字体颜色仍然是蓝色。\r\n### 多类选择器\r\n此外需要注意多类选择器的一个小问题。比如下面的例子：\r\n```\r\n\tul.red { color: red }\r\n\tli { color: green; }\r\n\t<ul class=\"red\">\r\n    \t<li class=\"red\">hello</li>\r\n        <li>hello</li>\r\n    </ul>\r\n\r\n```\r\n所有的li都是绿色的，注意这里的ul和.red之间没有空格，有空格的话就看不见效果了，这里引申出另外一个关于选择器中空格的问题，在jQuery也经常碰到,而带有red类的ul，虽然看似有red类，而实际上是一个ul的多类选择器()，因此该也li为绿色，这种情况也应当归属于继承样式权重值非常低的缘故。当ul 与.red之间存在空格的时候，就变成了普通的权重值比较问题，此时.red的li显示正确的红色。\r\n\r\n## 最后\r\n权重值是CSS中除了布局之外另一个很重要的特性，毕竟人家名字就叫做“层叠样式表”，层叠这个词表示的就是每个元素应用的就是最具体最顶层的那个样式。而继承，是占据在权重值最底层的，甚至低于通配符所设置的样式，啊可怜的孩子。\r\n最后，在保证优先级的前提下，应尽量减少选择器的个数，这跟CSS渲染效率有关，关于选择器嵌套，这也是一个挺深的坑。';
INSERT INTO shymean_article SET `title` = 'CSS代码格式', `created_at` = 1466944257, `category` = 'CSS', `tags` = '代码格式', `content` = '\r\n刚学CSS的时候，以为只要写出的样式能够在浏览器中正确显示就够了。直到逐渐发现一个几千行的CSS文件，如果不在书写过程中规范自己的代码格式，后面维护简直就是噩梦。掉进坑才知道痛，下面总结了自己在敲CSS代码需要注意的地方，如同CSS代码的组成一样，也分别从选择器，属性名，属性值三个方面进行总结。\r\n<!--more-->\r\n\r\n## 选择器\r\n选择器是css的基础，其重要性不言而喻。在保证选择器正确的前提下，对其格式也需要加以规范。\r\n* 首先是选择器的命名。对于class名和id名，应当具有明确的语义性。关于选择器命名这里面，有很大学问（比如按照属性命名而非功能命名），我现在的水平是万万不敢发表什么拙见的，[张鑫旭大神](http://www.zhangxinxu.com/)的博客里面有不少关于这方面的知识；\r\n* 其次是选择器的嵌套。选择器嵌套最主要的作用是为了提高选择器的优先级。但是如果仅仅是为了避免冲突嵌套数个选择器，会大大降低代码重用性（而类本身就是为了方便在多个地方使用相同的样式）；对于id选择器而言，由于其具有惟一性，故其前面的嵌套完全没有必要。这也正是我对于less预编译存在的部分困惑（当然我只是初学者）。此外，由于CSS的渲染方式是从右到左，过多的嵌套会大大降低浏览器渲染效率。所以，应当在保证优先级的前提下尽可能缩短嵌套。\r\n* 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。如无必要，不为 id、class 选择器添加类型选择器进行限定。\r\n\r\n## 属性名\r\n尽管不论按照什么顺序写属性名，都能使样式正确显示，但是还是参照前辈们的书写格式来进行吧（或者是养成自己的书写顺序习惯，而不是想到什么样式就写什么样式）。下面按照书写先后顺序进行排序\r\n* 位置属性(position, top, right, z-index, display, float等)\r\n* 尺寸大小(width, height, padding, margin)\r\n* 文字系列(font, line-height, letter-spacing, color- text-align等)\r\n* 背景(background, border等)\r\n* 其他(animation, transition等)\r\n此外还需要注意属性名在不同浏览器下的兼容性问题，比如opacity等，这方面还有待加强。\r\n\r\n## 属性值\r\n关于属性值的书写格式，有各种各样不同的格式。因此，最主要的还是养成自己固定的书写习惯（或者是服从项目的格式要求）。下面是我自己养成的一些习惯。\r\n* 属性名与值后的\":\"之间不包含空格,\":\"与属性值之间包含空格。\r\n* 在可以使用属性值缩写的情况下，尽量使用属性缩写。\r\n* 长度为 0 时须省略单位。\r\n* 颜色值可以缩写时，使用缩写形式。\r\n* 当数值为 0 - 1 之间的小数时，省略整数部分的 0。\r\n\r\n## 总结\r\n关于格式规范的问题，其实并没有统一的规定，需要靠自己在学习工作中不断摸索，在被一大段杂乱的css代码给恶心到之后才会真正注意到这个问题，最好的办法就是在学习初期就开始重视，并不断修正自己的代码风格。';
INSERT INTO shymean_article SET `title` = 'BFC及其应用', `created_at` = 1464405698, `category` = 'CSS', `tags` = 'BFC, 布局', `content` = '\r\n最初在看见BFC，两眼一愣，这是个什么玩意，看过的两本书上都没有谈论到。于是balabala一顿谷歌，现在勉强能弄懂了（然后又是满屏幕的overflow hidden，这是病得治啊！），然后就整理了一下。\r\n<!--more-->\r\n## BFC\r\n在了解BFC之前，首先需要弄清楚的是盒子模型，这是CSS布局的对象和基本单位。\r\n可以说这样说，一个页面，是由许多的盒子组成的，元素的类型与display的属性，决定了这个盒子的类型，不同的盒子，其渲染方式是不一样的。（官方的说法叫做Formatting Context，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用）\r\n如果display属性为block的盒子，就会参与block fomatting context，也就是上面所说的BFC，此外还有Inline formatting context (简称IFC)。（context这个词是名词，原意是环境/上下文，放在这里略显晦涩，我只能将它直译成“块级元素渲染环境”，当然这并不妨碍理解）\r\n## 触发BFC\r\nBFC是CSS2.1规范中的一个概念，满足下面任意一个条件的块级元素都会触发BFC。为了加深印象，正反情形我都列举出来了。\r\n* 根元素，是指文档树中没有父元素的元素，也就是最顶层结构的元素，一般情况下是html元素；\r\n* float属性不为none，即float为left||right；\r\n* position不为relative，即position为absolute||fixed；\r\n* display为inline-block, table-cell, table-caption, flex, inline-flex，这里特别需要注意的是inline-block。\r\n* overflow不为visible，即overflow为hidden||auto||scroll，这里特别需要注意的是hidden;\r\n\r\n## BFC的规则\r\n了解怎么“制造”BFC元素之后，就应该认识这些BFC具有的布局规则了。\r\n* 内部的Box会在垂直方向，一个接一个地放置。\r\n* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠，准确的说只有在同一个BFC内的元素才会发生外边距折叠。\r\n* 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\r\n* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此，这就是BFC所具有的大名鼎鼎的独立区域属性，躲进小楼成一统，管它春夏与秋冬。\r\n* BFC的区域不会与float box重叠,即旁边的浮动元素是无法遮挡住BFC元素的。\r\n* BFC可以包含浮动元素，意思就是BFC的高度计算是包括其浮动的子元素的，浮动元素的高度也参与BFC高度计算（重要的事情说两遍！），这下即使子元素全部都是浮动元素，BFC也可以知道它自己的高度了。\r\n\r\n## 使用BFC进行布局\r\nBFC的布局规则弄清楚之后，当然就应该学习他的布局作用了，最常见的作用就是清除外边距折叠与清浮动了。\r\n\r\n### 清除外边距折叠\r\n由布局规则第二条可知，当两个相邻的块级元素不再同一个BFC中时，是不会发生竖直方向上的外边距重叠的，在有的时候莫名其妙的发生了外边距不重叠，或者是在某些情况下不需要这种折叠的时候，就可以用到BFC了，需要注意的是父块为BFC的情况下也不会与子块发生外边距重叠。\r\n\r\n### 清浮动\r\n由布局规则第六条可知，BFC可以包含浮动元素，并正确的显示自己高度，如果父块没有设置高度则由其内部的子块撑开，BFC仍然处于文档流中，因此可以触发BFC达成清浮动的目的；此外，由于BFC还不与浮动元素的aside重叠（第五条），因此会根据自身宽度和aside的宽度，自动变窄。\r\n\r\n## 最后\r\n根据有道云上写的笔记大概整理了这么点东西，以前对于overflow hidden可以清浮动一直不太理解，原来就是BFC的作用，果然需要还是有深度的学习才行。这篇文章还有待补充，先挖个坑吧。\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = 'DOM中的事件处理', `created_at` = 1465309624, `category` = 'JavaScript', `tags` = '事件, DOM', `content` = '\r\n记忆中某天在某个个人网站上看见一个非常酷炫的效果：整个页面都是萤火虫似的小光点组成的LOGO，鼠标滑过的时LOGO被打散，屏幕上泛起阵阵涟漪，鼠标停止又变换图形。当时非常震撼，甚至于忘了保存链接。这就成了我现在正在奋斗的一个目标。正巧刚看完客户端JS关于事件处理的部分，下面简单整理了一下JS中关于事件及相关的一些知识点。\r\n<!--more-->\r\n## 事件\r\n当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，浏览器就会产生事件；也可以说成是浏览器通知应用程序发生了什么事情。关于事件的几个名词解释列于图中。\r\n![js事件](uploads/event.png)\r\n\r\n## 几个概念\r\n然后是几个需要注意的地方。\r\n\r\n区分事件目标与事件对象\r\n> 这两者在概念上是很容易区别的，只是初学的时候对概念不屑一顾的态度让我走了一点弯路。一个事件，是在某个事件目标（小至一个按钮、大到整个文档）上所发生的，而与该事件有关的详细信息（如鼠标坐标、target属性等）则保存在事件对象中。\r\n\r\n兼容作为参数的事件对象与作为全局对象的事件对象\r\n> 利用“||”运算符的短路运算可以解决：event = event||window.event。此外需要注意事件对象并不是事件处理函数所必需的，只是某些处理函数需要事件对象的某些属性罢了。\r\n\r\n事件处理函数的注册\r\n> 通过为HTML标签设置事件处理函数的方式违背了结构行为分离的准则，不建议使用； 通过设置事件目标属性的方式注册的事件函数只会存在一个，后注册的事件处理函数会覆盖前面注册的函数。\r\n\r\n事件处理函数的调用上下文\r\n> 事件处理函数一般作为事件目标的方法调用，因此其中的this指代的就是这个事件目标对象。但是使用attchEvent注册事件的时候其中的this是window全局对象。\r\n\r\n事件的默认操作\r\n> 通常情况下的return false表明禁止执行该事件相关的默认操作（比如点击超链接禁止跳转页面），不过这种通过返回值关闭默认操作只在通过事件目标属性注册才有效果。在其他形式注册的事件下需要事件对象调用其对应的方法。\r\n\r\n## 事件传播\r\n事件传播有事件捕获和事件冒泡两种形式，他们决定了事件处理函数的调用顺序，在模型上跟作用力与反作用力十分相似，但是捕获与冒泡的用途是不一样的，这里现在只是大致了解原理，具体的应用需要逐步掌握。\r\n### 事件捕获\r\n当触发了一个事件之后，事件从最外层的window对象开始向document对象传播并到达至最内层的事件目标为止，并调用在传播路径上的每个对象的事件捕获处理函数（如果存在的话），这就是事件捕获过程。只能通过addEventListener()且将第三个参数设置为true的方式才能注册事件捕获处理函数；而通过事件目标属性注册的事件函数均为事件冒泡处理函数。事件捕获在IE8之前的浏览器不被支持。\r\n事件捕获模型提供了在事件没有被送达目标之前查看他们的机会，能用于调试。\r\n### 事件冒泡\r\n当最内层事件目标调用其事件处理函数之后，事件将从事件目标沿着DOM树传播至根部，并调用在传播路径上的每个对象的事件冒泡处理函数。focus，blur，scroll，load,change等事件不会冒泡（至于其他不会冒泡的事件待收集）。冒泡机制被所有浏览器支持。\r\n事件冒泡模型在为大量单独元素上注册处理程序提供了解决方案（在其公有祖先元素上注册事件,即事件委托）。事件委托就是事件目标不直接处理事件，而是委托其父元素或者祖先元素甚至根元素（document）的事件处理函数进行处理。可以通过事件对象的target属性获得真正触发事件的引用。事件委托是建立在冒泡模型之上的。\r\n## jquery中的事件封装\r\n接下来是jQuery中对于事件的处理，jQuery中定义了几种关于注册事件的方法：\r\n> bind()\r\n> live()\r\n> delegate()\r\n> on()\r\n> off()\r\n> one()\r\n\r\n这几种方法都是通过冒泡方式进行事件函数调用的，且均支持一个事件目标上，针对一个或多个事件，同时绑定数个事件处理函数；此外这几种方法return false可以同时阻止默认行为与事件冒泡。\r\n* 鉴于历史原因（如选择器支持，函数执行效率等方面），live()方法已经被删除；\r\n* bind()方法只能针对已经存在的元素进行事件设置（无法为进行事件委托，且为多个元素绑定相同事件时内存开销很大），因此推荐使用on()代替；\r\n* 在事件绑定与事件委派方面，on()与delegate()方法是等效的，具体的区别从查到的资料上感觉并不让人信服，可能是为了统一规范事件绑定与委派吧，推荐使用on()。\r\n\r\n可以很方便的通过on()方法为同一个元素注册多个事件处理函数，也可以为多个元素注册同一个事件处理函数（结合强大的jQuery选择器）；移除已注册的事件处理函数也非常简单，可以使用off()方法。\r\noff()方法对应于on()，取代了 unbind()、die() 和 undelegate() 这几个移除事件处理函数的方法；此外对于只需要触发一次，随后就要立即解除绑定的情况，jQuery还提供了一个one()方法，使用one()方法注册的事件处理函数执行一次之后就被移除。\r\n由于并不是所有浏览器都支持事件捕获，且这种情况无法通过判断兼容性等方式来弥补，因此jQuery并不支持事件捕获。\r\n\r\n## 最后\r\n事件是前端中一个非常重要的知识点，现在学到的不过是一点皮毛，需要百尺竿头，加倍努力啊。\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = 'flex布局', `created_at` = 1480599974, `category` = 'CSS', `tags` = 'flex, 布局', `content` = '\r\n最近在掘金上看见了一个叫做`flex.css`的项目：使用flex进行移动端的快速布局。之前在学习CSS3的时候还挣扎在定位和浮动的困惑无法自拔，后面的项目也未曾想到使用flex。因此翻开CSS手册，准备整理一下关于flex的知识。\r\n<!--more-->\r\n\r\n## 兼容\r\n在[Can I Use](http://caniuse.com/#search=flex)上可以看到，现在主流的浏览器都是支持`flex`属性的，关于之前需要使用的`-webkit-`前缀，貌似现在也是不需要了，因此，大胆地尝试一些新的东西吧。至于flex本身，也有`box-flex`（旧版本）和`flex`（新版本），现在肯定是学习最新的啦。\r\n\r\n## 语法\r\n进行flex布局需要先定义一个flex容器，其子元素成为该容器的项目，设置为Flex布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\r\n### 容器\r\n```\r\ndisplay: -webkit-flex; // 现在已经不需要添加浏览器前缀了\r\ndisplay: flex;\r\n```\r\n一个声明为flex的容器，便可以添加下面六种属性（就我个人的观点，就像是操作单个文字一样操作容器下的项目）。\r\n#### flex-direction\r\n容器具有主轴和侧轴，全部的项目都根据轴进行布局的，`flex-direction`设置flex的主轴方向，即项目的排列方向，默认水平方向。（类似于文本的direction属性）\r\n```\r\nflex-direction: column | row | column-reverse | row-reverse;\r\n```\r\n#### flex-wrap\r\n默认情况下，项目都排在一条线（又称\"轴线\"）上（每个项目会自动调节其宽度）。flex-wrap属性定义，如果一条轴线排不下，是否进行换行。（类似于文本的white-space属性）\r\n```\r\nflex-wrap: nowrap | wrap | wrap-reverse;\r\n```\r\n#### flex-flow\r\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\r\n```\r\nflex-flow: <flex-direction> || <flex-wrap>;\r\n```\r\n\r\n#### justify-content\r\n定义了项目在主轴上的对齐方式（类似于文字对齐的text-align）。\r\n需要注意的是：起点和终点都是由flex-direction的值决定的，也就是说如果改变了flex-direction的值，justify-content的结果也会发生变化。\r\n\r\n```\r\njustify-content: flex-start | center | flex-end;\r\n```\r\n除了起点，居中，终点之外，如果需要设置各项目之间的位置分布，还可以使用\r\n```\r\njustify-content: space-between | space-round;\r\n```\r\n其中，`space-between`表示两端对齐，项目之间的间隔都相等；`space-round`表示每个项目两侧的间隔相等（类似于把该行剩下的留白均分给每个项目的外边距，）。这两个属性都会使容器中的元素平均地分布在行内，区别在于如果只存在一个项目，则前者相当于`flex-start`，而后者相当于`center`。\r\n\r\n#### align-items\r\n定义项目在侧轴上的对齐方式（类似于设置文本行高与vertical-align的结合），跟`justify-content`类似，也有下面三种属性值\r\n```\r\nalign-items: flex-start | flex-end | center ; // 垂直居中不要太简单\r\n```\r\n除了起点，居中，终点之外，此外还有\r\n```\r\nalign-items: baseline | stretch\r\n```\r\n其中，`baseline`表示项目按照项目的第一行文字的基线对齐；`stretch`如果项目未设置高度或设为auto，将占满整个容器的高度（这个单词的意思就是拉伸）。\r\nPS：如果要测试这个属性，最好显式地设置一下容器的高度，或者将项目设置不同的高度\r\n\r\n#### align-content\r\n用于多行的弹性盒模型容器轴线的对齐方式，只有定义了flex-wrap为wrap时才有效果，如果项目只有一根轴线，该属性不起作用，跟justify-content具有相似的属性值\r\n```\r\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch;\r\n```\r\n\r\n### 项目\r\n处于flex容器下的项目可以应用下面几个属性（当然，项目也可以是flex容器）。\r\n#### order\r\n定义项目的排列顺序。数值越小，排列越靠前，默认为0。（类似于z-index一样使用数值达到排列在“前面”的效果）\r\n```\r\norder: <integer>;\r\n```\r\n\r\n#### flex-grow\r\n定义项目的放大比例（所谓放大指如果项目宽度之和小于容器宽度，就会增加每个项目的宽度），默认为0，即如果存在剩余空间，也不放大。\r\n```\r\nflex-grow: <number>;\r\n```\r\n假设存在剩余空间，如果所有项目的flex-grow属性都为1，则它们将均分剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍，以此类推，浏览器会自动计算每个项目的宽度。\r\n\r\n#### flex-shrink\r\n定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\r\n```\r\nflex-shrink: <number>;\r\n```\r\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。\r\n* 如果一个项目的flex-shrink属性为0，空间不足时，则该项目的尺寸不缩小（这时就会发生项目溢出容器的情形）;\r\n* 如果一个项目的flex-shrink属性为2，其他的项目flex-shrink属性为1，则当空间不足时，该的缩小程度为其他项目的2倍，以此类推（类似于一个靠近浮动元素的BFC）。\r\n\r\n#### flex-basis\r\n定义了在分配多余空间之前，项目占据的主轴空间（跟主轴方向有关）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的沿主轴方向上的自身尺寸。\r\n```\r\nflex-basis: <length> | auto;\r\n```\r\n它可以设为跟width或height属性一样的值，则项目将占据固定空间，且设置该属性之后，width的值会被自动覆盖（不论书写顺序的前后）\r\n\r\n#### flex\r\n是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\r\n```\r\nflex: none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]\r\n```\r\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\r\n\r\n#### align-self\r\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可用于覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\r\n```\r\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\r\n```\r\n\r\n## flex.css\r\n由于我也是刚接触这个框架，大致查看了一下，主要是应用属性选择器直接在元素上进行布局声明。这样的写法之前很少遇见，但是感觉很有意思：布局完全跟CSS样式分离了，官方称作“声明式布局”，看HTML代码就可以大致了解整个页面的布局，怪不得说是移动端快速布局的神器。附上两个链接，学习去了：\r\n* [flex.css官方地址](https://github.com/lzxb/flex.css)\r\n* [flex.css快速入门--掘金](http://gold.xitu.io/post/582d991cc4c9710054407dc3?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)';
INSERT INTO shymean_article SET `title` = 'head内的标签', `created_at` = 1468996266, `category` = 'HTML', `tags` = '标签', `content` = '\r\n\r\n由于sublime中可以很方便的生成页面模板（!+ctr+e组合键），因此一般除了引入脚本跟样式表之外以及更改title内容之外，并没有在head标签内做其他改动，对于这个跟body标签同级的元素所给予的关注度基本可以忽略，今天了解了一点seo的东西，发现应当重新回过头来看一看这个被我忽视了这么久的重要标签。\r\n<!--more-->\r\n关于head标签本身，其实并没有什么其他需要注意的地方，它只是所有头部元素的容器，所有头部元素内容都不会出现在页面上。文章的重要放在head内部的标签上。\r\n## title标签\r\n这个大概是最熟悉的一个标签了，使用其内容指定整个文档出现在浏览器标签栏中的名字（在手机浏览器中中查看网页时，能够更清楚的看到标题）。有下面几个方面需要注意。\r\n* 如果title内容为空或者没有title标签，则会以整个文件名作为标签栏名字，一般情况下，最好设置一个标签；\r\n* 一个页面如果存在多个title，则只有第一个title的内容生效，其他的标题标签会被浏览器忽略，一般情况下，最好只设置一个标签；\r\n* title标签也是一个DOM元素节点，因此可以动态的修改其中的内容（貌似除了伪装成跳转页面并没有什么其他的用处，我想到的一种做法是在公共的JS文件中对title进行判断，只有在指定的页面内对应的JS才会生效，比如某些返回顶部的按钮之类的，具体的做法还是得仔细想想。）\r\n* 貌似并不能对title进行样式设定（这是前面提到的所有头部元素都不会出现在页面上，因此根本就无法渲染其样式），也不能包含其他的标签（浏览器会将title标签内的所有内容直接映射到标签栏上），平常看见的一些网页标题前有个类似于logo的背景图，使用的是ico图标的方式及下面就会提到的link标签。\r\n\r\n## link标签\r\n该标签可以将外部资源引入当前页面文档，通过指定其href属性（即路径），可以将外部资源与页面链接起来。link标签另一个比较重要的属性是rel，rel属性规定当前文档与被链接文档之间的关系。\r\n* rel最常见的属性值就是rel=”stylesheet，该属性得到了全部浏览器的支持。在CSS样式的四种作用方式中，使用Link标签链接外部样式表是最常见的一种。然而，link标签的用途并不单单只是作用于样式表；\r\n* 比如在title标签中提到的标签栏logo图标，即是使用link标签来完成的，具体做法是 将rel属性值更改为icon，并将href指定为某个图片资源，需要注意的是虽然支持多种图片格式，一般的做法是使用ico格式的图片，可以通过各种图片格式转换器获得，这样做的目的是为了...（好吧我也不太清楚，大多数浏览器会自动识别网站根目录下的.ico文件，以及为了获得更好的图片效果吧。汗！这个解释真是牵强）。\r\n```\r\n\t<link rel=\"icon\" href=\"house.ico\">\r\n```\r\n此外link标签的rel还有很多其他的属性值，只是由于这些值只得到了部分浏览器的支持，且并不是很常见，因此这里就不介绍了，详情可以查看w3cSchool里面的[讲解](http://www.w3school.com.cn/tags/att_link_rel.asp)。\r\n\r\n## style标签\r\n额这个是耳熟能详。我学CSS写的第一行样式就是在这个标签里面写的。Style也十分简单，只有一个唯一的属性type，且具有唯一的属性值text/css。虽然有的教程上写的style标签的type属性及属性值不能省略，但是我发现一个没有任何属性的style标签内部的样式也会生效。（既然都是唯一的属性及属性值，为什么还要显式地声明呢？难道是为了以后出现取代css样式的技术吗？拭目以待哦，这里立个flag。）\r\n* 为了结构与样式分离，因此一般很少使用style标签设置页面样式，（不过写个demo或者简单的测试啥的，style标签还是很常用的）。更多的是设置DOM元素的style属性而非style标签（JS设置的style都是行内样式，咳咳，跑题了）。\r\n* 此外，并不是只能在head中放置style标签，可以在页面中任何一个地方使用style标签，并且浏览器也会自动解析并渲染出正确的样式（即使所指定的样式位于需要渲染的DOM节点之后），style标签默认样式display:none,且无法更改。但是！（重要的都在最后面），一般情况下应当将style标签放在头部（如果存在的话），这样的 css 文件可以先加载，避免先加载 body 内容，导致页面一开始样式错乱，然后闪烁，不但是style标签，使用link标签链接外部样式表时也应当如此对待。\r\n* 最后，style标签也是一个DOM元素，也可以被querySelector等方法获取到并设置innerHTML等属性（然而这个我是真没想到有什么用，毕竟动态设定style属性都已经违背了优雅降级的思想。）\r\n\r\n## script标签\r\n该标签用于定义浏览器脚本程序（好吧，现在基本上也就是JS一统天下了，不过昨天还在某个网页上看见了vbscript的程序。）此外由于js是script标签type属性的默认值，因此不必显示指明type=\"text/javascript\"。\r\n* 与样式表不同的是，内嵌样式与外部样式分别采用了style标签和link标签，而script标签既可以书写页面脚本，也可以引入外部脚本（设置src属性值为指定路径）。\r\n* 与style标签相同的是，可以在script标签中进行JS代码的书写且该段代码会被浏览器正确解析，需要注意的是由于浏览器是自上往下加载页面的，若将 javascript 文件放到 头部，如果script中的代码不处于任何任何函数中，则当浏览器加载到该程序时就会执行，意味着必须等到所有的 javascript 代码都被 下载、解析和执行完成 之后才开始呈现页面内容。这样就会造成呈现页面时出现明显的延迟，窗口一片空白；此外将JS放在头部会增加页面内容加载时间。为避免这样的问题一般将全部将 javascript 文件放到底部（所以这里强行将script标签归为头部元素有点名不副实）。\r\n* 为了解决上述问题，可以设置script标签的另外两个属性async和defer。\r\n\t* defer属性的作用是表明脚本在执行时不会影响页面的构造，（实质上是脚本会延迟到整个页面加载完毕后再执行，因此defer属性相当于告诉浏览器遇见脚本就按顺序下载，但是延迟执行，这里的执行时按页面中的脚本标签顺序先后执行）；\r\n\t* async属性与defer类似，是告诉浏览器不必等待脚本的下载和执行，从而异步加载页面的其他内容，与defer不同的是，async无法保证数个script标签内代码的执行顺序（并不是按照页面中的脚本顺序来执行的，其顺序是不定的，因此如果使用async则需要保证各个脚本之间的不依赖性）。\r\n\r\n## 最后\r\n这篇博文写了三个晚上，这实在是...最近学习效率比较低呀。整理完head标签内部常见的元素，接下来的重点是head标签中的meta标签，这是一个充满着谜团与惊喜的标签哦';
INSERT INTO shymean_article SET `title` = '《DOM编程艺术》读书笔记', `created_at` = 1464443841, `category` = 'JavaScript', `tags` = '读书笔记', `content` = '\r\n《DOM编程艺术》这本书短小精悍，值得一看，入门必备呀！囫囵吞枣看了两遍，补充了一点笔记。\r\n\r\n<!--more-->\r\n\r\nD，O，M解释\r\n\r\n>文档对象模型，把整个网页当成一棵节点树，每个节点都可以通过某条联系找到该页面中的其他任何节点\r\n\r\n三种比较重要的节点\r\n\r\n>元素节点：非常重要，大多数操作都是对元素节点的操作\r\n\r\n>文本节点：文本节点总是被包围在元素节点之中（XHTML闭合标签），注意并非所有的元素节点都有文本节点\r\n\r\n>属性节点：对元素节点做更具体的描述，如title src class 等等属性标签\r\n\r\n获取元素节点的方式\r\n\r\n>getElementById()//返回一个节点\r\n\r\n>getElementsByTagName()//返回节点列表（类数组对象），即使只有一个元素节点也必须通过下标访问\r\n\r\n>getElementsByClassName()//同上\r\n\r\n\r\n\r\n获取元素节点上的属性节点与设置属性节点\r\n\r\n>getAttribute(\"title\")//获取title属性的值，若无返回null\r\n\r\n>setAttribute(\"title\",\"hello\")//为titile属性设置hello的值，可以通过这种方式设置类名，注意会覆盖前面的属性值\r\n\r\n\r\n\r\n获取元素节点内的文本节点与设置文本节点\r\n\r\n>innerHTML()//只有这一个方法，如果为其赋值则表示设置文本内容，如果直接返回则显示该元素节点中的文本内容，注意会返回其下的所有标签代码与文本内容。想要单独改变文本节点的内容应使用nodeValue属性（注意是一个属性）。\r\n\r\n\r\n\r\n所有的DOM操作设置的样式都是行内样式，因此其优先级非常非常高。\r\n\r\n\r\n\r\n获取一个元素节点的所有子节点，childNodes\r\n\r\n>首先注意这是一个属性而不是方法；\r\n\r\n>其次，该属性只统计他自己的子节点而不计算其子节点的子节点，空格与换行都算是文本节点；\r\n\r\n>在不同浏览器下会返回不同的节点总数。可以通过节点的nodeType属性查看其具体属性，其中：\r\n\r\n\t* 1表示元素节点\r\n\r\n\t* 2表示属性节点\r\n\r\n\t* 3表示文本节点，\r\n\r\n\t* 此外共有12种节点类型，虽然并没有什么用处。\r\n\r\n>可以使用first-child和last-child属性代替childNodes[0和childNodes[length-1]；此外firstElementChild在标准下获取第一个元素类型的节点，但是非标准的ie不支持，在非标准的ie下firstChild获取到的就是第一个元素节点，（真是坑）。\r\n\r\n\r\n\r\n获取元素的父元素和兄弟元素节点的相关属性\r\n\r\n>parentNode//元素的父节点\r\n\r\n>offsetParent//离当前结点最近的有定位的父节点\r\n\r\n>nextSibling 和nextElementSibling//下一个兄弟（元素）节点\r\n\r\n>previousSibling 和previousSibling//上一个兄弟（元素）节点\r\n\r\n\r\n\r\n平稳退化与渐进增强\r\n\r\n>平稳退化：正确使用js，在浏览器不支持的情况下尽可能顺利地显示页面内容。平稳退化对于爬虫非常有效。因此不要将重要的内容放在DOM加载显示。\r\n\r\n>渐进增强：用一些额外的JS数据去包裹原始数据使其缤纷多彩，即使JS无法使用也能正常显示主要内容\r\n\r\n\r\n\r\n优化性能\r\n\r\n>尽可能少访问DOM和尽量减少标记\r\n\r\n>合并放置多个脚本，减少服务器响应次数\r\n\r\n>压缩脚本，缩短加载时间\r\n\r\n\r\n\r\nDOM core 和HTML-DOM的区别\r\n\r\nHTML-DOM中访问元素节点的属性时可以直接使用\".\"运算符\r\n\r\n\r\n\r\n动态创建节点的方法\r\n\r\n>创建元素节点： document.createElement(nodename)//创建了一个元素节点，一般需要将其赋给某个变量\r\n\r\n>创建文本节点： document.createTextNode(text)//创建内容为text的文本节点\r\n\r\n\r\n\r\n将创建的节点插入到节点树中\r\n\r\n>通过父元素： parent.appendChild(node)//将动态创建的节点插入到父节点中\r\n\r\n>通过兄弟元素： sibling.insertBefore(node)//将动态创建的节点插入到兄弟节点前，注意没有insertAfter方法，需要自定义一个。\r\n\r\n\r\n\r\n通过style属性获取及设置样式\r\n\r\n>选择器属性名如果存在“-”，应当使用驼峰命名法；\r\n\r\n>此外通过style属性只能返回行内样式；而当为style对象的属性设置值时必须将值放入引号中；\r\n\r\n\r\n\r\n通过className属性来设置更多的样式\r\n\r\n*该属性返回对应元素节点的所有类名，相当于getAttribute(\"class\")；\r\n\r\n>同样可以通过该属性为对应的元素节点设置新的类名，相当于setAttribute(\"class\",newClassName)；\r\n\r\n\r\n\r\n使用定时器创建动画\r\n\r\n定时器是window全局对象的方法，每隔一段时间就调用指定函数，完成动画效果。比如一个移动的动画，其本质效果是改变元素的定位属性值，因此需要预先设定元素的定位方式。 需要注意的是通过事件触发的对象，一定要考虑定时器的重复触发问题，这是由于变量作用域引起的。\r\n\r\n\r\n\r\n关于W3C标准的思考\r\n\r\n我所理解的W3C标准就是“结构，表现，行为三者分离”，但是随着逐步深入，发现HTML,CSS,DOM之间都有互相叠加的区域，可以在HTML中设置样式与事件响应，可以在CSS中通过伪类达成动态交互，可以在DOM中创建节点及设置样式，三者并不冲突，而具体使用则需要仔细斟酌。随着CSS3和HTML5的深入，发现这三者越来越融合的感觉。\r\n\r\n\r\n\r\n书本最后介绍了HTML5和一些常用的库，不再赘述。';
INSERT INTO shymean_article SET `title` = 'HTML表单', `created_at` = 1468282025, `category` = 'HTML', `tags` = '标签', `content` = '\r\n最近总是想着，是时候给博客搭一个后台了，然而昨天晚上才开始看PHP，大致翻了《PHP从入门到精通》这本书，关于该书内容这里就不做评价（略那啥...）。只是接触到后台之后，才对于表单form标签开始有了一点了解，想想前两天被后台的同学吐槽“为什么一个页面上要套那么多form”，丢脸丢到家了，赶紧学一点点后台。好了不说废话了，现在总结一下form标签。\r\n<!--more-->\r\nform标签主要用于接收用户的不同类型的输入或选择，并在提交表单时向服务器传输数据，接下来主要从HTML的form标签属性和HTML表单元素两方面说起;\r\n\r\n## 标签属性\r\nform是一个块状元素，没有内外边距和边框，甚至没有任何其他默认样式，除了独有的属性之外跟一个普通的div元素没有什么区别。 Action：属性值为一个url路径，表示整个表单打包的数据发送到的目标地址，一般指向一个后台处理程序文件（比如xx.php），然后再处理程序中通过函数或变量获取表单数据内容。\r\n### method\r\n指定表单传递的方式，属性值有post和get两种。这两种方式有很大的区别：使用post方式提交数据，表单数据会作为HTTP请求的一部分发送给服务器（关于HTTP的简单理解，这里是一个链接）；使用get方式提交数据，表单数据会添加在action属性值所指定的url地址后面发送到服务器。主要的区别有以下两点：\r\n* 由于url长度的限制，因此使用get方式传输的数据量一般比较小，而post则没有这个限制；\r\n* 使用get方式传递的参数附在url后，存在安全隐患。\r\n\r\n### traget\r\n与a标签的target属性一致，表示点击提交按钮之后打开新窗口的方式。\r\n### entctype\r\n指定表单数据编码方式，编码过程是在数据发送到服务器之前进行的，具体的内容目前并没有深入。\r\n### name\r\nname属性是一个非常重要的表单属性，表明表单的名称，注意name和id的区别：id用来操控CSS和JS，只存在于客户端（即浏览器中）；而name是浏览器与服务器通信时所使用的名称（比如数组键值）。两者功能不同，不能混淆。在表单和表单元素中，name是一个不可或缺的属性。\r\n\r\n## 表单元素\r\nform标签只是构成了整个表单的容器，而具体内容则是根据需要在容器中加入不同的表单元素。为了便于理解，我将表单元按功能分成了三类：文本输入，选择框和按钮三大类，当然这只是我个人的理解，其实无关痛痒。\r\n### 文本输入\r\n有text,password,textarea，分别对应文本，密码和文本域。其中前两者使用input标签并设置其type属性为对应的值来创建，其内容保存在value中；而textarea则是一个闭合的标签，会解析其中的换行与空格，此外需要注意的是使用innerHTML可以在文本框中看见其内容，但是表单提交时输入的内容保存在value中而非innerHTML；\r\n### 选择框\r\n有checkbox，radio，select，分别对应复选框，单选框和下拉菜单。前两者也是使用input标签并设置其type属性为对应的值来创建。而select是下拉菜单容器，下拉选项由options标签创建。选择框有一个比较重要的属性checked(或selected)，表示选择的状态，用于判断是否已被选中。\r\n### 按钮\r\n有file，button，submit，hidden，分别对应文件上传，普通按钮，提交按钮和隐藏按钮；其中文件上传按钮又有accept等多个属性，这里不做详细介绍，hidden在页面上不会显示，主要的作用是用来收集某些数据；而submit作为整个表单的提交，应当放在整个表单的末尾。\r\n### 注意事项\r\n表单元素最重要的属性，大概就是name和value了，前者作为服务器处理程序的数组键名，后者作为该数组某键对应值，承担着打包和整理整个表单数据的作用。其中有一些需要注意的小细节（虽然用处不大）：\r\n* input标签默认的type是text，但是一般会显示的指定type；\r\n* checkbox默认的value值是on；\r\n* 要使一组radio生效，则必须为他们指定相同的name属性值；\r\n\r\n## 其他\r\n表单事件中有两个比较重要的事件：focus和blur，分别表示获得焦点与失去焦点，多用于前端表单验证（关于使用正则验证表单）。除了checked状态之外，还有很多类似于disable的属性，可以参考jquery 表单选择器，专门为快速选择表单元素封装了一套方法。\r\n此外，默认的表单元素样式都比较朴素，网上有很多利用CSS美化表单的方式，于是这里就不再献丑了。（PHP是不是世界上最好的语言呢？/斜眼笑。今天好困，我要睡觉...）';
INSERT INTO shymean_article SET `title` = 'HTML标签', `created_at` = 1464327258, `category` = 'HTML', `tags` = '标签', `content` = '\r\n学习HTML的第一个任务就是将大大小小、形形色色的标签给弄明白，因此这里简单地回顾一下。在伟大的“结构、表现和行为分离”的指导思想下，我就不打算关注部分过时的样式格式标签和属性了。\r\n<!--more-->\r\n## 标签的语义\r\n根据标签是否有特定的含义可以将其分为语义化标签和无语义标签。\r\n### 语义化标签\r\n所谓语义化标签，就是根据标签里面的内容（内容语义化），选择合适的标签（代码语义化），从而写出更具有可读性的代码，且能够让愚笨的爬虫更轻松地解析网页内容（也就是很重要的SEO）。\r\n\r\nHTML4.1主要的几个语义化标签比如标题（h1-h6）、列表（li）、强调（strong、em）等，这些含有特定语义的标签，有自己的默认样式，能够在没有CSS的情况下，也能使页面呈现出良好的内容结构与代码结构（因此这里又引申出一个关于CSS样式重置的问题，我是一个链接）。\r\n\r\nHTML5新增了header、nav、article、sections、aside、footer等语义化标签，很显然的顾名思义。HTML5的一个理念是“语义”与“显示”分离，因此这些语义化标签能够让开发人员和浏览器对其中的内容一目了然。这些标签的功能就是代替一部分div的功能（不用再写 div id=”nav” 之类，然而我在看HTML5之前已经开始搭这个博客了，满屏幕的div，泪奔/(ㄒoㄒ)/~~），这些标签并没有任何默认样式，除了会让文本另起一行。\r\n\r\n总结就是：能用语义化标签的地方尽量语义化，让代码看的更加优雅。\r\n### 无语义标签\r\n无语义化标签就另外一个伟大的“DIV+CSS”布局思想所带来的div和span了。div的全称是divsion即整除的意思，这个标签在HTML中没有任何的含义，只是将当前的页面分割成独立的区域，所以一般需要使用class或者id来标记一个div，当然这就是CSS的事情了。\r\n而与div对应的span标签用来组合页面中的行内元素，span没有固定的格式表现，如果不对它应用样式，那么span元素中的文本与其他文本并没有任何视觉上的区别。div与span最大的区别在于他们所代表的块级元素与内联元素，接下来就会说到。画外音：“听闻很久很久以前，当网页布局还是采用表格的时候，代码十分臃肿，程序员苦不堪言balabal...”\r\n## 标签的表现形式\r\n根据标签元素的表现样式可以将其分为块状元素、内联元素和内联-块状元素。\r\n* 常用的块状元素有：div、p、h1...h6、ol、ul、dl、table、address、blockquote 、form\r\n* 常用的内联元素有：a、span、br、i、em、strong、label、q、var、cite、code\r\n* 常用的内联块状元素有：img、input\r\n初学的时候经常搞不清他们之间的区别，遇到过很多问题，下面是一点总结。\t\r\n### 块级元素特点\r\n* 每个块级元素都从新的一行开始，并且其后的元素也另起一行，也就是一个块级元素独占一行；\r\n* 元素的高度、宽度、行高以及顶和底边距都可设置；\r\n* 元素宽度在不设置的情况下且元素处于普通流的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度；\r\n* 支持所有的css命令。\r\n\r\n### 内联元素特点\r\n* 和其他内联元素都在一行上；\r\n* 元素的高度、宽度及顶部和底部margin不可设置而padding虽然可以设置，虽然背景颜色可以覆盖，但是却会与上下的元素发生遮挡，内容区域未变化，并不是普通块状元素那样内容区域下移，因此也算作不可设置上下padding；\r\n* 元素的宽度就是它包含的文字或图片的宽度，不可改变；\r\n* 两个内联元素之间的换行会被解析产生一个空格（多行换行也只产生一个），这个并不是bug而是正确的内容显示。而两个块级元素之间的换行会被忽略；\r\n* 块状元素具有的流体特性：在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；如果有margin-left/margin-right, padding-left/padding-right, border-left-width/border-right-width等，实际内容区域会响应变窄。形成了自适应效果。就像放在容器中的水流一样，内容区域会随着margin,padding, border的出现自动填满剩余空间。\r\n\r\n### 内联-块状元素特点\r\n* 和其他元素都在一行上；\r\n* 元素的高度、宽度、行高以及顶和底边距都可设置；\r\n* 也会解析换行；表现样式为inline-block的元素会触发BFC\r\n\r\n## 其他\r\n需要注意的是元素的表现样式并不是固定的，使用display属性可以轻松在块与内联之间相互转换，当然，将span转换为div，再将div转换为span使用是一件完全没有必要的事情。\r\ndiv+css是现在进行网页布局最流行的方式，掌握块状元素与内联元素的特性，才能更好的理解盒子模型、浮动与定位。HTML标签虽然是基础，却十分重要。此外在进行DIV布局与考虑语义化之间需要仔细斟酌，能够使用语义化标签就尽量使用，但是完全没有必要仅仅为了获取一个块级元素就将h1拿来用，嗯，就是这样吧。';
INSERT INTO shymean_article SET `title` = 'HTML5自定义属性', `created_at` = 1467793926, `category` = 'HTML', `tags` = 'DOM', `content` = '\r\n\r\n趁着难得的一个双休折腾了一下jQuery Mobile，（虽然后面发现其中有几个坑并且还不能用在现在的项目中），里面的data-*属性简直不要太多。最初接触BootStrap的时候也碰到过data-自定义属性，某次面试题里面也有这个知识点，却一直没有深入理解。学习jqm，虽然不大能用得上，也不能再使用“拿来主义”了，现在整理一下。\r\n<!--more-->\r\n\r\n## 作用\r\nHTML5规定可以为元素添加非标准的属性，目的是为元素提供与渲染无关的信息和语义信息，因此，如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。\r\nData-*存储的数据能够被页面上的JS利用，而在此之前主要依靠class（指定浏览器渲染当前元素规则）和rel（指定当前文档与被链接文档之间的关系），元素自身的其他特性就容易与上述两个属性的功能相违背（虽然也能达到部分效果，比如给类取一个语义性的名称），而通过自定义的属性，就可以达到对其元素进行搜寻、过滤以及分组等动作。\r\n\r\n## 设置\r\n只需要在属性名前加上”data-”开头即可设置标签的自定义属性，然后将整个属性放在对应的标签下。里面的内容可以是任意的相关属性。\r\nW3Cschool上面说data-后面的属性名不能包含大写字母，但是我试了一下，用该属性控制CSS样式仍旧是会生效的，只是观察到浏览器会自动将大写转换成小写字母，因此这里应当是自定义属性不区分大小写，至于为什么会说属性名不要包含大写字母，大概是DOM中的dataset属性（马上就会谈到），其属性都是忽略”data-”开头的，与font-size等属性一样采用驼峰命名法的方式获取的，因此为了不产生歧义，如果只有一个单词，最好采用全小写的写法，且自定义属性的修饰名词不要过长，毕竟并没有对其数量的限制，大不了多写两个属性嘛！下面是关于命名大小写的例子。\r\n```\r\n    <style type=\"text/css\">\r\n        [data-name=\"t\"] { background-color: #ccc}\r\n    </style>\r\n\r\n    <div id=\"t\" data-name=\"t\">\r\n        Hello World!\r\n    </div>\r\n```\r\n普通的情况下，div元素背景会变成灰色；然后将自定义属性名改成data-Name,其余不作变动，可以看见容器的背景颜色仍然为灰色，然而通过DOM获取到的属性就会发现：\r\n```\r\n    var t = document.getElementById(\"t\");\r\n    alert(t.dataset.name);//tang\r\n    alert(t.dataset.Name);//undefined\r\n```\r\n此外还发现一个有趣的现象，当更改的是HTML中的属性名为Name，CSS中的属性仍为name时，将会在脚本执行完毕之后再将容器背景渲染为灰色；当更改的是CSS中的属性名为Name，HTML中的属性仍为name时，将在脚本执行之前将背景渲染为灰色，这个大概跟浏览器的渲染流程有关系（使用的是chrome）;\r\n当以短横线连接的属性名时，DOM获取属性遵循的是驼峰命名法：\r\n```\r\n    <div id=\"t\" data-name-t=\"t\">\r\n        Hello World!\r\n    </div>\r\n\r\n    alert(t.dataset.nameT);//tang\r\n```\r\n\r\n## 使用\r\n上面巴拉巴拉说了一些，其实都是些无关痛痒的话，到底发该怎么使用自定义属性呢？\r\n其实jQuery Mobile中大量使用了自定义属性，并使用JS动态设置样式。其原理就是：脚本检测容器的自定义属性，并在具有某自定义属性的容易上动态添加对应的样式类；这样就成功地将样式类与容器标签给分开了，相当于事先准备好了大量的样式并在设置自定义属性的时候调用这些样式，虽然仅仅使用类名也可以达到这样的目的。（顺便吐槽一下jqm的默然data-ajax属性，以及只能在服务器环境下使用，以及不太流畅的体验...）关于自定义属性在jqm中的用法可以看看[这篇文章](http://www.jb51.net/html5/67809.html)。\r\n好了，那就到这里了吧，jquery中的data方法貌似更加好用，且解决了兼容性的问题噢。';
INSERT INTO shymean_article SET `title` = 'JavaScript中构建对象', `created_at` = 1466433336, `category` = 'JavaScript', `tags` = '面向对象, 原型', `content` = '\r\nJS中的面向对象与C++中的面向对象有很大不同。由于不存在类的概念，在初学JS的面向对象时略感困惑。《JS高级程序设计中》关于这一块讲的十分精彩。先来整理一下关于JS创建对象的方法。\r\n<!--more-->\r\n\r\n## 对象字面量\r\n可以使用对象字面量来创建一个对象。\r\n```\r\n    var bird = {\r\n        name:\"crow\",\r\n        age:3,\r\n        fly:function(){\r\n            alert(\"I\'m \"+this.name+\", I\'m flying \"+this.age+\" years!\");\r\n        }\r\n        }\r\n    bird.fly();\r\n```\r\n* 优点：直接明了，相当于只是创建了一个引用数据类型的变量；\r\n* 缺点：只限于一个对象，当使用同一个接口创建多个对象时，会产生大量重复的代码；\r\n\r\n## 工厂模式\r\n可以创建一个函数，并在其中创建一个空对象，将需要的属性值作为参数赋给对象属性，并将获得值之后的属性返回。\r\n```\r\n    function createBird(name,age){\r\n        var o = new Object();\r\n        o.name = name;\r\n        o.age = age;\r\n        o.fly = function(){\r\n            alert(\"I\'m \"+this.name+\", I\'m flying \"+this.age+\" years!\");\r\n        }\r\n        return o;\r\n        }\r\n    var bird = createBird(\"crow\",3);\r\n    bird.fly();\r\n```\r\n* 优点：抽象了创建具体函数的过程，可以创建多个相似的对象；\r\n* 缺点：无法知道对象的类型（只能是Object）。\r\n\r\n## 构造函数\r\n构造函数与工厂模式类似，只是在其外部采用new调用，在其内部采用this代替显式创建空对象。构造函数名称首字母一般大写。\r\n```\r\n    function Bird(name,age){\r\n        this.name = name;\r\n        this.age = age;\r\n        this.fly = function(){\r\n            alert(\"I\'m \"+this.name+\", I\'m flying \"+this.age+\" years!\");\r\n        }\r\n    }\r\n    var bird = new Bird(\"crow\",3);\r\n    bird.fly();\r\n```\r\n* 优点：可以识别实例对象的自定义类型（即构造函数名）。\r\n* 缺点：所有的实例对象无法共享相同的属性和方法，造成内存的浪费。\r\n\r\n## 原型模式\r\nprototype是函数中一个非常重要的属性，接下来重点理清这个问题。\r\n* 首先需要明白，无论什么时候，只要新建了一个函数，就会为该函数创建一个prototype属性，这个属性指向了函数的原型对象；\r\n* 其次，JS中的所有对象都有原型对象， 而所有的原型对象都有一个constructor属性，这个属性是一个指向prototype属性所在函数的指针；因此Bird.prototype.constructor就指向了构造函数Bird本身。\r\n* 当自定了一个构造函数时（使用new调用），这个构造函数的原型对象默认只会获取到constructor属性，并继承Object的属性和方法；\r\n* 当使用该构造函数实例一个对象时，这个对象内部将包含一个指向其构造函数的原型对象的指针（__proto__或者[[prototype]]），需要注意的是这个属性是连接实例对象与其构造函数的原型对象，而不是连接实例对象与构造函数。\r\n\r\n关于原型对象有几个比较重要的知识点，如下。\r\n### 查询\r\n* 当代码读取对象的某个属性时，会逐步搜索该属性名：\r\n* 首先从实例对象本身开始，如果找到则返回；\r\n* 如果没有找到，则搜索__proto__指针所指向的原型对象，如果找到则返回；\r\n* 可以使用in操作符判断对象是否拥有该属性值（无论是自定义的还是从原型继承而来的）。\r\n\r\n### 赋值\r\n* 可以通过搜索查询原型对象中的值（包括属性和方法），却无法通过对象实例修改原型对象中的值；\r\n* 当为实例对象添加了一个属性，如果原型对象中存在同名属性，则会被实例对象的属性所覆盖；\r\n* 如果原型对象中不存在该同名属性，该属性也只是该实例对象所独有的，并不能被原型对象下的其他实例对象所共享；\r\n* 在添加的属性之后又希望重新访问原型对象中同名属性的值，可以使用delete删除实例对象中覆盖的属性并恢复对于原型对象中属性的访问。\r\n* 可以通过hasOwnProperty()方法检测属性是实例对象所独有的还是继承自原型对象的，返回true表示该属性为实例对象所独有。\r\n\r\n### 简化原型对象\r\n* 每次使用Bird.prototype.pro就显得十分麻烦，更常见的做法是采用一个包含所有属性和方法的对象字面量来重写整个原型对象，即Bird.prototype = {...}；\r\n* 这么做相当于重写了这个prototype，并且其constructor属性会指向Object函数而不是自定义的Bird构造函数，解决这个问题的办法是显示的声明prototype的constructor属性值。\r\n\r\n### 原型的动态性\r\n* 由于对实例对象的属性查询是一个搜索过程，且每次查询都会执行该搜索过程，因此可以在程序中随时为原型对象增加属性和方法，并在之后的代码中实例对象中访问这些共享的属性和方法（即使这个实例对象先于新增属性而创建）；\r\n* 尽管可以随时为原型添加属性和方法，并在修改之后可以被所有的实例对象所访问；但是如果重写整个原型对象（比如采用对象字面量赋值的方式），会切断前面创建的实例对象与原型对象之间的联系（他们是通过__proto__指针相关联的，而对象是引用数据类型，采用赋值会将原型对象重新指向了另一块堆内存，因此实例对象的__proto__属性仍指向先前的原型对象“所指的内存”，理解可能有误，请批评指正），而先前的实例对象，引用的仍然是最初的原型对象。\r\n```\r\n    function Bird(){\r\n        Bird.prototype.name = \"crow\";\r\n        Bird.prototype.age = 3;\r\n        Bird.prototype.home = [\"tree\",\"grass\"]\r\n        Bird.prototype.fly = function(){\r\n            alert(\"I\'m \"+this.name+\", I\'m flying \"+this.age+\" years!\");\r\n        }\r\n    }\r\n    var bird1 = new Bird();\r\n    var bird2 = new Bird();\r\n    bird1.fly();//crow\r\n    bird2.name = \"duck\";\r\n    bird2.fly();//duck\r\n\r\n    bird1.home[0] = \"appleTree\"\r\n    alert(bird2.home[0]);//appleTree\r\n```\r\n\r\n最后是使用原型模式的优缺点：\r\n* 优点：所有实例对象都共享原型的全部属性及方法。\r\n* 缺点：也是由于其共享的特点，对于基本数据类型而言还好，可以通过自定义属性的方法进行覆盖；而对于引用数据类型而言，在一个实例对象上对其进行修改，其结果同样会出现在另外一个实例对象上，违背了面向对象的封装原则。\r\n\r\n## 构造函数与原型组合\r\n采用构造函数定义各自的实例属性，采用原型定义方法与共享的属性。\r\n```\r\n    function Bird(name,age){\r\n        this.name = name;\r\n        this.age = age;\r\n        this.home = [\"tree\",\"grass\"]\r\n    }\r\n    Bird.prototype = {\r\n        showhome:function(){\r\n            alert(this.home);\r\n        },\r\n        fly:function(){\r\n            alert(\"I\'m \"+this.name+\", I\'m flying \"+this.age+\" years!\");\r\n        }\r\n    }\r\n\r\n    var bird1 = new Bird(\"crow\",3);\r\n    var bird2 = new Bird(\"duck\",5);\r\n    bird1.fly();//crow\r\n    bird2.name = \"swan\";\r\n    bird2.fly();//duck\r\n\r\n    bird1.home[0] = \"appleTree\"\r\n    bird2.showhome();//tree,grass\r\n```\r\n这样，每个实例对象都会有自己独立的属性，并共享原型对象的方法和属性，最大程度节省了内存。\r\n## 其他\r\n### 寄生构造函数\r\n与工厂模式类似，仅仅是封装创建对象的代码，但是又采用new调用该函数。书上建议在可以使用其他构造模式的情况下不要采用这种方法。\r\n### 稳妥构造函数\r\n所谓稳妥指没有公共属性，稳妥构造函数中对象的方法不引用this，因此无法通过其他方法访问该构造函数中的变量。也不建议使用。\r\n## 最后\r\nJS中创建对象虽然有多种模式，但是最常见的还是对象字面量创建以及组合构造函数与原型模式这两种方式来创建对象。原型是JS中需要深入掌握的一个概念，接下来的学习内容是大名鼎鼎的原型链继承。';
INSERT INTO shymean_article SET `title` = 'JS中的变量作用域', `created_at` = 1464963203, `category` = 'JavaScript', `tags` = '作用域', `content` = '\r\n\r\n最初接触“词法域”的概念是在Lua的学习过程中。所谓“词法域”指的是：若将一个函数写在另一个函数之内，那么这个位于内部的函数可以访问外部函数中的局部变量。由于变量函数作用域与C++中的块级作用域完全不一样，当时理解真是煞费苦心。现在在JS中居然又碰见了词法作用域，可谓是感叹万分呀！毕竟看Lua纯粹只是当时的一点兴趣罢了。下面就是关于JS中的变量作用域，以及对于闭包的简单理解。\r\n\r\n<!--more-->\r\n\r\nJS中的变量作用域分为全局作用域与函数作用域。所谓全局作用域，指的是不再任何函数内声明的变量的作用域。全局变量可以看作是全局对象的属性。这篇文章主要关注的是函数作用域。\r\n\r\n《JavaScript权威指南》关于JS函数作用域的定义是：变量在声明他们的函数体内以及这个函数所嵌套的任意函数体内都是有定义的（作用域链），且声明的变量在函数体内都是可见的（即变量声明提前）。\r\n\r\n## 变量声明提前\r\n\r\n了解JS解释器的工作过程对于理解“变量声明提前”很有帮助。惭愧的是对于编译原理、操作系统等计算机知识一无所知，因此这个具体的过程我并不知道一丁点的东西，这大概也是相对于科班出身的同学来说，自己很大的短板。啊扯远了。JS解释器工作过程可分成“预解析”与“逐行运行代码”两部分。\r\n\r\n* 预解析：根据var function等声明寻找找所有的变量及函数，在正式运行代码前所有的变量都赋值为undefined，而所有的函数都只是函数块（不会调用函数）；然后将变量放在一个“仓库”（只是为了理解罢了，可以理解为作用域的具体化），如果遇见与变量名相同的函数，则保留函数；如果是重名函数，则后声明的函数会覆盖前面声明的函数；如果只是两个变量重名，由于提前赋值均为undefined，因此并没有什么区别。\r\n\r\n* 逐行运行代码：按程序逐行运行代码，遇见变量则从“仓库”中取出并使用。因此即使函数放在最下面，也可以在其声明之前调用；当遇见赋值表达式的时候，存放在仓库中的变量值会被改变。\r\n\r\n下面通过一个例子说明。\r\n\r\n```\r\n\r\n    alert(a);//function a(){alert(4);}\r\n\r\n    var a = 1;\r\n\r\n    alert(a);//1\r\n\r\n    function a(){alert(2);}\r\n\r\n    alert(a);//1\r\n\r\n    var a = 3;\r\n\r\n    alert(a);//3\r\n\r\n    function a(){alert(4);}\r\n\r\n    alert(a);//3\r\n\r\n```\r\n\r\n通过运行代码可以看见：\r\n\r\n* 第一次弹出的是//function a(){alert(4);}整个代码块；\r\n\r\n* 第二次弹出的是1（由于其前面那句的赋值表达式改变了仓库中的值，从一个函数块变为了1）；\r\n\r\n* 第三次弹出的仍然是1；\r\n\r\n* 第四次弹出的是3；\r\n\r\n* 第五次弹出的仍然是3；\r\n\r\n可以看见，虽然声明了函数，但是并没有调用它，在代码运行的过程中声明的函数被覆盖，且在整个程序结束之后，a为一个数字而非函数了,当使用a()时会报错。\r\n\r\n## 作用域链\r\n\r\n当从全局域的第二步（也就是上面所说的逐行运行代码）到一个函数调用的时候，进入函数作用域，并在函数作用域开始预解析，过程与全局域相同。首先将变量放在另外一个小的独立仓库（即该函数作用域），需要注意的是形参也是变量声明因此也会被放入“仓库”。然后开始逐行运行函数中的代码，遇见变量则优先从该函数的仓库里寻找变量，如果有，则使用其值；如果没有则从父级的仓库逐步向上寻找（作用域链）；继而如果从全局仓库都没有找到，程序就会报错。\r\n\r\n函数中的局部变量可以看作是调用该函数的那个对象的自定义属性，那么可以换个角度理解作用域链。 每一段代码（全局代码或者函数块）都有一个与之相关的作用域链，这个链是一个对象列表，这组对象定义了作用域中的变量，当需要查找某个变量时，将从第一个对象（最近的那个函数作用域）一直寻找至全局对象。下面这个例子:\r\n\r\n```\r\n\r\n    var a = 1;\r\n\r\n    var b = 1;\r\n\r\n    function f(){\r\n\r\n        alert(a);//undefine\r\n\r\n        alert(b);//1\r\n\r\n        //alert(c);//报错\r\n\r\n        var a = 2;//不会更改全局仓库里面的值，如果没有前面的var关键字，则会修改全局仓库里面的值\r\n\r\n    }\r\n\r\n    f();\r\n\r\n    alert(a);//1\r\n\r\n```\r\n\r\n可以看见，当调用f()时，由于首先进行的预解析，因此alert(a)并不会报错而是一个undefined；由于b元素是上一个作用域链的变量（更大的那个仓库），因此会显示1；由于c并没有声明，且又不存在于作用链中，因此会报错。\r\n\r\n如果在上面的例子中为f()声明传入一个参数，但是调用的时候不传实参进去，且不在函数体内单独声明该变量则会出现下面情况。\r\n\r\n```\r\n\r\n    var a = 1;\r\n\r\n    var b = 1;\r\n\r\n    function f(a){\r\n\r\n    alert(a);//undefine\r\n\r\n    a = 2;\r\n\r\n    }\r\n\r\n    f();//不传参数\r\n\r\n    alert(a);//1\r\n\r\n```\r\n\r\n这就是前面所说的形参也可以看做是局部变量声明。\r\n\r\n但是如果在调用的时候将实参（全局作用域里面的变量）传进函数，则相当于在函数内部的第一句表达式之前隐藏着 var a (形参)= a（实参）。由于函数域仓库存在着变量，因此就不会改变父级变量的值（JS中并没有C++类似的指针或者引用，如果想要改变父级变量的值，则直接使用作用域链上的变量而不要在单独声明新的变量。）\r\n\r\n```\r\n\r\n    var a = 1;\r\n\r\n    var b = 1;\r\n\r\n    function f(a){\r\n\r\n        alert(a);//1\r\n\r\n        a = 2;\r\n\r\n        b = 0;\r\n\r\n    }\r\n\r\n    f(a);//将a传入函数\r\n\r\n    alert(a);//1\r\n\r\n    alert(b);//0\r\n\r\n```\r\n\r\n## 最后\r\n\r\n这篇文章是最初学习JS时所做的笔记了，在整理的时候发现了一些错误并已经纠正。变量作用域是学习JS中很重要的一点，接下来就应该整理一下闭包了。';
INSERT INTO shymean_article SET `title` = 'JS模板引擎（初级篇）', `created_at` = 1483179742, `category` = 'JavaScript', `tags` = '正则, 模板引擎', `content` = '\r\n\r\n之前的项目中，通过ajax请求获得的数据，重新在页面上渲染出来，基本上都是采用字符串拼接或者定义一个`type/html`的script标签，然后通过jQuery查找结点然后插入数据的，在数据量不大的情况下，这么做貌似也没有什么问题。但是昨天遇见的情况是返回好评、中评、差评的多条数据，，且每天评论需要展示的内容十分多，因此考虑使用第三方的模板引擎库。\r\n\r\n<!--more-->\r\n我找了两个库`jquery.tmp`和`doT.js`，感觉都不太合适（没有for指令），但对于模板引擎的原理并不是十分了解（尽管在微擎的项目里遇见过N多使用模板引擎的地方），因此准备学习一下。\r\n我在网上找到了一篇[《20行JS代码实现一个JS模板引擎》](http://blog.jobbole.com/56689/),真是妙不可言。下面是关于这个模板引擎的一些学习整理和思考，管中窥豹，大致也学到了关于模板引擎的基本原理。\r\n\r\n## 基本思路\r\n首先先理一理，写一个模板引擎的目的是什么？为了展示数据，详细一点，就是要在一段已经确定（样式已经确定）的HTML结构中展示数据，通过`innerHTML`就可以轻松完成。\r\n```\r\nvar data = {\'name\':\'txm\', \'age\':23};\r\nvar htmlStr = \'<p>name is: \' + data.name + \' , age is : \' + data.age +\'</p>\';\r\n$(\"#target\").html(htmlStr)\r\n```\r\n或者稍微复杂一点的，可以使用`type/html`模板\r\n```\r\n// tpl\r\n<script type=\"text/html\" id=\"tpl\">\r\n    <p>name is : <span class=\"name\"></span>, age is + <span class=\"age\"></span></p>\r\n</script>\r\n\r\n// js\r\nvar dom = $($(\"#tpl\").html());\r\ndom.find(\".name\").text(data.name);\r\ndom.find(\".age\").text(data.age);\r\n$(dom).appendTo($(\"body\"));\r\n```\r\n第一种方式的弊端显而易见，需要在JS代码中拼接大量的字符串。\r\n第二种方式也不可避免的需要书写大量的JS代码来操作节点，且必须使用相应的标签来包裹对应的数据，虽然可以用下面这种方式取巧\r\n```\r\nvar dom2 = $($(\"#tpl\").html());\r\nfor (var key in data){\r\n    dom2.find(\".\"+key).text(data[key]);\r\n}\r\n$(dom2).appendTo($(\"body\"));\r\n```\r\n必须按照一定的规律对相应数据包裹标签进行命名，这大大限制了扩展性。另外对于一些数据的判断和遍历，也必须书写相关的逻辑代码。\r\n\r\n因此，模板引擎的作用就出来了。跟上面第二种方法类似，预留一个模板，模板中相应的数据使用模板标签标记，模板标签将按照引擎的规则进行解析，然后在需要的时候调用数据渲染对应的模板，最后输出在页面上。\r\n整理一下思路：\r\n* 按照需要的HTML结构定义一个模板\r\n* 在模板中按照一定的语法填写模板标签\r\n* 输入数据，并解析相应的模板标签，输出一段HTML结构\r\n* 将结构插入到页面中，大功告成\r\n\r\n由此可见，最主要的功能就是解析模板标签的语法，那么如何实现呢？使用__正则表达式__和`new Function()`。\r\n\r\n## 简单实现\r\n\r\n### 正则替换\r\n使用正则表达式可以实现简单的字符串替换，即将变量占位符替换成实际的数据，这里直接使用原文中的例子，也采用了相同的`<%`和`%>`，只是改变了作者使用的正则表达式。\r\n```\r\nvar data = {\'name\':\'txm\', \'age\':23};\r\nvar tpl = \'<p>Hello, my name is <%name%>. I\\\'m <%age%> years old.</p>\';\r\n\r\nvar re = /<%([^]+?)(?=%>)%>/g;\r\nvar res = null;\r\nwhile (res = re.exec(tpl)){\r\n    var key = $.trim(res[1]); // 获取键名\r\n    tpl = tpl.replace(res[0],data[key]);\r\n}\r\nconsole.log(tpl);\r\n```\r\n使用分组里面的值作为键名，获取到相应的数据，然后将模板字符串中的占位符进行替换。但是很明显，这种做法在存在嵌套数据的情况下不起作用，因为解析出来的`xx.prop`会被当作一个普通的字符串键名，这种情况下就会返回undefined。\r\n\r\n### new Function\r\n为了解决这个问题，作者使用了`new Function()`定义函数的方法（这真是太奇妙了，尽管之前知道这种创建函数的方法，但是没想到还能这样使用）。\r\n```\r\nvar fn = new Function(\'a\',\'console.log(a+1)\');\r\nfn(2); // 3\r\n```\r\n尽管解析的是一个字符串，但是在函数中是可以正常执行的，这样什么嵌套属性，`for,if`的问题都能解决了。\r\n将一段可以执行解析数据功能的代码，当作`new Function`的构造参数传入，作为这个函数的函数体，然后调用这个函数，并返回数据解析后拼接成的字符串，大功告成。我们的目标已经从如何解析模板标签，缩小到如何拼接一段可以执行解析操作的代码字符串。\r\n原文中使用了一个空数组，并借助一个保存偏移量的游标`cursor`，通过`push()`和`join(\'\')`的方法拼接字符串，实际上，使用`+`进行拼接也是可以的（貌似现在`+`的速度更快）。\r\n\r\n先不要纠结代码怎么写，而应该着眼于函数体的字符串实现的功能：一段可以执行的JS代码，输入的是一个数据（JSON），输出的是整个模板的内容。单纯的实现这个功能，伪代码如下\r\n```\r\nfunction fn(data){\r\n    var str = \'\';\r\n    str += 正常的模板内容（字符串）; // 可能会出现在多个地方\r\n    // 解析数据\r\n    str += data.数据;\r\n    // 解析操作符\r\n    for (...){\r\n    \tstr += data.xx...\r\n    }\r\n    // 同解析操作符\r\n    if (...){\r\n    \tstr += data.xx...\r\n    }\r\n    // 返回模板内容\r\n    return str;\r\n}\r\n```\r\n下面来试一试如何拼接这段函数体代码的字符串呢（注意这里是拼接整个函数的代码块，而不是拼接模板内容的字符串，处理模板内容这个功能是在该函数中实现的，这里就当作是使用一种比较独特的方法来写函数）。来一个不包含条件和循环的简单例子:\r\n```\r\nvar data = {\'name\':\'txm\', \'profile\':{\'age\':23}};\r\n\r\nvar tpl = \'<p>Hello, my name is <%data.name%>. I\\\'m <%data.profile.age%> years old.</p>\';\r\nvar re = /<%([^]+?)(?=%>)%>/g;\r\nvar res = null;\r\n\r\n// 拼接函数体字符串\r\nvar fnStr = \'var str = \"\";\\n\';\r\nvar cursor = 0;\r\n// 解析模板\r\nwhile (res = re.exec(tpl)){\r\n    fnStr += \'str += \"\' + tpl.slice(cursor, res.index) + \'\";\\n\';\r\n    fnStr += \'str += \' + res[1] + \';\\n\';\r\n\r\n    // 挪动游标\r\n    cursor = res.index + res[0].length;\r\n}\r\n\r\nfnStr += \'str += \"\' + tpl.substr(cursor) + \'\";\';\r\nfnStr += \'return str;\';\r\n\r\n// 构造函数\r\nvar fn = new Function(\'data\',fnStr);\r\n\r\n// 调用函数\r\nconsole.log(fn(data));\r\n```\r\n哈，在函数体中，使用字符串拼接模板内容，比用数组貌似更直观。\r\n\r\n### 解析语义标签\r\n上面只是解决了基本的变量解析的问题，其实还有另外一个没有展示出来的问题，如果模板引擎中出现双引号，则拼接的代码字符串在插入函数体之后会报错，因此我们需要对引号进行转义。\r\n```\r\n// 将普通模板标签中的双引号转义\r\nfnStr += \'str += \"\' + tpl.slice(cursor, res.index).replace(/\"/g,\"\\\'\") + \'\";\\n\';\r\n```\r\n最后，只要稍微处理一下标签，将`str += ...`放在相应的代码块中间就可以完成对`for`,`if`等语句的解析，最后，整个模板引擎的解析如下\r\n```\r\nvar data = {skills: [\"js\", \"html\", \"css\"]};\r\nvar tpl = \'My skills:\' \r\n        + \'<%for(var index in data.skills) {%>\' \r\n        + \'<a href=\"#\"><%data.skills[index]%></a>\' \r\n        +\'<%}%>\';\r\n\r\nvar re = /<%([^]+?)(?=%>)%>/g;\r\n// 用于检测是否存在JS关键词\r\nvar jsExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g;\r\nvar res = null;\r\n\r\nvar fnStr = \'var str = \"\";\\n\';\r\nvar cursor = 0;\r\n\r\nwhile (res = re.exec(tpl)){\r\n\r\n    fnStr += \'str += \"\' + tpl.slice(cursor, res.index).replace(/\"/g,\"\\\'\") + \'\";\\n\';\r\n\r\n    if (jsExp.test(res[1])) {\r\n    \t// 如果存在则直接保留\r\n        fnStr += res[1] + \'\\n\';\r\n    }else {\r\n    \t// 否则进入字符串拼接环节\r\n        fnStr += \'str += \' + res[1] + \';\\n\';\r\n    }\r\n\r\n    cursor = res.index + res[0].length;\r\n}\r\n\r\nfnStr += \'str += \"\' + tpl.substr(cursor) + \'\";\';\r\nfnStr += \'return str;\';\r\n\r\nvar fn = new Function(\'data\',fnStr);\r\n\r\nconsole.log(fn(data));\r\n\r\n```\r\n至此，一个简单的模板引擎原理剖析结束，剩下要做的就是将整个代码封装一下，传入数据，返回模板字符串，插入页面，大功告成。\r\n\r\n## 最后\r\n现在大概了解了一点模板引擎的原理，实际上，模板引擎的实现有多种方法，比如也可以使用`eval()`函数等。\r\n另外，一个真正的模板引擎还应当是第一次运行执行模板解析后将模板字符串进行缓存，在之后的模板渲染过程中就不必再执行重复工作了（但是如果模板存在循环的话，则返回的模板字符串就不一定是固定的了）。\r\n类似的优化应当还有很多，比如使用更严谨高效的正则，这些知识就等待接下来的学习吧。';
INSERT INTO shymean_article SET `title` = 'LESS学习笔记', `created_at` = 1465560728, `category` = 'CSS', `tags` = 'Less', `content` = '\r\n在招聘要求中看见的需要熟悉LESS/SASS，然而我一个都没见过。LESS是一种动态样式语言，可以对代码进行预编译生成所需的CSS代码（呃我是这么理解的，有失偏颇），反正是了结了我“HTML和CSS哪能算编程语言呢”的疑惑。查了些资料学习了一下，当然现在学到的只是皮毛，也有不少疑惑。\r\n注：使用的编译工具是Koala。\r\n\r\n<!--more-->\r\n\r\n开头先感谢两篇文章[w3cplus](http://www.w3cplus.com/css/less)和[bootcss](http://www.bootcss.com/p/lesscss/)，简洁明了，通俗易懂。\r\n## 变量\r\n@vname，相当于定义了一个可重复利用的值，只需要修改定义变量的数值就可以修改使用该变量的属性，需要注意的是变量只能被定义一次(后定义的变量会覆盖前面的变量)，类似于c++宏或者const常量。可以把颜色属性值red,blue等看做是css中定义好的变量，只是less中的变量使用范围广泛得多了。\r\n变量可以计算，还可以将变量名定义为变量。\r\n## 混合\r\n可以将经常重复使用的样式整合在一起写成单独的类，再嵌套进所需要的选择器中，这个类可以传入参数甚至带上默认参数，是不是很函数很像？没错，相当于定义了一个函数并在所需要的选择器中进行调用。\r\n多个参数可以使用逗号隔开，当传入的参数表示复合属性的时候，可以使用@arguments参数代替。\r\n## 嵌套规则\r\n当书写组合，后代选择器的时候，可以使用嵌套，很直观的看出HTML的DOM结构层次，大大减少了代码量（只是表面的假象，一味的嵌套编译生成的CSS代码选择器会多到吓死人）。\r\n在嵌套中需要注意的是&的使用，使用&表示多类选择器，而不加&表示后代选择器。\r\n## 运算符与函数\r\nLess中的Operations主要是针对任何数字、颜色、变量的操作，可以对其是行加、减、、乘、除或者更复杂的综合运算；而Functions主要是针对Color funtions 加减时忽略其单位名字，颜色函数主要有lighten(@color,10%),darken,saturate,desaturate,fadein,fadeout,spin等，以实参颜色为标准进行处理并返回新的颜色。\r\n## 命名空间\r\n如果有两个选择器的样式完全相同，则可以将一个选择器的样式引用到另一个选择器样式上面。\r\n```\r\n    #one a {\r\n        color: red;\r\n        #two > .button;//将a标签样式引到.button类上\r\n    }\r\n```\r\n这样不会造成书写混乱不堪吗？这么做节省的代码量与逻辑条理哪个更重要呢？\r\n## 变量范围\r\n变量作用范围采用就近原则，元素先找本身有没有这个变量存在，如果本身存在，就取本身中的变量，如果本身不存在，就寻找父元素，依此类推，直到寻找到相对应的变量。\r\n\r\n## 注释\r\n跟其他语言相同，\"//\"和\"/**/\"\r\n\r\n## 最后\r\n跟学习任何东西一样，如果想掌握Less需要大量的练习，目前的问题是找不到使用Less的理由，比如一个变量，在拿到设计图之后并不知道每个模块具体的尺寸颜色等，需要同设计沟通。可能在CSS使用熟练之后会养成一定的直觉吧。多练习多练习。\r\n使用Less能够节省很多编写CSS代码的时间，且代码的可读性很强；但是冥冥之中感受到实际编译生成的CSS代码量并不会减小，根据“样式重用”的思想，如果滥用混合可能会造成代码的臃肿，这是我个人的一点感觉，毕竟刚学习Less，应当在使用中给自己提个醒，选择性的学习，有待深入。';
INSERT INTO shymean_article SET `title` = 'JS面向对象之原型继承', `created_at` = 1467038613, `category` = 'JavaScript', `tags` = '面向对象, 原型', `content` = '\r\n前面理清了JS面向对象中的构建对象，其中谈论到了原型的概念，以及使用组合构造函数和原型模式的方法来创建对象。接下来总结一下关于JS中继承的问题，继承可分为接口继承（只继承方法签名）和实现继承（继承具体方法）两种。\r\n<!--more-->\r\n由于JS中的变量是松散类型，且JS中的函数不限制参数个数，参数类型和参数顺序，因此函数并没有函数签名，因此JS只支持实现继承，且主要依靠原型链来实现的。\r\n\r\n## 原型链继承\r\n### 原型链\r\n首先来理一理原型链。（接下来的语言十分啰嗦，只是为了让自己理清整个思路，敬请谅解。）\r\n从原型模式构建对象可知，每个构造函数都有一个原型对象，而原型对象有一个属性constructor指向该构造函数，且每个构造函数的实例对象都有一个指向原型对象的指针（__proto__），所有实例对象共享原型对象的方法和属性（默认情况下原型对象只有constructor属性，根据需求自行添加），那么问题来了：如果让构造函数A的原型对象等于另外一个构造函数B的实例时，会发生什么情况呢？\r\n答案是显而易见的：构造函数A的原型对象（也就是构造函数B的实例对象）含有一个指向构造函数B的原型对象的指针（__proto__），且构造函数A的所有实例对象都可以访问构造函数B的原型对象所具有的属性和方法。如此层层递进，则构成了实例与原型的链条，这就是原型链的基本概念。下面我用一个图来简单的描述这个过程。\r\n![原形链](uploads/object.png)\r\n\r\n### 实现原型链继承\r\n实现原型链有一种十分简单的方式，直接显式地将父构造函数的实例对象赋值给子构造函数的原型对象（与其说赋值，不如说将子构造函数的原型对象重新指向新的父实例对象），用来替换其原本的原型对象（所有函数的原型对象都是Object的实例）。\r\n```\r\n    function f(name){\r\n        this.name = name;\r\n    }\r\n    f.prototype = {\r\n        say:function(){\r\n            alert(this.name);\r\n        }\r\n    }\r\n    function s(age){\r\n        this.age = age;\r\n    }\r\n    s.prototype = new f(\"tang\");//替换子构造函数的原型对象\r\n    s.prototype.show = function(){\r\n        alert(this.age);\r\n    }\r\n    var t = new s(18);\r\n    t.say();//使用father原型对象的方法\r\n    t.show();//使用son原型对象的方法\r\n```\r\n通过原型链可以实现子实例对象访问父原型对象的属性和方法，但是有时候需要覆盖某个方法，或者是为子对象（子实例对象或者子原型对象）添加某个方法，直接在子对象上添加或重写属性和方法即可，惟一需要注意的地方是这些代码一定要放在“使用父实例对象替换子原型对象”的操作之后，否则在添加方法之前原型链根本就没有形成，而形成原理链的赋值过程会重写子构造函数的原型对象，导致之前所添加或修改的方法无法生效。\r\n```\r\n    s.prototype.show = function(){\r\n        alert(this.age);\r\n    }\r\n    s.prototype = new f(\"tang\");\r\n    var t = new s(18);\r\n    t.say();\r\n    t.show();//由于子原型对象被后替换，因此show方法无法被使用，这儿会报错\r\n```\r\n同样的原因，在通过原型链实现继承的时候，无法使用对象字面量来创建原型，这样也会重写整个原型链，导致之前的继承原型链被破坏。\r\n### 问题\r\n使用原型链是JS中实现继承的主要手段，但是仍然存在一些问题：\r\n* 由于是使用实例作为子原型对象，则该实例中的引用数据会被其子实例对象共享（即使该引用数据在父实例对象之间是各自独有的），无法达到封装的要求；\r\n* 也是由于是使用实例作为子原型对象，则该父实例对象在创建过程中已经向其构造函数中传递参数，生成的父实例对象的值已经固定，在使用子构造函数创建子实例对象的时候，再也无法通过向父构造函数传参的方式改变子原型对象（父实例对象）的属性。\r\n```\r\n    function f(){\r\n        this.firends = [\"Jack\",\"Rose\"];\r\n    }\r\n    function s(){\r\n    }\r\n    s.prototype = new f();\r\n\r\n    var t1 = new s();\r\n    alert(t1.firends);//Jack,Rose\r\n    var t2 = new s();\r\n    t2.firends.pop();\r\n\r\n    alert(t1.firends);//Jack\r\n    alert(t2.firends);//Jack\r\n```\r\n\r\n## 借用构造函数继承\r\n解决上述问题采用一种叫做“借用构造函数继承”的技术（也叫做经典继承），即在子构造函数的内部使用call或者apply调用父构造函数，相当于将创建父实例对象的时间延迟到创建子实例对象的时候，并在创建每个子实例对象的时候都会调用父构造函数，且可以向父构造函数传入参数。\r\n但是采用这种经典继承的方法无法避免的问题就是在父构造函数中定义的方法在每个子实例对象都有一份副本。\r\n```\r\n    function f(){\r\n        this.firends = [\"Jack\",\"Rose\"]\r\n        this.say = function(){\r\n            alert(this.firends);\r\n        }\r\n    }\r\n    function s(){\r\n        f.call(this,name);\r\n    }\r\n    var t1 = new s();\r\n\r\n    var t2 = new s();\r\n    t2.firends.pop();\r\n\r\n    alert(t1.say == t2.say);//false\r\n    alert(t1.firends);//Jack,Rose\r\n    alert(t2.firends);//Jack\r\n```\r\n## 组合继承\r\n由于经典继承的一些问题，在实际中最常用的继承方法是将原型链和经典继承方法结合起来，使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承，既保证了原型上方法的公用，又保证了每个实例都有它自己的属性。\r\n```\r\n    function f(name){\r\n        this.name = name\r\n        this.firends = [\"Jack\",\"Rose\"]\r\n    }\r\n    f.prototype.say = function(){\r\n        alert(this.name);\r\n    }\r\n    function s(name,age){\r\n        f.call(this,name);\r\n        this.age = age;\r\n    }\r\n    s.prototype = new f();\r\n\r\n    var t1 = new s(\"tang\",1);\r\n\r\n    var t2 = new s(\"zhang\",2);\r\n    t2.firends.pop();\r\n\r\n    alert(t1.say == t2.say);//true\r\n    alert(t1.firends);//Jack,Rose\r\n    alert(t2.firends);//Jack\r\n```\r\n组合继承避免了原型链继承和构造函数继承的缺点，融合了他们的优点，是最常用的继承手段。\r\n\r\n## 其他\r\n此外还有原型式继承和寄生式继承，目前只是稍微地了解了一下，因此不敢妄下结论。';
INSERT INTO shymean_article SET `title` = 'meta标签', `created_at` = 1471876134, `category` = 'HTML', `tags` = '标签', `content` = '\r\nmeta标签是页面head标签中一个辅助性的标签，最常见的用途便是指定页面编码。然而，meta标签的功能不单限于此，可以设置其属性实现多种功能。\r\n<!--more-->\r\n## meta标签简介\r\n首先来看一下meta标签的定义:\r\n> meta标签用来存储描述页面文档属性的元信息，比如作者、日期、网页描述和关键词、页面刷新等。而元信息保存在meta标签的属性中，一般以名称/值得形式成对传递。\r\n\r\n也就是说，元信息的名称保存在meta标签的一个属性中（即name属性或http-equiv属性，暂时称作名称属性），而元信息的值保存在meta标签的另一个属性中（即content属性）。下面分别介绍这两个名称属性和与之对应的content属性。\r\n\r\n## name属性\r\nname属性的作用是将content属性关联到一个名称，在通常情况下，可以自由地设置name的属性值（但是建议最好是使用富有意义的名称）。除此之外有几个特殊的name值，会被浏览器特殊对待。\r\n### viewport\r\n这是一个移动设备上的概念，我也是由于项目需要才了解这个属性的。[移动前端开发之viewport的深入理解](http://www.cnblogs.com/2050/p/3877280.html)这篇文章说的十分精彩，不妨移步阅读。\r\n#### viewport概念\r\n简单地说，移动设备上的viewport就是该设备显示网页的区域。由于网页的宽度不同，因此viewport即可能超出移动浏览器可视区，也可能小于浏览器可视区。一般情况下，为了能够正常显示PC端网页，浏览器的默认viewport为980px或者是1024px，带来的后果就是出现横向滚动条（或者其他类似页面可以左右滑动的效果）。\r\n#### CSS像素与物理像素\r\n最初我也以为css中的1px就等于屏幕的一个物理像素，这在桌面浏览器中大概无可厚非，然而到移动浏览器中就有了天壤之别。有两个因素决定了CSS像素与物理像素的区别：__屏幕像素密度__与__缩放__：\r\n* 随着技术发展，移动设备的屏幕像素密度越来越高（比如苹果的Retina屏幕），这意味着同样大小的手机屏幕上的css像素可能是物理像素的2倍甚至更多（即1css像素 = 2物理像素）。\t\r\n为了搞定这个问题可以做一个测试。使用iphone截一张图，然后使用PhotoShop查看，可以看见iphone5的屏幕宽度是320px，但是截图宽度确实640px，第一次碰见这个问题我甚至都不知道该怎么切图，到后面才明白。\r\n* 大多数移动设备都支持用户缩放功能。当页面放大一倍时，css像素所占据的物理像素也会增大一倍，而屏幕的物理像素至始至终都是不会变化的。\r\n\r\n为了解决上面这两个问题，所以在上一节中所提到的默认viewport设置较宽，就是为了让移动端浏览器尽可能完整地显示所有网页。\r\n#### 移动设备优先\r\n那么问题来了，目前越来越多的网页是单独基于移动端开发的（比如最近的项目里面好几个都是微信项目页面）。既然是单独适配移动端，因此需要为页面指定一个非常理想的viewport，即不需要用户缩放也不需要横向滚动条，就能完整浏览整个页面。而这个指定的viewport就是meta标签中的viewport。\r\n当然通过设置meta标签的name属性值为viewport只是告诉了浏览器这个页面是移动设备优先的，具体怎么设置完美的viewport呢？这时需要在content属性中显式设置viewpor对应的属性值。\r\n#### viewport对应属性值\r\n```\r\ncontent=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"\r\n```\r\n依次解释这条指令：\r\n* width=device-width表示viewport宽度等于移动设备宽度；\r\n* initial-scale=1.0表示页面初始缩放值为1，即不缩放；\r\n* maximum-scale=1.0表示最大缩放为1；\r\n* user-scalable=0表示不允许用户进行缩放。\r\n\r\n上面提到的缩放，是相对于初始viewport来进行缩放的。关于默认缩放值，有一个特别需要注意的地方:\r\n>在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。\r\n\r\n也就是所，默认缩放值的默认值，不一定会是1，因此为了达到移动设备优先的效果，最好显式指明。\r\n#### 小结\r\n虽然已经着手两三个移动端项目了，关于viewpor了解却很不充分，现在只是简单理清概念，仍需继续学习。\r\n\r\n### keywords与description\r\nkeywords即为搜索引擎爬虫所提供的页面关键字，所有关键字存储在content属性中，用逗号分隔。\r\ndescription属性与keywords属性类似，也保存关于页面描述的信息并提供给爬虫获取，只不过其content属性值可以为一整段话而非几个词组。\r\n上面这两个name属性值是SEO中十分重要的概念（貌似现在的搜索引擎对于关键字与页面描述的依赖度与信赖程度比较低了，大概是黑帽SEO的关系吧，然而我对于SEO的掌握小于等于0，也仅仅知道白帽黑帽灰帽子啥的...）,大概恶补几个知识点。\r\n\r\n#### 搜索引擎工作原理\r\n这是一门庞大且复杂的学问，万万不敢妄下什么意见和结论。由于只是为了简单了解一下keywords的用途，因此简单涉猎一番。\r\n搜索引擎的工作主要分为三部分：抓取网页，处理网页，提供检索服务。因此，搜索引擎必须知道并抓取网页，才能进行后面的操作。为了提高被搜索爬虫抓取的概率，因此诞生了SEO这一行业，而title，keywords与description是与之相关的十分重要的三个属性。将预先准备好的信息存放在meta标签中，这样爬虫在路过网页的时候就可以停下来好好的看一看这个网页，那么网页被抓取的几率是不是更大呢?（好吧，这只是我的YY...）\r\n\r\n#### 页面关键字与描述内容\r\n只需要明白一点，所有的关键字与页面描述的内容都是自定义的，也就是说想写啥就写啥，哪怕是跟页面毫无关联的废话也没关系（只要不怕被老板打死）。为了实现良好的SEO效果，根据网上的建议：\r\n* 现在的搜索引擎并不太重视keywords和description属性了（具体不重视到什么程度我也不知道，说不定有人云亦云之嫌）;\r\n* 将最重要的关键字放在最前面\r\n* 关键字最好不要超过10个，描述段落不要超过100个字符，字数过多可能导致爬虫忽略；\r\n* 首页与分页面的keywords没有必要相同，根据页面的内容来定义“真正”的关键字；\r\n* 请遵守业内白帽子规则...(什么鬼)；\r\n\r\n#### 小结\r\nSEO也是一门博大精深的学问，只是本人目前尚处于前端小白阶段，未能窥得其奥秘，曾经还纳闷博客都建了一个多月了百度都搜不到...未来的某一天一定会好好的学习学习SEO的。\r\n\r\n### name属性的其他值\r\n\r\n#### author\r\n声明网页的作者，可以是名字或者邮箱等。然而使用HBuilder的时候自动生成的作者信息是使用注释实现的，貌似这样更符合其他语言的风格\r\n\r\n#### robots\r\n给搜索爬虫之路，指定哪些页面是需要被索引的，对应的content值有all,none，index,noindex等\r\n\r\n## http-equiv\r\nname只是将content属性关联到一个名称，而http-equiv主要是把content属性关联到http头部，向浏览器传回某些信息，用以帮助浏览器正确地显示网页内容。 http-equiv可以用来实现某些特定的功能。\r\n\r\n### expires\r\n指定网页的有效日期，一旦网页过期则必须重新从服务器下载，其对应的content值是GMT的时间格式。\r\n所谓GMY的时间格式，指的是“格林尼标准时间”：\r\n```\r\nvar d = new Date();\r\nconsole.log(d);\t//Tue Aug 23 2016 21:53:22 GMT+0800 (中国标准时间)\r\n```\r\n\r\n### Window-target\r\n这个属性的含义是强制页面在当前窗口以独立页面显示。所谓独立页面指的是无法被嵌套在iframe或者frameset中使用。因此该属性可以阻止别人在框架中调用自己的页面（然而我的博客十天半个月也不会有人访问！）\r\n\r\n### content-Type和content-Language\r\n用来指定页面的字符集和语言。不太明白与mate \"utf-8\"的区别\r\n\r\n### Cache-Control\r\n该属性指定请求和响应遵循的缓存机制，关于页面缓存，暂时还不太了解，目前只知道一个304，泪奔...待我填完这个坑再回来搞定这里吧。\r\n\r\n## 最后\r\n对于http-equiv属性非常不熟悉，因此只是简简单单过了一遍，目前关于Meta属性，最需要掌握的就是viewport了，因此移动端项目跟PC端还是有很大区别。\r\n最后草草结尾，留下几个坑慢慢来填。\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = 'MySQL数据类型', `created_at` = 1477407130, `category` = '数据库', `tags` = '数据库', `content` = '\r\n最近在练习一个后台小项目，随便规划了几个需求之后开始搭环境（好吧其实就是写了几个页面然后上ThinkPHP），当正儿八经的开始写后台项目的时候才发现，在数据库中该怎么为每个字段选择合适的数据类型呢？然而我连MySQL数据库的每种数据类型的具体作用都不太熟悉，细思极恐，赶紧恶补一番。\r\n<!--more-->\r\n合理的数据库结构和数据类型是高性能数据库的关键，而使用何种数据类型来保存数据并没有强制的规定，这里找到了前辈们总结的一些经验，感谢互联网。\r\n参考资料：\r\n* [百度经验](http://jingyan.baidu.com/article/f0062228d2e4a8fbd3f0c8a6.html)\r\n* [MySQL建表时选择最佳的数据类型](http://blog.sina.com.cn/s/blog_4e36a71001013mgg.html)\r\n\r\n## 数据类型\r\n在挑选合适的数据类型之前，先看一看MySQL具体的数据类型有什么吧。\r\n### 数字类型\r\n数字类型又可以分为整数类、小数类和数字类。\r\n#### 数字类\r\n所谓的“数字类”，就是指 DECIMAL 和 NUMERIC，它们是同一种类型（在phpmyadmin中并没有看见NUMERIC），这种类型又叫做定点数，指的是小数的位数固定，整数部分最大为65，小数部分最大为30。实际上这种数据类型是将数字以字符串形式保存，在运算中不会失真，比较适合用于“价格”、“金额”这样对精度要求不高但准确度要求非常高的财务数据字段。\r\n\r\n#### 小数类\r\n小数即为浮点数，包括FLOAT（占4个字节）和DOUBLE（占8个字节）类两种。浮点数的优点在于表达的数值范围十分大，可以表示很小或者很大的数值。缺点是浮点数存在误差问题，需要尽量避免做浮点比较。实际上，平常项目所用到的数据哪里会需要那么大的数值范围呢。\r\n\r\n#### 整数类\r\n实际上数据库用到最多的数据类型就是整数类，根据所占内存大小分为了TINYINT,SMALLINT,MEDIUMINT,INT和BIGINT这几种，分别占1，2，3，4，8个字节。\r\n\r\n### 字符串类型\r\n字符串类型又包括了字符和文本。\r\n#### 字符\r\nCHAR： 指定字节长度，并且在存储时如果完全占据指定内存（即使内容数据实际大小比指定大小要小）；\r\nVARCHAR：如果并不确定数据的实际长度，只知道他的阈值（即最大长度），则使用可变长度的VARCHAR类型更合适，这会根据数据的长度自动调节变量所占内存大小（为数据长度+1，多余的一个字节用来存储长度）；\r\n#### 长文本\r\n如果需要存储很大字节的字符串（比如博客，新闻等）可以使用TEXT来存储，此外还有TINYTEXT,MEDIUMTEXT,LONGTEXT。\r\n#### 大数据\r\n如果要在数据库存储二进制内容，比如图片，可以使用BLOB数据类型。\r\n#### 枚举和集合\r\nENUM：最多可以定义 65535 种不同的字符串从中做出选择，只能并且必须选择其中一种，占用存储空间是一个或两个字节\r\nSET：最多可以有 64 个成员，可以选择其中的零个到不限定的多个，占用存储空间是一个到八个字节。\r\n\r\n### 日期和时间\r\nDATE：如果数据对日期敏感，而对时间没有要求则可以使用DATE类型，需要8个字节\r\nTIME：在某些情况下可能只需要单独关注时间则使用TIME类型，需要8个字节\r\nDATETIME:包含日期和时间，需要8个字节\r\nTIMESTAMP：用来保存时间戳，只需要4个字节，且可以灵活转换为日期时间，因此使用最为频繁，需要注意的时间戳可能受时区影响。\r\n\r\n## 如何选择\r\n\r\n### 选择小数据类型\r\n通常情况下，使用占用内存较小的数据类型来存储和读取数据更好：数据类型越小，在磁盘，内存和处理器缓存中占据的空间很小，只需要很小的CPU处理消耗。\r\n然而，必须保证没有低估需存储数据的数值范围，否则就是“捡了芝麻丢了西瓜”，毕竟数据库就是用来存储并读取数据的。\r\n\r\n### 避免使用NULL\r\n如果有需要，最好将字段设置为NOT NULL,空值字段的查询是一件很难的事情，因为空值使得索引、索引分析以及数值比较更加复杂，如果确实需要使用NULL，考虑使用0、特殊值或者一个空的字符串来代替更为合适。\r\n\r\n### 常见的数据对应的类型\r\n其中有的数据前面已经提到过了，这里再简单总结一下：\r\n* 定点数字类型尽量只在对小数精确计算时才使用、如存储财务数据\r\n* 数据量较大时、建议把实数类型转为整数类型，因为浮点数不精确，而定点数的计算代价昂贵\r\n* 如果没有需要，不必对浮点数进行精度指定\r\n* 很短的字符串或所有值都接近同一个长度，使用CHAR，如存储密码的MD5值\r\n* 经常变更的列最好使用CHAR，因为CHAR产生的碎片少\r\n* 对于Unicode编码的字符集，最好使用VARCHAR\r\n* 很大的数据，比如BOLB和TEXT最好存储在单独的表中\r\n* 如果没有意外，最好使用TIMESTAMP来保存时间，占用内存较小\r\n\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = 'PHP基础入门', `created_at` = 1476885265, `category` = 'PHP', `tags` = 'php基础', `content` = '\r\n\r\n大概是参加工作后的一个月吧开始学习PHP，最初只是草草地翻阅了一下手册，然后跟着后端的同学熟悉PHP框架开发，在ThinkPHP语法糖的诱惑下，一直没有深入PHP的基础知识（与其说是深入，不如说是了解）。PHP的函数十分繁杂，命名也比较混乱，然而项目中常规使用的函数：比如打印，判断，字符串，数组等函数和方法，应当是优先需要掌握的，因此重新整理有道云上面的笔记，进一步学习PHP。之后的目标是用PHP为我的小网站重新搭一遍（PS：自从用了Hexo，之前买的虚拟主机就一直撂在那里了...）\r\n\r\n<!--more-->\r\n\r\n## 数据类型\r\n\r\n变量类型是根据使用该变量的上下文所决定的，因此数据类型自动转换有时候会发生一些看似莫名其妙的事情。\r\n### 布尔值\r\n当运算符，函数或者流程控制结构需要一个 boolean 参数时，将发生自动类型转换，下面数值都会转换为false：\r\n* 布尔值false\r\n* 整形数字0或浮点型数字0.0\r\n* 空字符串\"\"或零字符串\"0\"\r\n* 空数组\r\n* 特殊类型NULL\r\n* 从空标记生成的 SimpleXML 对象 （表示从来没见过）\r\n\r\n需要注意的是，不包含任何成员的对象现在也会被认为是true。\r\n\r\n### 数字\r\n数字分为了整形和浮点型，使用除法运算符得到的是浮点数，将浮点数转换成整数有多种方法\r\n不要将未知的分数强制转换为integer，因为会存在精度的丢失，比如\r\n```\r\necho 0.1+0.7; //0.8\r\necho (int)((0.1+0.7)*10); // 7\r\n```\r\n也就是说，永远不要相信浮点数结果精确到了最后一位，这是在大多数语言中都存在的问题。\r\n\r\n### 字符串\r\n与JS不同的是，PHP中的单引号与双引号所组成的字符串__有明显区别__\r\n* 在单引号字符串中的变量和特殊字符的转义序列将不会被替换\r\n* 而用双引号定义的字符串最重要的特征是变量会被解析\r\n\r\n```\r\n$a = 123;\r\necho \"$a\"; //123\r\necho \'$a\'; //$a\r\n```\r\n此外需要注意的是，PHP会将非数值的字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。也就是说任意字符串都是可以转换成数字的（跟JS的isNaN判断有很大区别！）\r\n\r\n## 数组\r\nPHP数组的键名是不限制必须为整形数字的，也就是说键名可以混用数字和字符串。\r\n数组中多个元素都使用了同一个键名，则只使用了最后一个，之前的都会被覆盖。\r\n数组中的键名会自动转换成整形数字（如果可行的话），在这种情况下，即使键名不完全相同，后面的值也会将前面的值覆盖。例外是如果键名是内容为浮点数的字符串，是不会发生这种类型转换的。\r\n\r\n```\r\n$a = array(\r\n\t1 => \'a\',\r\n\ttrue => \'b\',\r\n\t1.2 => \'c\',\r\n\t\'1\' => \'d\',\r\n    \'1.2\' => \'e\',\r\n);\r\nvar_dump($a);\r\n//结果\r\n//  1 => string \'d\' (length=1)\r\n//  \'1.2\' => string \'e\' (length=1)\r\n```\r\n访问数组元素时，如果给出方括号但没有指定键名，则取当前最大整数索引值，新的键名将是该值加上 1，相当于为数组新增了元素\r\n```\r\n$a = array(1,2)\r\n$a[] = \'3\';\r\nvar_dump($a); // 1,2,3\r\n```\r\n\r\n可以使用foreach方法快速遍历数组\r\n```\r\nforeach ($array as $key => $value) {\r\n\techo $value.\"<br/>\";\r\n}\r\n```\r\n由于 foreach 依赖内部数组指针，在循环中修改其值将可能导致意外的行为。\r\n\r\n## 变量\r\nPHP中使用($)符号加变量名来定义一个变量，变量名区分大小写。\r\n### 变量解析与赋值\r\nPHP可以在双引号字符串中插入变量并正确解析，变量解析大概是为了方便在进行某些情况下（比如sql语句中）减少字符串的拼接，主要有有两种规则：\r\n* 简单规则，即在一个双引号字符串中嵌入一个变量，一个 array 的值，或一个 object 的属性。\r\n\t* 当PHP解析器遇到一个($)符号时，就会去组合尽量多的标识以形成一个合法的变量名；\r\n\t* 同理，HP解析器遇见数组索引方括号([])和对象属性索引(->)也会去组合标识并找到对应的变量。\r\n* 复杂规则，只需简单地像在 string 以外的地方那样写出表达式，然后用花括号 { 和 } 把它括起来，并嵌入到双引号字符串中即可，需要注意的是($)符号必须与({)符号紧挨着，否则无法被解析。\r\n\r\n变量默认总是传值赋值（包括数组，这里也是与JS完全不同的地方）。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。\r\n如果需要使用引用赋值，则需要将&符号加到将要赋值的变量前\r\n```\r\n$a = 1;\r\n$b = $a;\r\n$c = &$a;\r\n\r\n$b = 100;\r\necho $a; //1\r\n\r\n$c = 100;\r\necho $a; // 100\r\n```\r\n\r\n### 变量作用域\r\n变量的作用域主要分为了全局变量和局部变量：\r\n* 不在任何函数内的变量拥有全局作用域。\r\n* 在用户自定义函数中，一个局部函数范围将被引入。任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。\r\n\r\n尽管被称为全局变量，PHP 中全局变量在函数中使用时必须声明为 global才能够使用，否则就会报”变量未定义“的错误。\r\n```\r\n$a = 1;\r\nfunction foo(){\r\n\tglobal $a;\r\n\techo $a;\r\n}\r\n```\r\n\r\n此外PHP还存在静态变量，静态变量只在局部函数作用域中存在，但是当该函数调用结束之后，该变量的值并不会丢失（作用于C语言中的static类似），使用static定义静态变量。\r\n```\r\nfunction foo(){\r\n\tstatic $a = 0;\r\n    $a++;\r\n    echo $a;\r\n}\r\nfoo(); //1\r\nfoo(); //2\r\n```\r\n\r\n### 超全局变量\r\nPHP定义的一些变量，用来处理接收到的表单数据等...\r\n\r\n### 常量\r\n可以使用define()函数或者const关键字来定义一个其值不可改变的常量\r\n* 常量不需要$符号\r\n\r\n```\r\ndefine(\'TEST\',1);\r\nconst TEST2 = 10;\r\necho TEST; //1\r\necho TEST2; //10\r\n```\r\n需要注意的是使用const定义常量只能在全局作用域下进行，在函数内部无法使用这种方式定义常量，而使用define则没有这种限制。\r\n此外，使用define在函数内部定义的常量也可以在全局作用域下访问到。\r\n\r\n## 流程控制\r\n在PHP中的流程控制语句中，还可以使用冒号代替花括号，使用elseif和endif这些缩写。\r\n```\r\n$a = 1;\r\n$b = 2;\r\n//1\r\nif ($a > $b):\r\n\techo 1;\r\nelseif($a == $b):\r\n\techo 2;\r\nelse:\r\n\techo 3;\r\nendif;\r\n//2\r\nif ($a > $b){\r\n\techo 1;\r\n}else if($a == $b){\r\n\techo 2;\r\n}else {\r\n\techo 3;\r\n}\r\n```\r\n甚至第二种写法中的else if也可以写作elseif的形式，然而我更习惯分开带大括号的习惯，所以，这里就大概就是看个人喜好了吧。\r\n\r\n## 函数\r\n### 函数作用域\r\n任何有效的PHP代码都可以出现在函数的内部，甚至包括其他函数和类的定义。\r\n此外PHP中的所有函数和类都具有全局作用域，也就是可以在全局作用域中调用一个在函数作用域中定义的函数，前提是其父函数已经被调用（该函数已经执行定义流程才可以）\r\n```\r\nfunction foo(){\r\n\techo \'In foo\';\r\n\r\n\tfunction foo2(){\r\n\t\techo \'In foo2\';\r\n\t}\r\n}\r\nfoo(); //必须调用父函数进行定义之后\r\nfoo2(); //可直接调用\r\n```\r\n### 函数参数与返回值\r\n参数默认是通过按值传递，可以在函数定义的时候指定为按引用传递，只需要在参数前加上&符号即可，此外，如果只是需要某次函数调用的时候按引用传递，也可以在实参前加上&。\r\n```\r\nfunction changeMax(&$a,&$b){\r\n\tif ($a > $b){\r\n\t\t$t = $a;\r\n\t\t$a = $b;\r\n\t\t$b = $t;\r\n\t}\r\n}\r\n\r\n$a = 10;\r\n$b = 1;\r\nchangeMax($a,$b);\r\necho $a.\',\'.$b; //1，10\r\n```\r\n跟C++一样，可以为函数设置默认参数，同时任何默认参数必须放在任何非默认参数的右侧\r\n```\r\nfunction foo($a,$b=1){}\r\n```\r\n\r\n如果没有指定return，则默认返回值为NULL。\r\n\r\n## 类与对象\r\n对象的属性可以临时增加，但是仅限于该对象访问，类实例化的其他对象并没有该临时属性。\r\n对象之间的赋值时按引用传递，改变一个对象变量会影响到另一个变量所指向的同一个对象。但是当将对象显示的置为null时，按值传递的对象变量不会被删除，而按显式按引用传递的对象变量会同时被删除。\r\n\r\n\r\n## 常用函数\r\nPHP中的函数非常多，也非常强大，只是各种花式命名让人目不暇接，心中感慨还是面向对象好哇（关键我还是个驼峰命名爱好者，样式表不算）!最后整理了一些常用的PHP函数。\r\n\r\n### 数字\r\nintval()： 将参数转换为整形数字，如果为浮点数，只保留浮点数的整数部分\r\nis_numeric()：检测参数是否为数字，返回布尔值\r\nis_nan()：检测参数是否为NaN\r\n> PHP会将非数值的 string 当成 0，也就是说使用上述两个函数来检测字符串是否能够转换成数字是行不通的（这里跟JS的差别很大）\r\n```\r\n$a = \'xxx\';\r\necho intval($a); //0\r\n```\r\n\r\nceil()：向上取整\r\nfloor()：向下取整\r\n\r\nmax()：参数为一个数组或多个数字，返回其中最大值\r\nmin()：同上，返回参数中的最小值\r\n\r\nmt_rand(start,end)：返回某个范围内的随机数\r\n\r\n### 数组\r\nin_array($v,$arr)：检查一个元素是否在数组中\r\narray_slice($arr,start,end)：截取指定索引值范围的子数组\r\n\r\narray_push($arr,$v1,$v2...)：将一个或多个元素放在数组最后\r\narray_pop($arr)：删除数组中最后一个元素\r\n\r\narray_unshift($arr,$v1,$v2...)：向数组头部插入元素\r\narray_shift($arr)：删除数组中第一个元素\r\n\r\nsort($arr)：从小到大进行数组排序\r\nrsort($arr)：从大到小排序\r\nshuffle($arr)：将数组打乱\r\n\r\narray_merge($arr1,$arr2)：合并两个数组\r\narray_unique($arr)：移除数组中重复的元素\r\n\r\nimplode($arr,$char)：把数组按指定分隔符拼接成字符串 //join()\r\n### 字符串\r\nstrlen()：返回字符串的长度\r\ntrim($str)：去除字符串左右空格\r\nstrtolower($str)：将字符串全部小写\r\nstrtoupper($str)：将字符串全部大写\r\n\r\nstrpos($str,$c,[int])：查询指定子字符串在字符串中出现的位置，第三个参数指定起始查找位置\r\nsubstr($str,$start,$length)；截取指定长度的字符串\r\nstr_replace($search,$replace,$str)：替换字符串中的某些字符\r\n\r\nstr_split($str,$len)：把字符串按len长度进行分割并返回数组\r\nexplode($search,$str)：把字符串按指定字符进行分割并返回数组\r\n\r\n### 编码\r\njson_encode()：对数组进行JSON编码，\r\njson_decode()：对JSON格式的字符串进行编码\r\n\r\nurlencode()：本函数将字符串进行 URL 编码\r\nurldecode()：本函数将 URL 编码后字符串还原成未编码的样子\r\n> 可以使用这两个函数来解决json_encode后默认编码为unicode的问题，为了解决深层嵌套的问题单独写了一个函数\r\n```\r\nfunction json_encode_fixed($arr){\r\n\tfunction json_encode_fixed_foo(&$arr){\r\n\t\tforeach ( $arr as $key => $value ) {\r\n\t\t\tif (is_array($value)){\r\n\t\t\t\t$arr[$key] = json_encode_fixed_foo($value);\r\n\t\t\t}else {\r\n\t\t\t\t$arr[$key] = urlencode ( $value );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $arr;\r\n\t}\r\n\r\n\tjson_encode_fixed_foo($arr);\r\n\treturn urldecode(json_encode($arr));\r\n}\r\n```\r\n\r\n### 日期\r\ntime()：返回时间戳\r\ndate(\'Y-m-d h:i:s\',time())：根据第一个字符串参数的格式打印出对应的日期，第二个参数为当前时间戳\r\nstrtotime()：将时间字符串转换成时间戳\r\n\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = 'CSS权威指南读书笔记', `created_at` = 1472043338, `category` = 'CSS', `tags` = '读书笔记', `content` = '\r\n\t\r\nCSS的特性：\r\n> * 能够向文档中的一组元素应用某些表现规则\r\n> * CSS层叠样式表中的“层叠”，即指定了样式的冲突规则。\r\n\r\nCSS样式表中不能出现任何文档标记，否则会导致部分或者全部样式无法被解析（表示今天刚遇到的一个报错，一个未闭合的大括号导致其后面所有的样式都无法正确显示，所幸使用了HBuilder的CSS语法检测才能快速定位错误。）\r\n<!--more-->\r\n\r\n替换元素和非替换元素\r\n> * 替换元素指该元素内部的内容并非由文档内容直接表示，比如img需要显示的指定其src属性，（PS：作者应该说的是非闭合标签）；\r\n> * 非替换元素指该元素的内容由浏览器直接生成并显示（即闭合标签）\r\n\r\n样式表的title属性值\r\n如果为一个rel为stylesheet的link标签指定了标题，也就指定了该样式表作为首选样式表；如果没有为样式表指定title，则该样式表将作为一个永久样式表，始终用于文档的显示\r\n\r\n候选样式表\r\n> 将link标签的rel属性值设置为alternate stylesheet即可定义候选样式表，即只有在用户选择这个样式表时才会生效，需要为不同的样式表指定不同的title属性值。（然而找了半天都没找到开启候选样式表的地方，最后终于在IE的“页面-样式-样式文件名”中发现了）\r\n\r\n## 选择器\r\nCSS能够向文档中的一组元素应用某些规则，而这些规则由选择器和声明块组成。\r\n> * 选择器与生命块都是可以进行分组的。其中，在各个声明之后必须使用分号隔离，否则CSS解析器无法识别这个声明。\r\n> * 点号加类名的方法在HTML、SVG和MathML中可以正常工作，在其他标记语言中则不一定正常；而加#号ID选择器可以在任何文档语言中使用。通常情况下，浏览器其实并不会检验ID的唯一性，也就是说，其实在页面使用了所有同名的ID也可能使用相同的样式规则，然而这种做法是不正确的，此外对于JS获取DOM来讲是很坑的，可能只会获取到第一个ID，因此，任何时候都不要在页面中使用相同的ID名称。\r\n\r\n多类选择器\r\n> 多类选择器表示\"&&\"，即只有同时包含这些类名的元素（与类名顺序无关）才能应用对应的声明规则，在IE7及之前的浏览器版本无法正确识别多累选择器。\r\n\r\n属性选择器\r\n>属性选择器可分为简单属性选择器，具体属性选择器和部分属性选择器三种：\r\n* 简单属性选择器只关注用于某属性的元素，而并不关注其属性值；\r\n* 具体属性选择器选择拥有该属性且其属性值也一一对应的元素；\r\n* 部分属性选择器类似于正则语法，通过属性值的某部分来筛选元素\r\n\r\n结构选择器\r\n结构选择器需要使用“结合符”，结合符包括：\r\n> * “ ”，空格结合符，需要注意的是空格结合符组成的后代选择器之间的层次可以是无限的，并不仅限于某代元素；\r\n* “>”，子结合符，表示选取父元素下的第一代子元素，\r\n* “+”，相邻兄弟结合符，表示选取指定元素的后一个兄弟元素\r\n\r\n伪类选择器\r\n> 伪类选择器的实质是将某个“幻象类”关联到与伪类相关的元素，这样就不必添加具体的类就选择到对应的元素，比如：\"first-child\"的含义是选择某个作为某元素的第一个子元素的那个元素，而不是某元素下的第一个子元素！\r\n\r\n## 层叠与权重值\r\n对于每个选择器所声明的规则，浏览器都会计算其特殊性（即权重值），并根据权重值的大小解决样式冲突，而所有样式冲突解决的本质都是依靠“层叠”进行的\r\n__计算方法__\r\n> * 依照 0,0,0,0 的规则计算权重值，行内样式千位+1，ID选择器百位+1，类选择器十位+1，标签选择器与伪类选择器个位+1，通配选择器权重值为0（并非没有权重值），而结合符没有任何权重值，权重值计算不会出现进位的情况（即0,1,0,0始终优先于0,0,13,0）\r\n* 浏览器会将元素的样式规则“解组”为单独声明，并对每一条单独声明计算其权重值并根据大小，解决样式冲突\r\n* 使用\"!important\"进行声明的元素并没有权重值，而是归属与“重要声明”，而其他未使用“!important”进行声明的规则归属与“非重要声明”，重要声明的规则总是优先于非重要声明，而非权重值之间的比较。\r\n\r\n继承的层叠\r\n继承只能自上向下传递（body背景样式传递到html元素是一个例外）,大多数盒子模型属性都不能被继承。此外，继承的值没有任何的权重值（甚至连0都没有），因此需要慎重使用通配选择符，此外需要注意浏览器的一些默认标签样式，只有在该规则没有显式指定任何声明的情况下才会使用继承属性！\r\n\r\n解决冲突\r\n如果有多条规则应用在同一元素上，则使用层叠解决：\r\n> * 重要声明(!important)优先于非重要声明，而用户的重要声明优先于开发人员的重要声明\r\n* 权重值高的规则声明优先于权重值低的规则，开发人员的规则声明有限域用户的规则声明\r\n* 权重值相同时，出现在样式表后面的声明优先于前面的声明，主样式表的声明优先于@import引入的样式表声明\r\n* 浏览器的默认规则声明优先级最低\r\n\r\n## 单位\r\n### 颜色\r\n__表示方法__\r\n颜色有多种表示方法：命名颜色，RGB颜色，十六进制颜色。\r\n* rgb颜色既可以使用百分数，也可以使用0-255之间的正式，分别代表该颜色重红、绿、蓝三种颜色分量\r\n* 十六进制颜色，如果其三组数十成组出现的，比如#aabbcc，则可以简写成#abc；\r\n* 十六进制颜色与rgb颜色之间的转换，只是简单的十六进制与十进制之间的转换。\r\n\r\n安全色\r\n“web安全色”指的是在256色计算机上总能避免抖动的颜色。在rgb()百分数表示法中的三色分量要么为0，要么能被20%整除；在rgb()整数表示法中的三色分量能被0或51整除；在十六进制表示法中三色的简写为0,3,6,9,c和f。\r\n\r\n### 长度\r\n绝对长度\r\n* 绝对长度有英寸，厘米，毫米，点（标准印刷单位）和派卡（印刷术语）；除了在定义打印文档的样式表时（从来没弄过），最好不要使用绝对长度（总之就是写页面不要用绝对长度）；\r\n\r\n__相对长度__\r\n> * 相对长度单位，是因为这些单位是根据与其他事物的关系来度量的，因此相对长度单位具有不确定性。相对长度单位主要有em,ex和px:\r\n* 1em的定义为该元素字体的font-size大小，因此不同字体大小的元素上的em是不同的。如果em长度单位本身就是用来指定该元素上的字体大小，那么该元素的font-size就是其父元素的em（也就是父元素的font-size）乘以指定乘积因子\r\n* 1ex的定义为该元素所用字体小写x的高度，一般来说，可以假设为1ex = 0.5em，该单位实际情况中用的很少\r\n* 1px即组成显示器显示区域网格的方形单元格（简称为显示器元素）的长度，在不同的显示器下（比如PC和打印机），可能会被像素长度(1px)重新缩放为更合理的度量，因此，像素也是一个相对长度单位。\r\n\r\n在控制字体大小的时候，最好不要使用像素，这会导致在ie7之前的某些BUG；而在控制图像大小方面，最好使用像素（因为图片的尺寸本身就是像素，除非是SVG矢量图）\r\n\r\n## 字体与文本\r\n### 字体\r\n字体系列\r\n> * 指定font-family时最好提供一个通用字体系列，以备在用户系统中部存在指定字体的情况下选择备用的字体系列，多个字体之间使用逗号隔开，字体名称中含有空格或\"#\"\"&\"之类的符号时需要使用引号将字体名称包围起来\r\n\r\n字体粗度\r\n> 虽然字体粗度关键字有100-900,对应字体的9级加粗度，但是这些关键字并没有固定的加粗度，比如100，200，300，400可能映射到同样的较细变形程度；而使用bolder和lighter时浏览器会首先计算其父容器的font-weight数值，再乘以对应的乘积因子\r\n\r\n__字体大小__\r\n> 使用百分数或者em指定字体大小时，是由浏览器先获取其父元素的font-size再乘以对应的乘积因子，并且浏览器很有可能会将该结果取整为最接近的整数像素，因此在连续使用百分数或者em指定字体大小时，误差可能会累积\r\n\r\n注意事项\r\n> 使用font组合属性时需要注意下面几点：\r\n* 必须指定font-size和font-family，且font-size属性位于font-family属性之前\r\n* 如果某个属性对应的关键字是normal则可以省略\r\n* 可以加入line-height,但是必须使用font-size/line-height的格式\r\n\r\n### 文本\r\n文本缩进\r\n> * text-indent继承的也是计算值而非声明值\r\n\r\n__行高__\r\n行高指文本行基线之间的距离，行间距实际上是(line-height - font-size)的值，因此可能为负；\r\n> 实际上，文本行每行的行内元素都会生成一个内容区，而每个内容区又会生成对应的行内框，在默认情况下，行内框的大小即为字体大小，而使用line-height则是显式地重新指定了文本行中各个行内框的大小，只需要将行间距均分成两半且应用到每个内容的顶部和底部，就可以得到对应的重新生成的行内框的大小\r\n\r\n如果使用百分数来设置行高，浏览器会首先计算其父元素的字体大小与对应百分数的乘积，得到对应的结果再传递给对应元素（当子元素的字体大小大于该值就会出现文本行重叠的情况）；\r\n如果使用乘积因子来指定行高，浏览器会计算该元素的字体大小（如果没有则计算该元素从其父元素继承得到的字体大小），然后乘以对应的乘积因子，并将结果应用在行高之上。\r\n上面两点的总结：继承也是有优先级顺序的，当属性值之间存在依赖关系的时候，这种优先级十分重要（不知道这种理解是否正确）。\r\n\r\n对齐\r\n默认的文本对齐方式是baseline，这会导致在某些浏览器下，基线下面的空间会导致图像出现一段空白，这种方法是文本对齐的正确实现，但有时候并不是我们想要的，有多种解决办法，在之前关于《img两个小问题》的那篇文章中提到过，最简单的方法大概就是指定父容器的“font-size:0”了\r\n\r\n## 基本视觉格式格式化\r\n目前读到这里，感觉这一章是整本书的精华，将之前学习到的零散的知识点真正整合起来了。\r\n\r\n包含块\r\n> 包含块就是一个元素的布局上下文，包含块由最近的块级祖先元素，表格单元或者行内块祖先框的内容边界构成。\r\n\r\n水平格式化\r\n正常流中的块级元素框的水平部分总和（即左右外边距+左右边框宽度+左右内边距+元素内容区），这七个属性的值之和必定为该元素包含块的内容区大小，即使是使用负的marigin值也是如此（在这种情况下子元素的宽度可能大于包含块的宽度）\r\n * 其中width和左右外边距可以设置为auto（其他四个值只能为非负数值），浏览器会自动计算其大小，如果这三个属性都设置为非auto的某个值（这种情况叫做过分受限），且所有值之和不等于其包含块的内容区大小，那么浏览器会强制重置margin-right为计算值\r\n * 水平方向上的外边距不会合并\r\n \r\n竖直格式化\r\n如果为margin-top或者margin-bottom设置auto会自动计算为0而不是一个智能的大小。\r\n如果将元素的高度设置为auto，那么计算得到的值是最高的元素子元素的__外边框边界__到最低子元素的外边框边界（而不是外边距边界）之间的距离，这种情况会导致出现“外边距渗透的现象”，这可以归结于是子元素与其包含块之间发生的外边距折叠；\r\n外边距折叠在竖直格式化中是十分常见的情形，相邻的外边距会沿着竖直轴合并，需要注意的是如果元素有内边距或内边框，就不会发生外边距折叠的现象了\r\n\r\n## 外边距/边框/内边距\r\n所有的文档元素都会生成一个矩形框，这被称作“元素框”，描述了一个元素在文档布局中所占的空间大小。可以为__所有元素__应用外边距，边框和内边距。\r\n\r\n### 宽度和高度\r\nwidth被定义为从左内边界到右内边界的距离，height被定义为从上内边界到下内边界之间的距离，即元素内容区的大小。\r\n* 这两个属性不能应用在内联元素上，内联元素的宽度和高度由其内容决定;\r\n* 由于默认外边距，边框，内边距均为0，由于子元素元素框大小等于父元素内容区宽度的规则，块级子元素的默认宽度为父元素的100%;\r\n* 在IE6及之前的怪异渲染模式中，width和height被用来定义元素框的尺寸而非元素内容区的大小，CSS3指定的box-sizing则允许我们自由的选择盒子模型。\r\n\r\n### 外边距\r\n外边距指定了正常文档流中个元素之间的空白，所谓“空白”指的是不能放置其他元素的区域（这里只讨论了正常的文档流）。\r\n* 可以为margin设置为百分数，百分数是相当于父元素的width来计算的，而不论是左右margin和上下margin。这是由于如果上下外边距根据其父元素的height来设定可能会出现无限循环的情况（子元素的margin增加适应父元素的height,而父元素的height也必须增加来完全包含子元素...）\r\n* 元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向，覆盖之前的元素；\r\n* 设置margin-bottom/right为负数，元素并不会向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素\r\n* 在只设置了元素外边距的情况下（无边框或内边距），垂直方向上的外边距会发生折叠。\r\n\r\n外边距也可以应用在内联元素上（之前的认识完全错误），只是由于上面外边距并无法影响行高（内联元素的定位是由行框决定的，而影响行间距离的属性只有line-height，font-size和vertical-algin这三个），且外边距本身是透明的（背景色不会延伸至外边距），所以上下外边距不会有任何视觉效果。而在水平方向上，水平外边距会使该行内元素与其前后元素隔开指定的距离\r\n\r\n### 边框\r\n* 边框的默认样式是none，即没有任何边框，如果希望边框出现，必须显式地声明一个边框样式\r\n* 边框的默认颜色是元素的字体颜色\r\n* 元素的背景颜色会延伸到边框，即如果指定为dotted等样式的时候，元素的背景颜色在边框的可见区域也能够看到。\r\n* 边框也不法影响到行内元素的行高\r\n\r\n### 内边距\r\n* 跟外边距类似，指定内边距的大小为百分数，是相对于其父元素的width进行计算的\r\n* 为行内元素指定内边距也是规范完全允许的，同理，内边距也是无法影响行高的，但是由于背景颜色会覆盖内边距，因此会出现行内元素的背景颜色超过其行高的情况（之前关于为内联元素指定边距的疑惑豁然开朗）\r\n\r\n## 颜色和背景\r\n\r\n* 边框画在背景之上；\r\n* 所有的背景属性都不能被继承，默认背景为transparent；\r\n* 背景颜色与背景图像可以同时存在，且建议指定背景图像的时候同时指定元素的背景颜色\r\n* 背景图形的定位是相当于元素的内边距边界进行的（虽然背景可以延伸至元素边框），可以通过关键字，百分数和数值的方式指定background-position：\r\n\t* 关键字的顺序可以是任意的，且只指定一个关键字的情况下，另一个关键字的默认值为center\r\n\t* 百分数指定的定位有非常智能的效果，会导致背景图像的左上角或中心或右下脚等等对应元素不同的位置；如果使用百分值设置位置，第一个出现的数值将应用在水平方向，而第二个数值的默认值为50%\r\n\t* 使用具体数值指定背景图片定位，会将这些数值解释为背景图像从元素内边距左上角的偏移，偏移点是原图像的左上角。\r\n\t* 在CSS2.1之后，可以混合使用这三种方式指定背景图像定位\r\n* 背景图像的滚动关联如果指定为fixed，则该背景图像会相对于可视区定位\r\n\r\n## 浮动和定位\r\n\r\n### 浮动\r\n浮动的元素会以某种形式从文档的正常流中移除，但还是会影响布局：\r\n* 浮动元素在竖直方向上的外边距并不会合并（触发了BFC）；\r\n* 浮动元素的包含块是距离其最近的块级祖先元素；\r\n* 浮动元素都会产生一个块级浮动框，而不论该元素本身是什么类型（要记住，所有元素都可以浮动），因此对浮动的元素显式声明display:block是多此一举；\r\n* 有一系列的规则控制着浮动元素的摆放，比如：\r\n\t* 浮动元素彼此无法覆盖；\r\n\t* 浮动元素的外边界无法超过其包含块的内边界（当然使用负边界可以达到这样的效果）；\r\n\t* 浮动元素在竖直方向上会尽可能高地摆放，但是其顶端不能比之前的浮动元素或者块级元素的顶端更高；\r\n\t* 浮动元素在水平方向上会尽可能向左或者向右摆放，且位置越高，漂浮的更远；\r\n* 行内框与一个浮动元素重叠时，其边框，背景和内容都在该浮动元素之上显示（只有在浮动元素具有负边框的情况下才会看见这个情况）；\r\n* 块级元素与一个浮动元素重叠时，其边框和背景都在该浮动元素之下显示，而内容在浮动元素之上显示；\r\n* 使用clear进行清浮动，可以指定该元素的对应方向上不存在浮动元素，在CSS2.1中，使用clear的本质是引入了一个“清除区域”，清除区域是在元素上外边距之上额外增加了一个间距，且不允许任何浮动元素进入这个范围。这样造成的结果是设置了清浮动的元素的上边框边界推到了刚好越过浮动元素下边界的情况，出现“设置了上边距却没有出现间隔”的情况，解决这种情况的一个办法是设置浮动元素的下边距，相当于延长了浮动元素的下边界，从而达到预期的效果，具体的原理只有一句话：浮动元素的外边距边界定义了浮动框的边界\r\n\r\n### 定位\r\n不同类型的定位会影响对应元素框的生成：\r\n* static，块级元素生成矩形元素框，并作为文档流的一部分，内联元素生成行内框，置于其父元素中；\r\n* relative，元素偏移某个距离，其原本所占据的文档流位置仍然保留，其包含块由最近的块级框，表格单元格或者行内块祖先框的内容边界构成，\r\n* absolute，元素框从文档流中完全删除，并相当于其包含块定位，其包含块由最近的position属性值部位static的祖先元素的内容边界构成\r\n\r\n偏移量top,right,bottom,left描述了距离包含块对应边的偏移\r\n* 其值可正可负，正值会导致元素向内偏移，使边界朝着包含块的中心移动，负值会导致元素向外偏移。\r\n* 所有偏移量的计算都是使用外边距边界来进行的，而静态位置都是相对于包含块的内容区来进行的，偏移所移动的是元素框所有属性，包括外边距，边框，内边距和内容区。\r\n* 当同时声明了left和right会自动计算width的大小；当同时声明了top和bottom会自动计算height的大小；\r\n\r\n可以为偏移量设置为auto，这在不同的定位形式下的不同元素的表现上是不一样的：\r\n* 绝对定位:将left设置为auto，元素的左边界会相对于其定位钱本来的左侧位置对齐；将top设置为auto,元素的上边界相对于其未定位前本来的顶端位置对齐；将right设置为auto,元素的右边界会相对其未定位前本来的右侧位置对齐。\r\n* 在上述情况中，浏览器会自动计算元素的width和height；但是需要注意的是，在水平布局中如果left或者right设置为auto,在水平方向上元素都会相对于其静态位置（即未定位时的本来位置）摆放;在竖直方向中，只有top值为auto时元素会相对于其静态位置摆放，而bottom无法达到这种效果。\r\n* 在过度受限的情况下（这里指margin为auto），浏览器会忽略对应方向上的偏移并重新计算其偏移，甚至是竖直范行方向上的外边距（在正常流中，margin-top: auto的计算值为0）,这样就可以使用margin: auto 0达到竖直居中，比如下面的代码，可以使元素达到完全居中的效果;\r\n```\r\n.box {\r\n    background: red;\r\n    position: absolute;\r\n    width: 100px;\r\n    height: 100px;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    margin: auto 0 ;\r\n}\r\n//不要被四个0给唬住了，像下面这样，只要是过分受限，浏览器都会忽略并重新计算，这里可以理解为浏览器处理margin: auto的优先级更大...\r\n.box {\r\n    background: red;\r\n    position: absolute;\r\n    width: 100px;\r\n    height: 100px;\r\n    left: 10px;\r\n    right: 100px;\r\n    top: 30px;\r\n    bottom: 15px;\r\n    margin: auto ;\r\n}\r\n```\r\n\r\n## 最后\r\n本书后面的内容介绍了表布局，列表生成内容以及用户样式界面和非屏幕媒体。前面两章内容过于晦涩，后两章内容过于偏门，加之最近一直在忙着工作的事，因此这篇笔记草草结尾。《CSS权威指南》是一本非常难得的好书，值得反复阅读，细细琢磨，来日方长，定会多刷几次，第一次阅读完毕（好吧其实后面的内容还没有看完），最大的收获便是“CSS的复杂程度远超过它表面上看起来的那样，仍需不断地努力”。';
INSERT INTO shymean_article SET `title` = 'SCSS进阶', `created_at` = 1479826398, `category` = 'CSS', `tags` = 'SCSS', `content` = '\r\n最近阅读了一个按钮样式库[`button.css`](http://www.bootcss.com/p/buttons/)，尽管源码是用scss写的，我却看懵了：别人写的scss和我写的完全不一样啊，各种数组各种循环...！原本以为会用混合器和继承就差不多了，实际上还差的远了去了。然而之前看的教程文档上也只有这些基础，然后一通查询，摸索了一些关于SCSS进阶的方法，整理如下。\r\n<!--more-->\r\n\r\n参考资料：\r\n* [sass学习笔记-司徒正美](http://www.cnblogs.com/rubylouvre/p/3794292.html)。\r\n* [scss中国](http://sass.bootcss.com/docs/sass-reference/)    \r\n* [官方函数文档](http://sass-lang.com/documentation/Sass/Script/Functions.html)。\r\n\r\n## 占位符\r\n### 变量占位符\r\nsass使用PHP风格的$开头的变量命名风格，使用ruby风格`#{ }`占位符，占位符非常强大，可以用来拼接相应的属性，属性值甚至是选择器名称，然而占位器最主要的作用是用来构建可重用的样式!\r\n```\r\n$base: \'.txm\';\r\n#{$base}-list {\r\n    list-style: none;\r\n}\r\n```\r\n### 继承占位符\r\n正确使用`extend`可以生成分组选择器，节省很多代码量，但是有时候，我们想使用extend的功能，却不想输出继承的那个父类，这时就可以使用`%`类占位符\r\n```\r\n%col {\r\n    float: left;\r\n}\r\n\r\n.col-1 {\r\n    @extend %col;\r\n    width: 100px;\r\n}\r\n.col-2 {\r\n    @extend %col;\r\n    width: 200px;\r\n}\r\n// 这时就只会生成.col-1和.col-2，而不会生成单独的.col，十分方便\r\n```\r\n## 数据结构\r\n### 数组\r\nsass的数组,没有用使用[]包起来，而是通过空格来划分元素；如果是二维组数，则需要用到小括号与逗号。  \r\nsass的数组有一个特点，，也不能用[]来取其中的某一个元素，而是使用`nth()`内置方法,其索引值是从1开始（而不是大多数编程语言的数组从0开始）。\r\n```\r\n$base: \'.txm\';\r\n$list1: 5px 10px 15px 20px; // 一维数组\r\n$list2: 5px 10px, 15px 20px; // 二维数组\r\n$list3: (5px 10px) (20px 30px); // 同上，二维数组的另外一种表示方法\r\n#{$base}-list {\r\n    list-style: none;\r\n    padding: nth($list1,1); // 5px\r\n    margin: nth($list2,2); // 15px 20px\r\n}\r\n```\r\n除了`nth`方法之外还有几个其他的常用方法:\r\n* index($list, $value)，获取目标值的索引,从1开始\r\n    ```\r\n    $list1: 1px 2px 5px;\r\n    index($list1,5px); // 3\r\n    index($list1,10px); //找不到，则不会输出，应用该表达式的样式规则也不会在CSS文件中显示出来\r\n    ```\r\n* length($list)，获取数组长度，一般会搭配循环使用（实际上数组这个数据结构也许都是主要应用在循环生成多条样式规则上的）\r\n    ```\r\n    length($list1); // 3\r\n    ```\r\n* join($list1, $list2)，连接两个数组,第三个参数可以指定分割符(comma,space)。如果不指定则会自动判断使用逗号还是空格(貌似是根据第一个数组的类型来判断：一维数组则使用空格，二维数组则使用逗号。如果不确定，最好还是显式声明分割符。\r\n    ```\r\n    $list1: 1px , 2px;\r\n    $list2: 3px 4px;\r\n    join($list1, $list2); // 1px, 2px, 3px, 4px\r\n    join($list1, $list2, space); //1px 2px 3px 4px\r\n    join($list1, $list2, comma); // 1px 2px 3px 4px\r\n    \r\n    ```\r\n### 对象\r\nscss对象与JSON十分相似，区别在于使用`()`而不是`{}`来表示，对象提供了大量的函数，基本上都是以`map-`开头的\r\n*  map-get(obj,key)获取对象的某个属性\r\n``` \r\n$heading: (h1: 2em, h2: 1.5em, h3: 1.2em);\r\nfont-size: map-get($heading,h1); // 2em\r\n```\r\n* map-keys(obj)和map-values(obj)返回对象的全部键名或键值，以一维数组表示\r\n\r\n## 流程控制\r\n使用@if，@else, @for，@each和@while来表示流程控制\r\n### 条件\r\n@if后面的变量如果为真，则执行相应代码块，否则执行@else后面的代码块\r\n```\r\n$flag: true;\r\n.list{\r\n    @if $flag {\r\n        list-style: square;\r\n    }@else {\r\n        list-style: none;\r\n    }\r\n}\r\n```\r\n此外除了@if逻辑运算符，还有一个函数if()，可用于模拟三目运算符\r\n```\r\nif(unitless($width), $width + px, $width); // 判断$width是否有单位，没有单位则添加\'px\'\r\n```\r\n### 循环\r\n循环有三种形式：@for,@each和@while\r\nfor循环与JS类似，\r\n```\r\n$name: .t-col;\r\n// to相当于开区间\r\n@for $i from 1 to 5 {\r\n    #{$name}-#{$i} {\r\n        float: left;\r\n        border: #{$i}px solid #dedede;\r\n        width: percentage(1/$i);\r\n    }\r\n}\r\n// through相当于闭区间，包含结束值，比to多执行一次\r\n@for $i from 1 through 5 {\r\n    #{$name}-#{$i} {\r\n        float: left;\r\n        border: #{$i}px solid #dedede;\r\n        width: percentage(1/$i);\r\n    }\r\n}\r\n```\r\n@each 是用于遍历数组与对象的。如果是遍历对象，后面跟着两个变量，分别是键名与键值，逗号隔开，接着是in，最后是对象名。\r\n```\r\n$colorArr: red blue yellow;\r\n@each $color in $colorArr {\r\n\t.bg-#{$color} {\r\n\t\tbackground-color: $color;\r\n\t}\r\n}\r\n@each $key, $val in (h1: 2em, h2: 1.5em, h3: 1.2em) {\r\n\t#{$key} {\r\n\t\tfont-size: $val;\r\n\t}\r\n}\r\n```\r\n@while循环与JS也十分相似\r\n```\r\n$nums: 4;\r\n@while $nums > 0 {\r\n\t.while-#{$nums} {\r\n\t\twidth: $nums * 10px;\r\n\t}\r\n\t$nums: $nums - 1;\r\n}\r\n```\r\n\r\n## 函数\r\n### 功能函数\r\n整理了几个比较常用的函数：\r\n```\r\nunquote($string); // 去除字符串\r\nquote($string); // 为字符串添加引号\r\n\r\npercentage($number); // 生成百分数\r\nround($number); // 四舍五入取最接近的整肃\r\nceil($number)；// 向上取整\r\nfloor($number); // 向下取整\r\n\r\njoin($list1,$list2[,separator]); // 连接数组\r\nindex($list,$val); // 返回对应元素的索引\r\nlength($list); // 返回数组长度\r\n\r\nmap-get($map,$key); // 获取相应键名的键值\r\nmap-keys($map); // 返回对象的键名数组\r\nmap-values($map); // 返回对象的键值数组\r\n\r\n```\r\n\r\n### 颜色函数\r\n```\r\n// 饱和度通过灰色成分调节，而亮度用加白加黑来调节。\r\ndesaturate($color,5%); // 减少颜色饱和度\r\nsaturate($color, $amount)； // 增减颜色饱和度\r\ndarken($color,6%); // 使颜色变暗\r\nlighten(color,6%); // 使颜色变亮\r\n\r\n```\r\n### 自定义函数\r\nSCSS允许我们自定义函数\r\n```\r\n@function double($n) {\r\n　　@return $n * 2;\r\n}\r\n.test {\r\n　　width: double(5px);\r\n}\r\n```\r\n自定义函数是一个十分强大的功能，我目前使用到的最多的地方就是使用单位转换：\r\n```\r\n@function rem($pxVal){\r\n\t@return 1rem * $pxVal/75;\r\n}\r\n```\r\n这样就不需要再使用其他插件或者计算，就可以轻松实现rem布局了，函数的其他作用我正在探索中。';
INSERT INTO shymean_article SET `title` = '《JavaScript权威指南》读书笔记', `created_at` = 1464876300, `category` = 'JavaScript', `tags` = '读书笔记', `content` = '\r\n刚拿到权威指南这本书的时候被他的厚度吓了一跳，近千页密密麻麻的内容，心想不知道什么时候能看完。加之是刚接触JS，所以只能硬着头皮从头开始看。下面就是部分读书笔记，好记性不如烂笔头嘛。\r\n<!--more-->\r\n这本书将整个JavaScript分成了：前面部分是JavaScript语言特性和客户端JavaScript，后面部分是关于语言核心和客户端的参考。因此决定先通读前面的语言特性和浏览器API，而后面相关的参考作为字典查阅。\r\nJavaScript语言核心有一些很重要的知识点，比如闭包，原型链，正则表达式等；客户端JavaSCript也有诸如BOM，DOM和HTML5接口等分类。单是某些知识点就不能仅用一篇博文记载，因此这篇博文主要记载在阅读本书时了解到的一些容易被忽略的地方。\r\n\r\n## 语言核心\r\n语言核心主要介绍了JavaScript的语法结构，数据类型和变量，表达式和语句，函数，数组和对象等特性。\r\n\r\n### 语言环境\r\n由于历史的原因，JavaScript发展历经波折，也出现了许多不太好的语言特性，出现了使用`\"use strict\"`的严格模式和普通的非严格模式。严格模式下对一些不好的语言特性进行了限制。\r\n比如，严格版不支持八进制数字，也禁止出现不使用`var`声明的变量。\r\n但是现在JavaScript发展非常迅速哦。\r\n\r\n### 数据类型\r\n在JavaScript中，数据只分为原始类型（数字，字符串，布尔值，null和undefined）与对象类型；\r\n\r\n虽然数字字符串与布尔值这些原始类型不是对象，其行为与不可变对象非常相似，他们都可以可以使用类似于对象的的方法，主要是临时生成了一个__包装对象__，上述类型在读取其原有的属性和方法时像对象一样，但是如果对其属性进行赋值则会忽略这个操作（包装对象在调用属性和方法完毕之后就销毁了）。\r\n\r\n除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致。换句不恰当的话说：在JavaScript中，一切皆对象~~\r\n\r\n但是，原始类型的比较是通过值得比较来判断是否相等，但是对象只有同时为同一个对象的引用时才相等，否则即使对应的值完全相同也不相等。也就是说原始类型的赋值时值的传递，而对象的赋值是同一个对象的引用。\r\n\r\n另外书中还谈论了一个小问题：`null`和`undefinded`的区别是什么？\r\n> 前者表示非对象的空值；后者表示数字，字符串或者对象是无值的，通常用于已声明但没有进行赋值的变量。\r\n\r\n\r\n### 变量和作用域\r\n每个JavaScript解释器启动时，都会创建一个全局对象（在浏览器环境下就是window对象）。\r\n\r\n#### 变量声明\r\nJS的变量是无类型的，通过使用`var`来声明变量，在全局作用域下的变量被称作全局变量，全局变量看作是全局对象的一个属性。在非严格模式下，在任何地方出现的不使用var进行声明而直接赋值的变量也会作为全局变量。全局变量可以在代码的任何地方使用，我们应当尽量避免使用全局变量。\r\n\r\n#### 变量作用域\r\nJS的变量作用域为函数作用域，声明的所有变量（var function）都会被提前至作用域区的顶部，且在变量被赋值之前其值为undefined，变量在声明它的函数体内及该函数体内嵌套的所有函数体内都有有定义的。当既没有声明又没有赋值就直接调用变量，就会发生错误。\r\n\r\n前面提到全局变量（不在任何函数体内声明）可以看作是全局对象的属性，那么局部变量（即在函数体内声明的变量）可以看作是调用该函数的那个对象的属性；需要注意的是当使用var进行声明的时候，创建的这个属性数不可配置的，即无法用delete删除。\r\n\r\n每一段代码（全局代码或者函数块）都有一个与之相关的作用域链，这个链是一个对象列表（函数也是对象）或者链表，这组对象定义了作用域中的变量，当需要查找某个变量时，将从第一个对象（最近的那个函数作用域）一直寻找至全局对象，也就是说，函数的嵌套形成了作用域链。\r\n\r\n所谓闭包，也就是作为函数的参数或这是函数的返回结果的一个嵌套函数。由于作用域的存在，内部的嵌套函数可以访问外部函数作用域内的变量，并且可以将这些变量的生命周期延长到其父函数的生命周期之外，\r\n\r\n__每次调用外部函数时，内部函数又会重新定义一遍__。因为每次调用外部函数的时候，作用域链都是不同的\r\n\r\n### 表达式和语句\r\n\r\n#### 表达式\r\n表达式就是一条代码短语，用于提供给解释器并最终计算出一个结果。表达式分为了简单表达式和复杂表达式，其中：\r\n* 简单表达式指不包含其他表达式的原始表达式（比如一个变量名）\r\n* 复杂表达式是简单表达式通过运算符组合起来的。\r\n\r\n属性访问表达式指的：是通过 “.”访问符和\"[]\"访问符进行对象属性或者数组值进行访问。\r\n当“[]\"时将首先计算方括号内的表达式的值 并将其转换为字符串，这里需要注意的是如果属性名是字符串，则[]中也必须使用加上引号的字符串， 否则解释器会将它当成一个变量（变量名也是一个表达式）并计算其值，命名的属性不存在则表达式的值为undefined（而不是报错，对象不存在或null或nudefined则访问其属性就会报错）。如果属性名是一个保留字或空格标点符号及数字时只能使用方括号。\r\n\r\n在计算表达式的时候，可能会进行类型转换。所有对象转换为布尔值均为真，`==`运算符不进行类型的判断，恒等运算符`===`才进行类型检测。\r\n`switch(case)`选择语句进行匹配时，不会发生类型转换，也就是说，switch语句进行的是恒等计算。\r\n\r\n#### 语句\r\n表达式用来计算一个值，而语句是来执行以使某件事情发生（以分号 结尾）。有副作用的表达式称为表达式语句，此外声明语句用来声明新变量或者定义新函数。\r\n\r\n函数既可以通过表达式声明（将函数定义表达式赋值给一个变量`var f = function(){}`，也可以通过语句声明`function f(){}`，其中，前者无法在函数赋值之前通过该变量名调用，而后者在变量提升的影响下在作用域内均可以调用而无论函数具体的声明位置。\r\n\r\n也就是说，变量的声明是会提前的。但是采用var声明的变量，执行初始化的操作仍然在代码原位置，如果在初始化之前访问该变量值为undefined，此外多次声明同一个变量也是可以的，因为声明都会提前且值均置为undefined；而采用function进行函数声明语句不仅声明会提前，函数体也会提前（以表达式定义的函数在定义前无法被使用）。\r\n\r\n\r\n\r\n#### 运算符的优先级\r\n在表达式中，容易被忽略但是十分重要的一点就是运算符的优先级，书中也没有讲得很详细，[具体可以查看这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)，基本上是：括号 > 算术运算符 > 逻辑运算符 > 赋值运算符\r\n\r\n\r\n### 对象\r\n\r\n#### 属性\r\nJavaScript中的万物皆为对象（和包装对象），JS的对象都是关联数组。属性名一般都用字符串，尽管可以使用其他的值；当使用“.”时，后面跟的属性名是标识符，在程序运行的时候无法动态的修改；当使用[]时，属性名是通过字符串来表示的，可以在运行时更改。因此当不知道属性名的具体名字时一般采用方括号的形式。这样也可以为对象设置动态的属性名称。\r\n\r\n可以使用`for in`语句遍历对象属性，`for variable in object`在运行前会先计算object表达式，如果是null和undefined会跳过循环，如果是原始值则转换为包装对象，否则object本身就为对象了，将依次枚举对象的属性来执行循环，在每次循环之前，都先计算variable表达式的值，并将属性名（一个字符串）赋给他。（注意并不会枚举内置型方法和其他不可枚举的属性）。\r\n\r\n可以使用`delete`删除对象属性，但是delete只能删除自有属性（返回布尔值，只要删除成功或者没有任何副作用就为true），无法删除继承属性，要删除继承属性必须到定义这个属性的原型对象上删除。但是delete只是断开属性与宿主对象的联系，而不会去操作属性中的属性（意思是属性也是一个对象），由于已经删除的属性的引用依然存在，则会发生内存泄漏，因此在销毁对象时，需要遍历属性中的属性，依次删除。\r\n\r\n对象的属性包含了四种特性，除了值之外还包括可写性，可枚举性和可配置性，需要注意的是存取器属性（setter getter）不具有值和可写性（由setter是否存在决定），因此存取器的特性是读取，写入，可枚举性和可配置性。\r\n\r\n#### 方法\r\n对象不仅包含了特定的值，还可以拥有特定的方法，可以把方法看作是特殊的函数，他们对于调用的参数及返回值的处理完全相同，但是最主要的区别在于调用上下文（context，这个翻译很诡异的感觉）。在非严格模式下，函数调用的上下文是全局对象，而在严格模式下是undefined；方法调用的上下文是拥有该方法的这个对象，在方法调用中可以使用this调用该对象。\r\n\r\n当方法的返回值是一个对象的时候，该对象还可以继续调用它的方法，就像jQuery那样，因此当方法不需要返回值的时候，可以直接返回this，这样使用API就可以进行链式调用的编程风格。此外需要注意，嵌套的函数并不会从调用它的函数中继承this，如果需要应该将this保存在变量中，一般用self表示。\r\n\r\n#### 原型链\r\nJavaScript是通过原型实现继承的，每一个对象都与“原型”相关联，并且从原型继承相关属性，因此，对象的属性分为继承属性和自定义属性。且当对象继承的原型也具有原型的时候，这一系列链接的原型对象就是原型链。（待补充）\r\n\r\n#### 数组\r\nJavaScript中的数组是一种特殊的对象：属性名是递增的数字。简单总结了数组常用的方法：\r\n* 为新索引值赋值就可以添加元素，或者使用push和unshift（返回值为新数组长度）；\r\n* 如果将数组的length属性值减小，当前数组中那些索引值大于等于length的元素将被删除（需要注意的是将length增大，并不会数组中添加元素只是在数组尾部创建一个新的空白区域）。\r\n* 采用delete删除数组元素时，只是将对应索引位置的值变为undefined而不会改变数组长度；此外可以采用pop和shift从尾部或者头部删除元素（返回的是删除的元素值）。\r\n* pop/push shift/unshift在尾部/头部进行删除/添加操作；\r\n* join(\"-\")通过参数的字符将数组连接为字符串，默认为逗号，是字符串split()的逆向操作；\r\n* reverse()将数组中元素顺序颠倒（替换的是原数组本身）；\r\n* sort()排序，可以传入一个比较函数f(a,b)，若要第一个参数在前则返回负数，第二个参数在前则返回整数，相等返回0；\r\n* contact()连接两个数组的元素，并组合成一个数组，如果某个数组的元素包含数组，并不会递归扁平化数组的数组。 slice(n1,n2)返回数组的一部分，前闭后开区间。如果参数为负数表示相对于数组最后一个元素的位置，-1表示最后一个元素。该方法并不会修改原数组而是返回一个新的子数组；\r\n* splice(start,num,v1,v2...)该方法是在数组中插入或删除元素的通用方法，第一个参数指定操作（插入或删除）的起始位置（元素索引值）,第二个参数指定需要删除的个数，后面的参数表示插入的元素，除了第一个参数后面的参数都是可省略的。但是如果只是想插入元素，第二个参数也必须设置为0而非空。\r\n\r\n此外，新版本还新增的几种数组方法，这几种方法的第一个参数一般都是一个函数，函数的参数依次为数组元素，元素索引和数组本身（参数可以部分省略）；而这些方法的第二个参数一般都是this，即拥有第一个参数方法的那个对象。被调用函数的返回值十分重要。\r\n* forEach(f)从头到尾遍历数组并对每个元素调用所指定的方法；\r\n* map(f)同上，区别为对每个元素调用方法，这个方法的返回值将组成一个新的数组，然后由map返回该数组，该数组与原始数组具有相同的长度；\r\n* filter(f)该方法也返回一个数组，为原始数组经过过滤之后的子数组，f方法为过滤操作，如果返回为真则将数组元素添加进子元素中，注意该方法返回的是稠密数组；\r\n* every(f)和some(f)前者对所有数组元素进行判断，f全部返回true，every才返回true；后者只要有一个f返回true,则some返回true;这两个函数会执行短路操作。\r\n* indexOf()和lastIndexOf()返回给定目标元素的索引值。\r\n\r\n## 客户端的JavaScript\r\n待补充...';
INSERT INTO shymean_article SET `title` = '《MySQL必知必会》读书笔记', `created_at` = 1473775379, `category` = '数据库', `tags` = '读书笔记', `content` = '\r\n四月份的时候在腾讯课堂邵发老师的课上对mysql有了大致的了解，当时是使用C++操作数据库，加之处于迷茫状态，因此只能说是了解到了一点皮毛，连增删查改都不利索。\r\n最近在恰逢学习ThinkPHP，使用数据库模型，M()函数的时候才明白应当回头夯实数据库的基础知识，于是入手了《MySQL必知必会》并从头学习，（杜哥当初推荐的是《SQL必知必会》，只是草草翻阅，这也应该重新看看。PS：我的学习路线是不是十分凌乱？）\r\n\r\n<!--more-->\r\n## SQL基础概念\r\n数据库\r\n> 数据库是一个以某种有组织的方式存储的__数据的集合__，也可以理解为有组织的数据的容器\r\n\r\n表\r\n> 数据表指的是某种特定类型数据的结构化清单，用来存储某种特定类型的数据（指的并不是具体的数据类型，而是某种类型的事物）。\r\n> 每个数据表都有一个特定且惟一的名字，用来标识自己；然而，不同的数据库中的表明可以是相同的。\r\n\r\n列\r\n> 将数据表看作是excel表格类似，竖直方向上的列表示表中的一个__字段__，简称为字段（回想当初后台同学一口一个字段，然而我一脸懵逼。PS：在第10章提到，数据库列一般称为列，而在\"计算字段\"的连接上称为字段，然而实际上貌似并没有差别）。\r\n正确将数据分解成多个列是十分重要的，这样才能通过特定的列队数据进行排序和过滤（这也是我希望夯实数据库基础知识的目的之一）。\r\n每个列都有相应的数据类型，这个数据类型限制了该列中所存储的数据。\r\n\r\n行\r\n> 行指的是数据表中的一条__记录__，（有时候也叫做一个实体?）\r\n\r\n主键\r\n> 主键是一列或一组列，用来区分表中的每一行，因此，用来设置主键的列，对应的任意两行都不能具有相同的值，且不能为空值。\r\n\r\n## 使用MySQL数据库\r\n虽然这很无聊，我还是把每个命令的代码敲在博客里面吧。\r\n\r\n登陆mysql.console并创建一个新的数据库\r\n```\r\nCREATE DATABASE txm;\r\n```\r\n\r\n使用```show ```显示所有的数据库，可以查看到刚建立的数据库\r\n```\r\nSHOW DATABASES;\r\n```\r\n\r\n切换到对应数据库：必须先使用```use```打开数据库，才能操作其中的数据\r\n```\r\nUSE txm;\r\n```\r\n\r\n在数据库中创建一张新表。\r\n```\r\ncreate table txm_test(id int(2),varchar(5))；\r\n```\r\n\r\n使用```show```显示所有的数据表，可以查看到刚建立的表\r\n```\r\nSHOW TABLES;\r\n```\r\n\r\n也可以使用```show```显示列，查看每一列的详情\r\n```\r\nSHOW COLUMNS FROM txm_test;\r\n```\r\n\r\n还可以采用与之等效的简写方法\r\n```\r\nDESC txm_test;\r\n```\r\n\r\n注意：\r\n* MySQL语句是不区分大小写的（包括关键字和表名）（虽然可能在某些情况下表名会区分大小写），但是一般对所有SQL语句进行大小，对所有列和表明进行小写，方便阅读和调试；\r\n* 多条SQL语句必须使用分号(;)结尾。\r\n\r\n## 检索数据\r\n使用数据库，最重要的操作便是检索并得到想要的数据结果。\r\n### 检索列\r\n一个最简单的查询，检索指定的单个列\r\n```\r\nSELECT id FROM txm_test;\r\n```\r\n\r\n选择多个列，每个字段之间使用逗号(,)隔开，注意最后一个字段后不能再跟分割符\r\n```\r\nSELECT id, name FROM txm_test;\r\n```\r\n\r\n选择全部列，也就是整张表的所有数据，使用通配符(*)\r\n```\r\nSELECT * FROM txm_test;\r\n```\r\n\r\n注意：SQL语句一般返回原始的，无格式的数据，因此，一般很少使用检索出的原始数据\r\n### 检索行\r\n检索不同的行，如果有多个行对应列的值相同则值返回一个值（无法判断具体是哪一行的值？）\r\n```\r\nSELECT DISTINCT name;\r\n```\r\n\r\n限制SQL语句返回行数，使用LIMIT\r\n```\r\nSELECT id FROM txm_test LIMIT 10;\r\n```\r\n为了得到下一组数据，需要显式地指明偏移量\r\n```\r\nSELECT id FROM txm_test LIMIT 10,5\r\n# 等价写法\r\nSELECT id FROM txm_test LIMIT 10 OFFSET 5\r\n```\r\n\r\n注意：\r\n* 只带有一个值得LIMIT总是从第一行开始，给出的数是返回的行数；\r\n* 带有两个值得LIMIT可以指定从行号为第一个值的位置开始，返回的是起始位置后的下一组数据\r\n* 由于LIMIT子句是为了限制检索的输出结果，因此一般需要放在所有子句最后面（目前得到的结论是如此）\r\n\r\n### 排序\r\n使用order by 子句对检索结果进行排序（可以使用某个字段作为排序条件，但不选择输出该字段）。\r\n```\r\nSELECT id FROM txm_test ORDER BY score;\r\n```\r\n\r\n也可以同时指定多个字段作为排序条件，当前一个字段相等时使用后一个字段作为备选排序条件（也就是说，如果前面的字段不相等，则完全不会使用后面的字段进行排序）\r\n```\r\nSELECT id FROM txm_test ORDER BY id,score;\r\n```\r\n默认使用升序排列(ASC)，如果需要降序排列，需要显式地声明排序方向为降序(DESC)\r\n```\r\nSELECT id FROM txm_test ORDER BY score DESC;\r\n```\r\n需要注意的是在多个字段做为排序条件时，每个字段对应的排序方向都默认为升序，因此DESC只是修改对应字段的排序方向。如果想要所有的排序条件字段都按照降序排列，则需要对这些字段都奸商DESC\r\n```\r\nSELECT id FROM txm_test ORDER BY score DESC,id DESC;\r\n```\r\n注意：\r\n* order by是对检索输出结果进行排序，因此一般排在LIMIT语句之前，而处于其他的子句之后\r\n\r\n### 过滤\r\n数据表中含有大量的数据，可以通过指定搜索条件查询特定的数据，搜索条件是通过where子句定义的\r\n```\r\nSELECT *  FROM txm_test WHERE id = 1;\r\n```\r\nwhere支持由多种操作符组成的搜索条件，包括\r\n* = \r\n* <> 不等于，等价于 != \r\n* >和>=\r\n* <和<=\r\n* BETWEEN ... AND ...\r\n\r\n其中，如果字符的判断，需要为对应值加上单引号；是数值之间的比较，则不需要对值加单引号：\r\n```\r\nSELECT *  FROM txm_test WHERE name = \'tang\';\r\n```\r\n另外使用BETWEEN筛选某个范围内的值（不只是针对数值，也可以筛选日期和字符等），必须同时指定起始值和结束值，并用AND隔开\r\n```\r\nSELECT *  FROM txm_test WHERE id BETWEEN 1 AND 3;\r\n```\r\n此外多个搜索条件之间也可以通过AND或者OR组合\r\n```\r\nSELECT *  FROM txm_test WHERE id = 1 AND name=\'tang\';\r\n```\r\n需要注意的是AND的优先级高于OR，可以使用括号改变组合顺序\r\n```\r\nSELECT * FROM txm_test WHERE (id = 1 or id=3) AND name=\'tang\';\r\n```\r\n对于多个OR组成的搜索条件，可以简化成IN ()，每个条目之间使用逗号分隔\r\n```\r\nSELECT *  FROM txm_test WHERE id IN (1，2，3);\r\n```\r\n最后，可以使用NOT对条件进行取反\r\n```\r\nSELECT *  FROM txm_test WHERE id NOT IN(1,2,3);\r\n```\r\n\r\n### 模糊查询\r\n如果不知道对应列具体的值，可以使用LIKE，配合通配符 % 或者 _ 进行模糊查询，其中：\r\n* %代表任意数目的字符，可以是多个，也可以是0个\r\n* _代表有且只有一个字符\r\n```\r\nSELECT * FROM txm_test WHERE name LIKE \'%ng\';\r\n```\r\n注意：\r\n* 根据MySQL的配置方式，搜索是区分大小写的\r\n* 此外，尾空格可能会干扰通配符的匹配\r\n* 最后，使用通配符的搜索效率比较低\r\n\r\n### 使用正则表达式进行模糊查询\r\nMySQL仅支持正则表达式一个很小的子集，使用REGEXP指定正则筛选条件\r\n```\r\nSELECT * FROM txm_test WHERE name REGEXP \'.ng\'\r\n```\r\n\r\n##  处理数据\r\n存放在数据库中的数据格式一般不是应用程序所希望的格式，因此可以通过计算字段和函数对检索结果进行处理。虽然在客户端也可以对原始数据进行处理，然而，在数据库服务器上完成这些操作比在客户端要快得多。\r\n### 拼接字段\r\n可以使用拼接字段将多个值联结到一起构成单个值\r\n```\r\nSELECT Concat(name,\'(\',id,\')\') FROM txm_test;\r\n```\r\n由于新的值在数据表中并没有对应的字段，因此，为了在客户端获取该值，可以使用as为该值创建列别名\r\n```\r\nSELECT Concat(name,\'(\',id,\')\') AS id_new FROM txm_test;\r\n```\r\n### 文本处理函数\r\n文本处理函数主要有去除多余空格，转换大小写等\r\n```\r\n# 将结果大写\r\nSELECT name, Upper(name) AS upper_name FROM txm_test;\r\n# 去除右空格\r\nSELECT Concat(RTrim(name),\'(\',id,\')\');\r\n```\r\n\r\n### 日期处理函数\r\n日期数据一般采用特定的日期数据类型，由于无法确保实际的值及以后是否会发生改动，因此在进行筛选时，一般需要对值使用日期处理函数进行修饰，然后再与筛选条件进行比较。\r\n```\r\nSELECT * FROM txm_test WHERE Date(create_date) = \'2016-09-12\'\r\n```\r\n此外日期函数还有很多比如，Month和Year等...\r\n\r\n### 聚集函数\r\n如果只是需要汇总数据而并非每行具体的数据，可以使用聚集函数，分别是:\r\n* AVG\r\n* COUNT\r\n* MAX\r\n* MIN\r\n* SUM\r\n\r\n```\r\nSELECT AVG(id) AS avg_id FROM txm_test\r\n```\r\n\r\n';
INSERT INTO shymean_article SET `title` = 'RequireJS使用心得', `created_at` = 1484579075, `category` = 'JavaScript', `tags` = 'RequireJS, 工程化', `content` = '\r\n一直对于JS模块化开发心存敬畏，尽管很早之前就接触到了RequireJS（在微擎里面），实际项目中却仍旧采用的是最原始的在HTML文档中script标签里面写代码。一方面是因为后台的同学有时候需要自己写JS处理逻辑；另一方面是后台模板将共用的头部样式表和底部脚本都分离为单独文件，管理起来也不是很麻烦。因此一直没有去了解`require.js`。     \r\n最近一个多月一直在折腾新的博客，想着要不要试试`require.js`，然后一发不可收拾。\r\n<!--more-->\r\n\r\n\r\n貌似现在前端有了那么多开发环境和打包工具，`require.js`似乎也不是那么先进的样子，然而我想，模块化的思想终归是异曲同工的。下面就是使用`require.js`的一点心得。\r\n\r\n\r\n基本上都是参考官网文档和几篇博客进行学习的，下面是链接：\r\n* [require.js文档](http://www.requirejs.cn/docs/jquery.html)\r\n* [require.js中文文档](http://www.requirejs.cn/docs/api.html#usage)\r\n* [一篇文章掌握RequireJS常用知识](http://www.cnblogs.com/lyzg/p/4865502.html)，非常详细，非常推荐\r\n\r\n## 什么是模块\r\n学习使用`require`主要是为了避免直接在页面标签中写JS代码导致的一些问题：\r\n* 由于存在由于全局变量的问题，在JS代码中很容易造成命名冲突，尽管可以使用IIFE（立即执行函数）缓解这个问题。\r\n* 不同页面之间JS代码的管理和复用，之前的做法是维护一个公共的脚本文件，并定义相关的函数，在页面中按需执行。导致的问题是不同页面的逻辑可能冗杂在同一个公共的文件中，维护起来比较困难。\r\n* JS脚本的按需加载，前面提到后台将所有脚本都分离在一个单独的文件并在视图模板引入，导致的问题是每个页面都包含了全部的脚本，而事实上大部分脚本都是不会执行的，无形中增加了多次没有意义的访问请求。\r\n\r\n\r\n使用__模块化开发__可以解决这些问题。\r\n> 所谓模块化，要求在编写代码的时候，按层次，按功能，将独立的逻辑，封装成可重用的模块，对外提供直接明了的调用接口，内部实现细节完全私有，并且模块之间的内部实现在执行期间互不干扰。\r\n\r\n注意，模块化开发只是一种思想，这里要讨论的AMD规范是模块化开发的一种实现方式（并不是实现），也就是说，遵循AMD规范的开发方式，可以实现一种模块化开发。\r\n我对于模块化的理解是：一个JS文件单独处理一个独立的逻辑，这样做的好处是便于管理和维护。一个页面上根据需要引入相关的JS文件。此外，在这个模块处理逻辑的时候，也允许使用依赖其他的模块；当然，也允许其他模块依赖该模块。类似于搭积木一样，实现整个项目，甚至于还可以在其他项目类似功能的地方使用同一个模块，大大减少重复代码的书写。PS：我的理解是如此浅陋，因此下面的\"模块化\"字段自动打上双引号 （/斜眼笑）。\r\n\r\n实际上，在使用SCSS写CSS代码的时候，不知不觉中已经在使用这种模块化的思想了。在前面的那篇关于CSS代码维护的思考，为了应对客户无休止的页面需求更改，我将样式表拆分成了数个目录下不同的独立`_xxx.scss`文件（定义模块），然后使用目录的入口文件引入相应目录的颗粒样式表（加载模块），最后在`main.scss`中引入这几个入口文件，输出最终的样式表，这样在模块化的CSS文件上定位问题和替换样式就变得简单许多。\r\n\r\n使用SCSS预编译的`@import`指令可以完成CSS的模块化管理，那么，这里谈到的JS模块化在浏览器中怎么实现呢？没错，就是使用`require.js`，下面就来介绍今天的主角。\r\n\r\n## Require使用\r\n`require.js`可以帮助我们实现类似于遵循AMD规范的模块化代码。先忽略语法，我们最需要明白的是：`require.js`为我们提供了两个最主要的功能，一个是定义模块，一个是加载模块。有了这两个功能，我们就能在浏览器中实现JS模块化开发。跟官方文档一样，我们先了解如何加载模块，再学习如何定义模块\r\n\r\n### 目录结构\r\n加载模块的基础应当是规划项目的目录结构，在学习语法之前，应当思考一下如何管理我们的代码结构，`require.js`官方推荐的目录结构是如下的扁平结构\r\n```\r\nhtml/\r\n\r\njs/\r\n-\tapp/\r\n\t\tsub.js\r\n-\tlib/\r\n\t\tjquery.js\r\n\t\tcanvas.js\r\n\t\tapp.js\r\n```\r\n\r\n其中`lib`存放第三方库文件，`app`文件夹用来存放项目的逻辑代码。实际中，我们又可以根据页面或者是项目逻辑将`app`细分成不同的文件夹，比如\r\n```\r\n-\tlib/\r\n\t\tjquery.js\r\n-\tindex/\r\n\t\tindex.js\r\n-\tlogin/\r\n\t\tlogin.js\r\n        signin.js\r\n        validate.js\r\n-\tpage1/\r\n\t\tpage1.js\r\n……\r\n```\r\n根据官方的建议：为了避免凌乱的配置，最好不要使用多级嵌套的目录层次来组织代码，而是要么将所有的脚本都放置到baseUrl中，要么分置为项目库/第三方库的一个扁平结构。\r\n\r\n\r\n### 加载模块\r\n清晰地组织相关页面的JS文件，在维护起来会十分方便，因为我们可以快速定位源文件。然而，平时我们不是可以直接根据`<script>`的`src`属性寻找到相关的文件吗？\r\n没错，上面按层次划分目录只是模块化的第一步，实际项目中一个页面肯定不仅仅只引入一个`<script>`标签，我们是根据脚本的先后顺序来确定插件之间的依赖关系的。换句话讲，页面上的脚本标签必须严格按照他们之间的依赖关系来书写，这里存在两个问题：\r\n* 脚本之间的依赖关系并不能十分明显地展示出来，比如`jquery.js`和`bootstrap.js`，尽管我们知道`bootstarp.js`依赖`jquery.js`，但是并不能直观地看出来；某些jquery插件使用`jquery.xxx.js`的方式来表明这是一个依赖于`jquery`的插件，然而总体来说，我们仍然需要一种能够清晰明了地查看脚本之间的依赖关系的方法\r\n* 同前一条，页面上也可能存在互不依赖的脚本，他们之间的加载顺序可以是任意的，而为了快速定位和调试问题我们也需要一种区分各脚本之间是否存在依赖关系的方法。\r\n\r\n`require.js`提供的解决办法是：一个页面只使用一个`<script>`标签。\r\n\r\n没错，一个页面只使用一个`<script>`标签，这个标签用于加载`require.js`文件；一个页面对应一个应用脚本文件(这里暂且先叫做`page1.js`)，该文件的路径保存在这个`<script>`标签的`data-main`自定义属性上。\r\n```\r\n// data-main路径上可以不用书写.js后缀\r\n<script src=\"js/require.js\" data-main=\"js/page1/page1.js\"></script>\r\n```\r\n这样，在运行到这个脚本的时候会自动加载`page1.js`，然后会自动加载`page1.js`中所声明依赖的脚本模块，然后执行相关逻辑。需要注意的是所加载的模块，在定义的时候已经指定了其所依赖的脚本模块，`require.js`在加载的时候会自动处理这些依赖关系并保证脚本正确执行，如何定义模块我们后面会详细了解。现在让我们看看如何在`require.js`中声明依赖的脚本模块（假设我们的目录组织如前面所说的那样）。\r\n\r\n```javascript\r\n// page1.js\r\n\r\n// 配置基础路径和依赖组件名称\r\nrequire.config({\r\n    baseUrl:\'js/\',\r\n    paths:{\r\n        \'jquery\':\'lib/jquery-2.0.3\'\r\n    }\r\n})\r\n\r\n// 加载相关组件\r\nrequire([\'jquery\'],function ($) {\r\n    console.log($);\r\n});\r\n\r\n```\r\n实际上`require.js`是通过`module ID`来加载依赖模块的，从上面代码可以看见这个__页面应用脚本__`page1.js`中分成了两部分：配置和加载。\r\n\r\n#### 配置\r\n`require.config`配置主要定义`baseUrl`和`paths`属性（另外还有一些其他比较重要的属性，稍等片刻）。这两个属性用来解析对应的模块路径。\r\n\r\n__基础路径`baseUrl`__\r\n\r\n`baseUrl`指定了一个目录，然后`requirejs`基于这个目录来寻找依赖的模块。\r\n`baseUrl`的所表示的目录值，可为绝对路径，可为相对路径，绝对路径很容易理解，但是相对路径是相对于什么呢？\r\n* 在没有任何配置和`data-main`的情况下，`baseUrl`为引入`require.js`文件的那个HTML文件所在的目录\r\n* 如果设置了`data-main`，则`baseUrl`的值为该属性所表示的那个脚本文件所在的目录\r\n* 如果在`require.config()`中手动配置`baseUrl`的值，则`baseUrl`的值即为配置的值\r\n\r\n上述值的优先级从上到下依次增大。\r\n\r\n__模块路径`baseUrl`__\r\n\r\n如果仅仅根据`baseUrl`来加载模块，存在下面两个问题：\r\n* 每个模块基于`baseUrl`的路径名可能会很长\r\n* 模块的存放位置可能改变，导致维护十分困难\r\n\r\n为了解决这两个问题，可以使用`paths`来配置每个模块的路径，键值可以直接具体到某个模块文件，也可以用来表示某个目录。\r\n然后`require.js`就会根据`baseUrl + paths`来解析模块的`module ID`。\r\n\r\n__模块ID`module ID`__\r\n\r\n所谓的`module ID`指的是在使用`define()`和`require()`函数时声明的模块的别名，`require.js`会根据`module ID`所表示的路径来加载相应的组件。\r\n```javascript\r\n// \'a\' 和 \'lib/b\' 都是 \'module ID\'\r\nrequire([\'a\',\'lib/b\'],function(){\r\n    // todo\r\n})\r\n```\r\n这里需要理解的是，一个`module ID`所表示的就是一个模块文件（不带后缀名`.js`）：\r\n* 如果某个`paths`代表的就是一个具体的模块文件，则可以直接将该键名作为`module ID`；否则需要将该`paths`所表示的目录下的某个模块文件名作为`module ID`。\r\n* 即使不声明某个`moduleID`的paths，也可以直接根据`baseUrl`来加载模块，`paths`主要是为了减小`module ID`的长度，以及便于维护。\r\n\r\n如果一个`module ID`符合下述规则之一，其ID解析会避开常规的`baseUrl+paths`配置，而是直接将其加载为一个相对于当前HTML文档的脚本：\r\n* 以 \".js\" 结束.\r\n* 以 \"/\" 开始.\r\n* 包含 URL 协议, 如  \"http:\" or \"https:\".\r\n\r\n注意第二点，并不是相对于根目录，而是当前引入`require.js`的HTML文档的所在目录！\r\n\r\n#### 加载\r\n\r\n配置好相关的`module ID`之后，需要显式地指定所依赖的模块，`require.js`才会进行加载。\r\n`require()`函数的第一个参数是一个`module ID`的数组，声明需要加载的脚本文件（后面全部简称为模块）。前面提到`module ID`可以不需要配置`paths`，因此这里可以直接使用某个模块文件的路径作为`module ID` 的方式进行声明（这里也可以算作是目录不要嵌套太深的一个理由）。\r\n\r\n`require()`函数的第二个参数是一个回调函数，在加载相关的模块之后就会执行该函数。前面提到，一个模块应当返回一个可以调用的接口供外部使用，那我们怎么在这个回调函数中调用前面加载的模块的接口呢，这里有两种办法：\r\n```javascript\r\n// 根据`module ID`数组，依次定义相关模块的输出变量，并按顺序作为这个回调函数的参数\r\nrequire([\'jquery\',\'testA\',\'testB\'],function ($, a, b) {\r\n    console.log($);\r\n    console.log(a);\r\n    console.log(b);\r\n});\r\n\r\n// 使用require(module ID)的方式\r\nrequire([\'jquery\',\'testA\',\'testB\'],function () {\r\n\tvar $ = require(\'jquery\');\r\n    var a = require(\'testA\');\r\n    var b = require(\'testB\');\r\n});\r\n```\r\n相比之下我更喜欢第二种方式调用模块提供的接口。\r\n\r\n#### 备份地址\r\n我们不仅可以声明使用本地模块，也可以引用第三方库文件，只需要在Paths中正确配置路径即可。\r\n但是我们从CDN中引入依赖脚本，又必须处理引入失败的情形，以前的处理办法是检测`window.jQuery`是否存在，然后创建`<script>`标签。\r\n在`require`中，可以在配置`paths`的时候可以使用一个数组，`require`会在前面的路径加载错误的时候去尝试加载后面的路径。但是需要注意的是这种配置只能用于`module ID`表示具体的脚本文件的情形。\r\n```javascript\r\npaths:{\r\n\t\'jquery\':[\r\n            \'http://cdn.bootcss.com/jquery/3.1.1/jquery\',\r\n            \'lib/jquery-2.0.3\'\r\n        ]\r\n}\r\n```\r\n如果第一个文件请求失败或者超时，就会加载本地文件，是不是很方便...\r\n\r\n### 定义模块\r\n现在我们知道了如何加载模块（尽管还有一些需要注意的地方没有找到），那么如何编写合适的模块呢？\r\n前面提到，定义的模块可以显式地列出其依赖关系，并以函数参数或者`require(module ID)`的形式使用这些依赖构造当前模块，而无需引用全局变量，避免全局名称空间污染。\r\n\r\n#### 模块返回\r\n根据模块的功能，有下面几种定义模块的方式。\r\n```javascript\r\n// 模块仅包含值对且没有依赖\r\ndefine({\r\n    test:function () {\r\n        console.log(1);\r\n    }\r\n});\r\n\r\n//如果一个模块没有任何依赖，但需要一个处理工作的函数，则在define()中定义该函数\r\ndefine(function(){\r\n    var test = function () {\r\n        console.log(1);\r\n    };\r\n\r\n    return {\r\n        test: test\r\n    }\r\n});\r\n\r\n```\r\n如果模块存在依赖：则第一个参数是依赖的名称数组；第二个参数是函数，这里就跟定义页面应用脚本类似\r\n这里也可以使用require.config()来配置模块依赖文件的路径，这样就不需要再页面应用脚本去声明依赖了，各个模块之间的依赖关系一目了然。\r\n```javascript\r\ndefine([\'jquery\'],function($){\r\n\tconsole.log($);\r\n    var test = function () {\r\n        console.log(1);\r\n    };\r\n\r\n    return {\r\n        test: test\r\n    }\r\n});\r\n```\r\n\r\n这里的难点是：如果定义模块A依赖于`jquery`，然后页面应用脚本依赖于A，那么这个`jquery`的相对路径到底是相对于模块文件A，还相对于页面应用脚本呢？\r\n\r\n#### 模块依赖\r\n我在页面应用脚本和模块A文件中分别定义了两个不同的`jquery`的`paths`（但是声明的`module ID`均是`jquery`），得到的测试结果是，\r\n* 只要这两个文件的某一个文件配置了`jquery`的`baseUrl + paths`，则均可以正确加载\r\n* 如果两个文件都配置了`module ID`（页面应用脚本没有声明加载），则会加载模块A的那个`module ID`所指定的路径；\r\n* 如果页面应用脚本也声明加载了`jquery`模块，则`require.js`只加载页面应用脚本声明的那个`jquery`文件。\r\n\r\n这里让我困惑的是如果模块A对`jquery`的依赖有版本限制的话，上面的情形就可能导致出现错误，尽管可以声明不同的`module ID`进行处理，但并不是很完美的解决办法。\r\n\r\n\r\n另外如果定义多个模块都需要依赖某个文件（这里还是用`jquery`举例），考虑下面几种情形：\r\n* 根据这些模块文件的位置声明不同的`module ID`路径（尽管路径最终的文件都是同一个`jquery.js`文件，但是每个模块的存放目录不同，导致最终解析的`module ID`也不同）\r\n* 在页面应用脚本配置对应的`module ID`表示具体的`juqery.js`，然后在定义的模块中直接声明使用`jquery`作为`module ID`即可（似乎还不错，但是思考一下，一个网站应该存在多个页面应用脚本，使用这种方法则需要在每个页面应用脚本上都配置一次关于`jquery`的`module ID`，与上面的直接在定义的模块文件中进行声明也没有多大区别）。\r\n\r\n为了处理这种问题，我的解决办法是，单独声明一个`config.js`的模块文件，直接配置整个项目全部的模块`paths`，表示具体的模块文件，然后在每个页面应用脚本先加载该配置文件，然后再加载该页面的依赖脚本。\r\n```javascript\r\n// config.js\r\nrequire.config({\r\n    baseUrl:\'js/\',\r\n    paths:{\r\n        \'jquery\':\'http://cdn.bootcss.com/jquery/3.1.1/jquery\',\r\n        \'math\':\'base/math\'\r\n    }\r\n});\r\n\r\n// page1.js\r\nrequire([\'js/config.js\'],function(){\r\n\t// 由于加载是异步的，必须等待config.js文件加载完成才能正确解析其他module ID\r\n    require([\'jquery\',\'math\'],function () {\r\n\r\n        var math = require(\'math\');\r\n        math.test()\r\n    });\r\n});\r\n\r\n// 模块文件\r\n// 直接使用config.js里面配置的paths作为module ID即可\r\ndefine([\'jquery\'],function($){\r\n    console.log($);\r\n    var test = function () {\r\n        console.log(1);\r\n    };\r\n\r\n    return {\r\n        test: test\r\n    }\r\n});\r\n```\r\n\r\n这样就可以将所有的模块统一在一个文件中进行管理，即使以后目录结构改变，或者模块文件重命名，也只需要更改`config.js`文件中的路径即可，这也正是我目前使用的`require.js`的方式。\r\n\r\n## 文件打包\r\n\r\n尽管正确使用`require.js`可以让我们很方便地在目录结构上管理我们的代码，良好的模块化必定依赖于多个细分的文件，这样做的后果就是如果不加以处理，一个页面中可能会请求数十个脚本文件，尽管`require.js`在加载文件的时候使用了`async`和`defer`属性，但仍旧需要等待异步和延迟的脚本加载并运行完毕之后浏览器才会进入事件驱动阶段。\r\n因此，在编写代码的时候，处于便于维护和管理的目的，我们应该使用模块化管理文件；但是在项目完成即将上传的时候，处于减轻服务器负担的目的，我们应该将零散的模块文件打包，依此减少浏览器请求数量，提高页面加载效率。\r\n`require.js`提供了一个相关的打包工具，叫做[r.js]()，经过一番尝试之后，重新折回来记录一点使用方法和心得。\r\n\r\n### 使用方法\r\n`r.js`是一个在node环境下的脚本，通过我们自定义的配置文件，将某个使用`require`的应用脚本文件与他的相关依赖模块整合到一个文件中，前面提到的配置文件就是用来声明该模块的文件的相关依赖文件的路径的。\r\n这里假设我们的目录还是上面的`page1`那样\r\n首先，将`r.js`移动到需要打包模块的目录下，也就是`js/page1/`下，新建一个`build.js`的文件，该文件用于配置相关参数。\r\n```js\r\n// build.js\r\n({\r\n\t//基础路径\r\n    baseUrl: \'../../js\',\r\n    // 依赖模块的路径\r\n    paths: {\r\n        a: \'lib/a\',\r\n        b: \'lib/b\',\r\n        marked:\'empty\',\r\n    },\r\n    // 需打包应用文件的名称\r\n    name: \"page1/page1\",\r\n    // 输出文件名\r\n    out: \"dist/page1-built.js\"\r\n})\r\n```\r\n关于`build.js`还有一些其他的参数，暂时还没有去了解。刚看见这个文件的时候，心想这不跟前面提到的`config.js`很像吗?\r\n\r\n在配置好`build.js`之后，就可以打开控制台，输入\r\n```\r\nnode r.js -o build.js\r\n```\r\n然后就会在指定的out路径生成对应打包好的文件了，打开输出文件可以看见，确实是将相关的依赖文件都整合到了这一个文件中，并进行了压缩（但是有时候我发现文件虽然打包在一起，但并没有进行整合）。\r\n\r\n哈，不会就这么简单吧！上面只是最顺利的理想状态，实际上，在使用的时候我遇见了很多的坑。\r\n* build.js中的`baseUrl`并不是require.js中的基础路径，貌似是相对于需要打包的应用文件的相对路径，后面的`paths`，`name`，`out`都是根据这个配置的`baseUrl`来寻找的\r\n* r.js会尝试着对合并后的文件进行压缩，但是某些ES6的语法特效却不被支持，诸如`let`局部变量，`action(){}`对象方法简写等书写都会在控制台报错，这个就有点坑了，需要在合并之前进行babel转义，这个我并不是很了解，还得进行进一步的尝试才行\r\n* 之前使用了一个config.js来管理整个项目的模块，应用脚本文件先引入该配置文件之后再加载相关依赖，这里特别需要注意这里声明的config.js文件的`moduleID`。根据依赖关系，打包之后config.js里面的配置`require.config()`会出现在最前面，而后面的模块文件中使用的`require([\'config\'])`也是依赖于config.js中配置的`baseUrl`，这里会非常坑。实际上有了build文件，可以直接将`require.config()`放在`data-main`的应用脚本文件上，但是考虑到一个项目可能存在的多个应用脚本，统一管理模块还是十分有意义的。\r\n* 如果需要保留某些引入的模块路径，而不是将全部的文件都压缩到一个文件中去，可以build.js的`paths`属性对应`moduleID`赋值为`\"empty:\"`，这样，在打包的时候就会保留对应模块的加载路径而不是无脑打包全部的文件了，注意这个`empty:`后面有个冒号~~~\r\n\r\n## 小结\r\n关于如何管理和维护代码（CSS和JS），过去的几个月里我进行着反复的尝试和探索，未来也会进行下去。工作不应该仅仅只是实现某个功能就结束，草草了事会给自己或是后面的同事带来无数的坑。\r\n写代码是一件很幸福的事情，写出能够维护的代码更是成就感爆棚的事情，回顾之前的代码，有的地方耦合性太强（甚至还有$(\".t\").parent().parent()...），有的代码重复粘贴在好几个地方，有的地方还存在各种潜在的BUG，所以，功夫尚浅，继续学习吧！接下来可以去尝试学习一下webpack了。';
INSERT INTO shymean_article SET `title` = '《Sass与Compass实战》读书笔记', `created_at` = 1474115818, `category` = 'CSS', `tags` = '读书笔记', `content` = '\r\n虽然最初使用Less写了两个项目，后来又转为Scss开发，经过短暂的语法学习就直接在生产环境中使用（没有人管...）。不过使用的只是诸如变量，嵌套这一些比较基础的语法，时间久了就有一种\"暴殄天物\"的感觉，所幸有网友推荐了这本《Sass与Compass实战》，带着“真正学会Scss，提高工作效率”的目的，以及那个困扰我许久许久的“选择器命名”问题，开始学习本书。PS：书很薄，二百来页。\r\n<!--more-->\r\n## Sass基础语法\r\n写Sass和读Sass和读写CSS十分相似，Scss是Sass的一个超集。我们关注的焦点应当放在如何使用Sass特性来优化书写CSS的过程。Sass的主要特性有：\r\n* 变量——最简单、最基本的重用形式；\r\n* 选择器嵌套——保持样式表的简洁和易读性；\r\n* 引入样式——将大片的样式拆分到不同文件，通过组织文件保持可维护性；\r\n* 混合器和继承——重用大段样式。\r\n\r\n由于在[初识SCSS](https://tangxiangmin.github.io/2016/08/05/%E5%88%9D%E8%AF%86SCSS/)这篇博中已经简单了解了Scss的基础语法，这里只是简单记录一下，作为复习。\r\n### 变量\r\n使用 __$__ 符号来标识一个变量，因为$符号在CSS中没有任何用途，不会导致与现存或未来的CSS语法冲突。\r\n任何作为CSS属性值的赋值都可以作为Sass的变量值，甚至是以空格分割的多个属性值。\r\n变量可以定义在CSS规则块之外；当变量定义在CSS规则块之内的时候，该变量具有__块级作用域__，即其值只能在该规则块及其子规则块下使用。\r\n此外变量名不区分下划线和中横线，也就是说$test-color和$test_color指向同一个变量，然而，统一使用同一种风格是很有必要的。\r\n\r\n### 嵌套规则\r\n选择器嵌套使用的十分频繁，需要注意的就是父选择器的标识符 __&__，可以用来处理伪类选择器 ;此外关于子组合选择器>和同层组合选择器+,~等，都能被Scss正确解释。\r\n此外还有属性值嵌套，由于CSS原生语法就支持部分组合属性，因此属性值嵌套用的并不是很多，主要用来解决border-right,border-left等这样的属性。\r\n关于选择器嵌套需要明白，嵌套只是让样式表看起来很小，实际上生成的CSS文件可能很大（浏览器只认CSS文件），在群组选择器中这种情形发生的可能性更大，因此，使用嵌套要慎重，不要使用毫无意义的多重嵌套。\r\n\r\n### 引入样式\r\n在Scss中，可以将样式分散到多个文件，这样整个项目可具备非常良好的维护性，且独立的样式甚至可以在其他项目中重用。\r\n不同于原生的CSS@import,Scss会将多个文件下的代码编译成一个文件，这样完全不用担心造成多次服务器请求的问题。\r\n为了避免在每个Scss文件都被编译成css文件，可以在这些__局部文件__（即只为了@import命令而书写的文件）名字前加上下划线_，这样就可以将多个Scss样式组件编译成一个css文件。\r\n前面提到了变量的块级作用域:\r\n* 在多个引入的Scss文件之间，前面文件中的全局变量可以在后面文件中使用（当然反过来就会报错：未定义的变量）；\r\n* 而后定义的变量会覆盖前面文件中的同名变量（注意短横线和下划线表示相同的变量）。\r\n\r\n然而在某些时候，我们可能担心自定定义的变量会与前面文件中的变量发生冲突而无法使用前面的变量（比如在使用第三方样式库的时候，我们更希望优先使用样式库中的变量值），这种情况下可以使用默认变量，即在定义变量值之后加上default即可，这样，只有当前面的文件没有定义该变量时才会使用我们自定义的变量值。\r\n```\r\n$basecolor : #ff00cc !default;\r\n```\r\n\r\n### 混合器\r\n混合器类似于函数，可以用来定义将会重用的大段样式：\r\n* 使用@mixin来定义混合器\r\n* 使用@include来调用混合器\r\n可以向混合器传递参数来修改最终的样式数值，甚至可以为混合器的参数设置默认值。\r\n```\r\n/*border-radius*/\r\n@mixin bd-r($size:5px){\r\n\t-webkit-border-radius: $size;\r\n    -moz-border-radius: $size;\r\n    border-radius: $size;\r\n}\r\n.test {\r\n\t@include bd-r(10px);\r\n}\r\n```\r\n利用混合器可以尽可能的重用样式（当然这只是减少在书写CSS代码时的复制粘贴，实际生成的CSS文件可能非常大）。\r\n重新翻阅到混合器这里，突然想到之前的“面向属性的CSS选择器命名”，当时由于考虑到由于“不要对任何任何网站通用的样式进行分离”，那么，将基本的样式定义成混合器怎么样呢？这样，如果有需要修改的地方，只需修改对应的参数或者是移除对应的混合器即可。将混合器当作是css的属性缩写，这样可以极大的减轻代码量。为了避免编译的CSS样式表过大，需要注意使用混合器的场合：即反复重用的视觉样式。记得有位前辈说，现在在压缩的情况下，CSS文件大小根本不是影响页面加载速度的因素，如何增加工作效率，身心愉悦的工作才是最应当考虑的问题...汗。\r\n书中关于正确使用混合器的建议是：如果能为混合器找到一个恰当的语义化名字（即对应的视觉样式描述），那么这段样式就可以使一个优秀的混合器；反之，可能就不那么合适了。\r\n另外，混合器可以包含CSS规则，包含选择器和选择器中的属性————因为，混合器本质上就是一段复用的CSS代码而已。\r\n最后，需要注意的是，尽管混合器跟函数相似，但是只能在CSS规则调用前面定义的混合器，而函数而可以出现在同级作用域之间的任何位置。\r\n\r\n### 选择器继承\r\n选择器继承是“面向对象的CSS”里面的概念，在Scss中主要通过@extend来实现选择器继承。当时在sass中国的网站上学习Scss的时候，关于选择器继承一直没有弄明白，经过本书的讲解，豁然开朗。\r\n选择器继承，实际上是通过分组选择器来实现的，比如一个.seriousError的类，想让他继承.error类的全部样式，就需要使用@extend（注意是全部样式，而不是部分样式，如果想要继承部分样式，应当将公用样式拆分成单独的类然后再继承，或者使用混合器）。\r\n```\r\n.error {\r\n\tcolor: red;\r\n\tfont-weight: bold;\r\n}\r\n.seriousError {\r\n\t@extend .error;\r\n\tborder: 1px solid #000;\r\n}\r\n```\r\n编译生成的CSS文件：\r\n```\r\n.error, .seriousError {\r\n  color: red;\r\n  font-weight: bold; }\r\n\r\n.seriousError {\r\n  border: 1px solid #000; }\r\n```\r\n实际上，选择器继承的原理，是将样式表中父类出现的任何地方（包括出现在子类后面的位置）都转变成(父类,子类)形式的分组选择器，这样，子类就拥有了父类的全部样式，然后独自拥有自定义的样式。\r\n与混合器相比，使用继承会生成更少的样式代码（因为混合器会完全复制重用的代码，而选择器继承是通过分组选择器实现的）\r\n关于继承，有几个需要理清的地方：\r\n* 只有全部命中子类选择器的元素才会继承父类的样式，即#main .seriousError  @extend .error 中，只有#main下的.seriousError选择器对应的元素才有.error的全部样式，因为出现在分组选择器的是#main .seriousError而不是单独的.seriousError\r\n* 选择器继承也遵从CSS层叠的规则，即浏览器最后采用的是样式权重值更高的样式，虽然分组选择器并不会增加或者减少选择器的权重值，但是“知道这点总没有什么坏处”——书本原话。\r\n* 最后也是最最重要的一点，不要滥用选择器继承。如果父类是一个后代选择器，为了使子类完全继承父类的全部样式，Scss必须考虑全部情况：比如\r\n\r\n```\r\n.wrap .box {\r\n\t@extends .father\r\n}\r\n.foo .father {\r\n\tcolor: red;\r\n}\r\n```\r\n在这种情况下，为了使.wrap下的.box选择器对应的元素继承.foo下.father元素的样式：红色字体，必须限制.box选择器为.foo选择器的后代选择器，因此Scss生成的CSS样式必须考虑下面三种情形:\r\n\r\n```\r\n// 情形1\r\n<div class=\"wrap\">\r\n    <div class=\"foo\">\r\n        <div class=\"box\"></div>\r\n    </div>\r\n</div>\r\n\r\n// 情形2\r\n<div class=\"foo\">\r\n    <div class=\"wrap\">\r\n        <div class=\"box\"></div>\r\n    </div>\r\n</div>\r\n\r\n// 情形3\r\n<div class=\"wrap foo\">\r\n    <div class=\"box\"></div>\r\n</div>\r\n```\r\n因此生成的CSS代码为\r\n```\r\n.foo .father, .foo .wrap .box, .wrap .foo .box {\r\n  color: red; }\r\n```\r\n我使用的是Koala编译，可以看到结果中并没有出现.wrap.foo .box的情形（实际上Scss并不总是生成所有的选择器组合）。因此，得到的结论便是：\r\n__不要让子类继承作为后代选择器的父类样式__。（我们可以放心地继承包含后代选择器的选择器）\r\n\r\n## 高性能样式表\r\n书中关于样式表的性能有如下建议：\r\n* 减少传输时间\r\n\t* 开启服务器的gzip压缩可以极大的降低样式表的大小（甚至可以压缩到原来的10%~15%，有这么夸张？）\r\n\t* 压缩图片（这里的图片指的是样式表中所使用的背景图片，并尽可能使用精灵图片来减少服务器的请求次数）；\r\n* 利用资源托管来提高页面加载速度\r\n* 选择器性能，一直以来对于选择器性能耿耿于怀，书中的一句话让我走出了死胡同，“选择器的结构和数量会对页面产生微小却可以度量的影响，然而根据20-80的理论，首先应当考虑页面的载入次序，服务器响应时间，以及网络传输消耗，之后才应当考虑选择器方面的优化”！！！\r\n\r\n## 总结\r\n仔细看完了Scss部分的介绍，关于Compass只是随手翻过，关于网格系统，精灵图等也大致了解过一点，这本书更主要的部分放在了Compass这个框架，而关于框架的掌握，更明智的选择应当是练习而不是看书，因此草草结束了这篇笔记。关于编写高效的CSS代码，还有很长的路要走。';
INSERT INTO shymean_article SET `title` = '《计算机科学导论》读书笔记', `created_at` = 1472991758, `category` = '计算机基础', `tags` = '读书笔记', `content` = '\r\n早在今年三月底从船厂辞职的时候，就买了计算机科学丛书这一系列，但是当时翻阅如同天书一般，草草翻阅了两页，阅后即忘，我想大概计算机专业的同学去拿着一本传热学，气体动力学之类的书也会有这样的感觉。于是当时就决定先放一放，待进入编程的大门之后再回过头来看这一套书（大概有五六本不吧）。现在，我觉得是时候了。\r\n<!--more-->\r\n\r\n## 绪论\r\n\r\n### 计算机模型\r\n数据处理器\r\n计算机可以被看作是一个接受输入数据，处理数据并产生输出数据的黑盒（即使用它的人并不需要知道其内部的工作原理）\r\n\r\n通用图灵机\r\n图灵机模型在数据处理器模型的基础上引入了程序的概念，程序是用来告诉计算机对数据进行处理的指令集合：只要提供了合适的程序，计算机就能进行任何计算\r\n\r\n冯.诺依曼模型\r\n该模型将计算机分成了4个子系统：存储器，算术逻辑单元，控制单元和输入/输出单元\r\n* 存储器用来存放数据和程序\r\n* 算术逻辑单元用来计算逻辑运算\r\n* 控制单元用来控制操作其他3个子系统\r\n* 输入系统从计算机外部接收输入数据和程序，输出系统将计算机对输入数据的处理结果输出到计算机外部\r\n\r\n### 计算机组成\r\n当代计算机由三大部分组成：计算机硬件，数据和计算机软件。\r\n\r\n计算机硬件\r\n当代的计算机硬件基于冯.诺依曼模型，尽管形状千差万别，但是都包含基本的4个子系统\r\n\r\n数据\r\n* 存储数据：常规类型的数据和文件不能直接存储在计算机中，数据是以二进制的形式存储在计算机内部的\r\n* 组织数据： 尽管数据只能以一种形式（位模式）存储在计算机内部，但是在计算机外部却可以表现为不同的形式\r\n\r\n计算机软件\r\n编程指的是在数据实际开始处理之前由操作员或工程师组织一系列计算机指令的过程：\r\n* 程序必须是有序的指令集，每一条指令操作一个或者多个数据项，因此一条指令可以改变他前面指令的作用；\r\n* 引入指令的概念主要是为了程序的重用性，如果每一条任务的程序都是相对独立且和其他程序之间没有任何的公用段，编程是十分困难的\r\n* __程序员不仅应当了解每一条指令的作用，还应该知道怎样将这些指令结合起来完成特定的任务。对于不同的问题，应该以循序渐进的方式来解决问题，接着尽量找到合适的指令来解决问题。__这种按步骤解决问题的方法就是__算法__。\r\n* 计算机科学家研究出利用符号来代表位模式，从使用机器语言编程过渡到使用更接近人类世界的语言来编写程序指令，这就是编程语言的概念。\r\n* 软件工程指结构化程序的设计和编写。\r\n* 操作系统指的是为程序访问计算机部件提供方便的一种管理程序，当然如今的操作系统远不止这些。\r\n\r\n## 数字系统\r\n数字系统定义了如何使用独特的符号来表示一个数字，大体来说可以分为两类：位置化系统（比如十进制...）和非位置化系统（比如罗马数字）。\r\n不同的数字系统中可能使用了不同的符号，这些符号被称为数码，而对应数字系统使用的全部数码被称为数码集。\r\n\r\n### 位置化数字系统\r\n在位置化系统中，数字中的符号所占据的位置决定了其表现的值，常见的位置化数字系统有十进制，二进制，十六进制和八进制\r\n\r\n其他进制转换成十进制：\r\n只需要将数码乘以其在原系统中的位置量(底的n-1次幂)并求和，即可得到在十进制中的数\r\n\r\n十进制转换成其他进制：\r\n* 对于整数部分可采用连除法，将十进制整数部分称为__源__，转换后的整数部分称为__目标__，转换后的数字进制称为__底__，首先创建一个空目标，接着使用底反复除源并得到商和余数，余数插入到目标的__左边__，商变成新的源，直至最后余数为0。\r\n* 对于小数部分可采用连乘法，首先创建一个空目标，然后使用底反复乘以源并得到结果，结果的整数部分插入到目标的右边，而小数部分称为新的源。最后得到结果。\r\n\r\n在进行数字转换的时候，需要注意：__数字转换的结果并不是完全精确的，因此在进行数字转换的时候需要指明允许保留几位小数__。\r\n\r\n### 非位置化数字系统\r\n在计算机系统中最常用的还是位置化数字系统，因此并没有详细介绍。现在想来，汉语中的数字也算是非位置化数字系统吧？比如“二十三”这样的... \r\n\r\n## 数据存储\r\n\r\n### 数据存储\r\n人们希望计算机能够处理多种不同类型的数据：数字计算，文本处理，音频数据，图像及视频等。\r\n然而所有计算机外部的数据类型都采用统一的数据表示法转换后以位模式（二进制）保存在计算机中，当计算机输出数据时再还原回来。\r\n使用__\"位\"__来表示计算机的最小存储单位，一个位的内容存放一个二进制数码。\r\n计算机使用位来存储所有的数据，而无需辨别他们是何种数据类型。\r\n\r\n\r\n### 存储数字\r\n计算机把数字分为整数（不带小数点）和实数（带小数点）。\r\n\r\n#### 整数\r\n整数通常使用定点表示法存储在内存中，字面意义为把小数点固定在最右边（小数点是假设的，并不存储在计算机中）。\r\n整数又分为无符号表示法，符号加绝对值表示法以及二进制补码表示法，用来表示非负数及负数的整数，\r\n\r\n__无符号表示法__\r\n无符号表示法只能用来表示0到2^n-1之间的正整数，其中n表示计算机中被分配用来保存无符号整数的二进制位数。\r\n存储无符号整数十分简单：\r\n* 首先将整数转变成二进制数；\r\n* 如果转变后的二进制位数不足n，使用0填充左侧剩余的位，使它的总位数为0；\r\n* 如果转变后的位数大于n，则会出现__溢出__，即计算机会丢掉最左边的位，只保留右边的n位，这样在重新读取数据的时候，就会发现输出的结果与输入的数据值完全不相同。\r\n\r\n__符号加绝对值表示法__\r\n符号加绝对值表示法将使用同样位数的无符号表发法的数值范围均分为正负两个子范围（具体原因即将第一个位用来存储了符号导致所表示的数值绝对值为0到2^(n-1) -1）。\r\n* 使用第一个位存储整数的符号，0表示正，1表示负，因此该表示法中0有+0和-0两种表示法；\r\n* 后面跟该数值绝对值的无符号表示法，\r\n* 数字的溢出分为了正溢出与负溢出两种情况，可以将能表示的数字范围想象成一个圆环，最小负值的下一个数字是+0,最大整数的下一个数字是-0,这样在数据溢出的情况下，所存储的实际数据是在这个循环圆中对应位置所表示的值。\r\n\r\n__二进制补码表示法__\r\n首先需要明白两种运算：\r\n* 反码：将一个二进制整数取反，即在对应位置上如果为1，则取反码为0；如果为0，则取反码为1；\r\n* 补码：从__右边__复制位，直到遇见第一个1被复制之后，对剩余的位取反码（可以把补码想象成有限制的反码？）；\r\n```\r\n1110110\r\n0001001 //反码\r\n0001010//补码\r\n```\r\n\r\n连续进行两次补码或反码时就可以得到原始数据。\r\n以二进制补码格式存储数字：\r\n* 将整数转变成二进制数字，剩余位使用0补齐；\r\n* 如果该整数是非负数，则将其原样存储；如果是负数，则对该二进制数字采用补码操作并存储；\r\n* 使用第一个位存储整数的符号，0表示正，1表示负（顺序放在最后只是为了表明存储符号的首位不在补码运算中）；\r\n\r\n则读取数字的时候：\r\n* 如果第一位是1，计算机取其补码；如果是最左位是0，计算机不进行操作；\r\n* 将所得值转换为十进制数字\r\n\r\n在补码表示法中，只有一个0（+0，因为只要为非负数，首位符号位则为0），因此可以多保存一个负数。\r\n在二进制补码表示法中，仍然存在正负溢出两种情况，且与符号加绝对值表示法的情况类似。\r\n\r\n#### 浮点数\r\n由于带有很大的整数部分或者很小的小数部分的实数使用定点表示法无法确保精度，因此使用浮点表示法（所谓浮点，即小数点并不是固定在某一个具体的位置）。浮点表示法主要分为三部分组成：符号，位移量和定点数，科学计数法就是使用了浮点数的概念\r\n```\r\n-1234000\r\n-1.234*10^6 //由负号，位移量6和定点数1.234组成\r\n```\r\n\r\n__规范化__\r\n由于小数点是可移动的，也就是说同一个数字，通过修改位移量和定点数，可以有无穷多种表示方法，为了使表示法统一，引入了规范化的概念：小数点左边必须使用__惟一的非零编码__，在二进制中则小数点左边只能为1；小数点右侧的数称为尾数（即带符号的小数部分）。\r\n\r\n__余码系统__\r\n使用余码系统来表示尾数：在余码系统中，负数和非负数都可以作为无符号数来存储，即将表示范围中的(-2^(n-1)~+2^(n-1))所有数都加上一个正整数，把他们统一移动到非负的一边，这个正整数被称为偏移量，大小为(2^(n-1)-1)。\r\n最常见的浮点数标准被单精度和双精度：\r\n* 单精度使用32位来表示浮点数，符号占1位，指数占8位（偏移量为127），尾数使用23位\r\n* 单精度使用64位来表示浮点数，符号占1位，指数占11位（偏移量为1023），尾数使用52位\r\n\r\n__溢出__\r\n浮点数存在上溢和下溢两种情况，试图存储绝对值很小的数会发生下溢，试图存储绝对值很大的数会发生上溢\r\n\r\n__截断错误__\r\n在位数不够的情况下计算机会截断尾数的末尾数字，这会导致比较严重的误差，被称作截断错误。\r\n\r\n### 存储文本\r\n语言集中的字符数量决定了计算机用来存储该语言所必需的位数，不同的位模式集合被设计用来表示文本符号，常见的字符编码有：\r\n* ASCII编码，该代码使用7位来存储字符\r\n* Unicode，该代码使用32为来存储字符，不同的部分被用来表示世界上不同语言的符号\r\n\r\n### 音频图像和视频\r\n音频是随时间变化的实体，计算机采用模拟数据来保存音频。\r\n存储在计算机中的图像使用两种不同的技术：光栅图或者矢量图。\r\n视频由一帧一帧的图像组成，使用与存储图像相同的技术保存视频。\r\n\r\n## 数据运算\r\n运算分为逻辑运算，移位运算和算术运算。\r\n\r\n### 逻辑运算\r\n位层次上的逻辑运算有非，与，或，异或四种情况。其中异或表示”如果输入位有1，则结果为另一位的取反值“。\r\n运用逻辑运算可以将一个指定位的数值置0（也称为复位），即将指定位与0进行“逻辑与”运算，该位为0的数被称作__掩码__，目前接触到的掩码用途貌似就是`子网掩码`了。\r\n```\r\n\t10111101\r\nAND 00001011\r\n=\t00001001//最左边4位全部置0\r\n```\r\n### 移位运算\r\n移位运算可以分为逻辑移位运算和算术移位运算：\r\n* 算术移位运算中，左移一位表示乘以2，右移一位表示除以2；\r\n* 逻辑移位中左移一位，最左位丢失，最右位以0填充，右移一位，最右位丢失，最左位以0填充；\r\n\r\n### 算术运算\r\n算术运算包括加减乘除，适用于整数和浮点数,由于过于枯燥，暂且略过，回头再看。\r\n\r\n## 计算机组成\r\n现代计算机组成主要分为三部分：CPU，主存储器和输入/输出系统。\r\n\r\n### 中央处理器\r\nCPU用于处理数据的运算，又可以分为算术逻辑单元，控制单元，寄存器组和快速存储定位：\r\n* 算术逻辑单元主要对数据进行逻辑，移位和算术运算；\r\n* 寄存器是用来存放临时数据的高速独立的存储单元，CPU的运算离不开大量寄存器的使用\r\n* 控制单元用来控制各个子系统的操作（与冯.诺依曼模型中的类似，但是归于CPU了）\r\n\r\n### 主存储器\r\n主存储器是存储单元的集合，每一个存储单元都有唯一的标识，称为地址。在存储器中存放每个字都需要有相应的标识符，而地址标识符本身也是使用位模式来存储的，也就是说，如果一个计算机有2^n个字的存储空间，则需要n个无符号整数来确定一个存储单元。\r\n主存的类型分为RAM和ROM，其中RAM（随机存取存储器）是贮存的主要组成部分，断电其内容就会消失。\r\n介于寄存器和主存之间还存在高速缓冲存储器，通常，计算机花费80%的时间来读取20%的数据，而告诉缓冲存储器用来存储经常使用的数据，从而加快计算机的存取数据的时间。\r\n\r\n### 输入/输出系统\r\n输入输出使得计算机可以与外界通信，可分为非存储设备（键盘，显示器等）和存储设备（如U盘，光盘等）\r\n\r\n### 子系统的互连\r\nCPU和主存储器之间通常通过主线相连，包括：数据总线，地址总线和控制总线；\r\n输入/输出设备不能直接和CPU相连，因为他们的物理结构不同，速度远远小于CPU的操作速度，因此需要输入/输出控制器来充当中介并把他们连接到总线上，常见的控制器（接口）包括：SCSI，火线，USB和HDMI等\r\n\r\n### 程序执行\r\nCPU利用重复的机器周期来按指定顺序执行程序中的指令，一个简化的机器周期包括：取指令，译码和执行：\r\n* 在取指令阶段，控制单元命令系统将下一条要执行的指令复制到CPU的指令寄存器中，复制结束后，程序计数器加1并指向内存中的下一条指令；\r\n* 当指令置于寄存器中后，该指令将由控制单元负责译码；\r\n* 译码结束后产生一系列可执行的二进制代码，并将该任务命令发送到CPU的某个部件并执行。\r\n\r\n## 计算机网络\r\n网络是一系列可用于通信的设备相互连接构成的，又分为局域网（LAN）和广域网（WAN），然而现在的局域网和广域网基本都是互相连接的，这就是因特网。\r\n\r\n### 协议分层\r\n在因特网中，最重要的概念就是“协议”，协议定义了发送器，接收器以及所有中间设备必须遵守以保证有效通信的规则。当通信变得比较复杂时，可能需要将不同的任务分配到不同的协议层，即__协议分层__的概念。\r\n如今因特网中使用的协议集被称为__TCP/IP__协议，指定了每个协议层之间的逻辑通信。自上向下将协议层分为了应用层，传输层，网络层，数据链路层和物理层。\t\r\n\r\n\r\n在协议层中有两个比较重要的概念，地址和数据包名称：\r\n* 层组之间的逻辑通信，在任何涉及两步校验的通信都需要两个地址，源地址和目标地址：\r\n\t* 在应用层，一般使用名称来定义提供服务的站点；\r\n\t* 在传输层，地址被称为端口号，被用来定义源和目的之间的应用层程序，端口号的作用是通过各个程序的本地地址来辨别多个同时运行的本地程序；\r\n\t* 在网络层，地址在整个因特网范围内是全球化的，因此网络层地址独一无二地定义了该设备与因特网的连接；\r\n\t* 在数据链路层，地址有时被称为MAC地址，是一个本地定义的地址，每一个链路层地址在计算机网络中定义了一个特定的主机或者路由器；\r\n\t* 物理层不需要地址，因为物理层数据交换的单位是位，无法得到地址。\r\n* 数据包...\r\n\r\n### 应用层\r\n应用层用来向用户提供服务，当使用网络时我们需要两个分开的应用程序彼此交互，这里又有__客户机-服务器模式__和__端到端模式__:\r\n* 在客户机-服务器模式中，众多的客户机与同一个服务器通信并获得该服务器提供的服务，服务器进程会一直持续开启，并承担通信集中负荷，对其性能要求十分高。一些传统的服务如：万维网和HTTP(超文本传输协议),FTP(文本传输协议)，SSH(安全外壳协议)和邮件服务等\r\n* 端到端模式也成为P2P（prot to port?），在这种模式下，一台与网络连接的计算机可以在一个时间段提供服务，又可以在另一个时间段接受服务，常见的服务是网络电话。端对端模式大大降低了网络服务的成本，随之而来的是安全问题。\r\n\r\n#### HTTP\r\n万维网（WWW）是具有连接分布在世界各地的文档中信息的存储库，这个存储库中叫做__网页__的文档（真是亲切啊！）分布在全世界并且相关的文档都链接在一起。\r\n客户机的应用程序来访问服务器的网页服务，而提供的服务分布在许多地方，被称为__站点__。\r\n* 客户端的应用程序被称为浏览器，通常由控制器，客户端协议和解释器组成。\r\n* 服务端用来提供和存储网页，每当浏览器的请求达到时，相应的文档页面会被发送到客户端。\r\n每个页面中都包含同站点或不同站点其他页面的链接，且每个页面都具有独立的地址和名称，因此可以独立的检索到（即在浏览器输入对应的地址就可以直接访问到该文件）。\t\r\n作为因特网中的文件，每个网页都需要唯一的标识来将他和其他网页区分开来，定义一个网页需要3个标识符：主机，端口和文件路径，此外还告诉浏览器相应的通信协议。统一资源定位器(URL)是为了把这四个结合起来而设计的，在服务器中默认的端口号为80。\r\n```\r\nprotocol://host:port/path\r\n```\r\n#### FTP\r\n...\r\n\r\n### 传输层\r\n传输层从网络层接收服务并为应用层提供服务，他是TCP/IP协议族的核心协议。\r\n传输层的第一个义务是提供__进程__间的通信，所谓进程是使用传输层服务的应用层实体（即应用层程序），使用__端口号__来区分不同的进程。在定义客户端程序的端口号称为’临时端口号‘（因为客户端程序的寿命相对较短）；定义服务端程序的端口号就不能随机选择了，因为服务端程序需要长时间保持运行，因此服务端程序端口号一般称为’知名端口号‘\r\n\r\n传输层协议最重要的就是UDP和TCP。\r\n#### UDP\r\nUDP即用户数据报协议，是不可靠的无连接传输协议，他是一个极简单而开销最少的协议。\r\n\r\n#### TPC\r\nTCP即传输控制协议，是一个面向连接的可靠协议，它明确地定义了连接设施，数据传输和连接拆卸段以提供面向连接的服务（即同一消息中的所有数据包之间有关联）\r\n\r\n### 网络层\r\n网络层负责源到目的地的消息发送，该层最主要的协议就是网际协议，也就是大名鼎鼎的`IP`，根据版本，现在使用的是IPv4和IPv6\r\n\r\n### 数据链路层\r\n该层是网络中连接起来后可以构成因特网的区域，又分为广域网，局域网等。\r\n\r\n### 物理层\r\n\r\n物理层将数据链路层接收到的位转换成用于传输的电磁信号，然后这些信号将被传送至传输媒介\r\n\r\n## 操作系统\r\n计算机系统由硬件和软件组成，其中，软件又分为操作系统和应用程序两种：\r\n* 应用程序是使用计算机硬件解决用户的问题\r\n* 操作系统使用户更有效地使用硬件，更容易地获取资源\r\n\r\n操作系统一般由四部分组成：用户界面，内存管理器，进程管理器和文件管理器\r\n### 用户界面\r\n用户界面指用来接收用户（或程序）的输入并向操作系统解释这些请求的程序，分为图形化界面(windows)和命令行界面(unix,linux)。\r\n\r\n### 内存管理器\r\n由于程序运行的内存是有限的，在多道程序下（即在同一时刻装入多个程序并同时执行），则必须考虑内存分配的问题。\r\n内存分配主要包括分区调度，分页调度，请求分页调度，请求分段调度和请求分页分段调度这几种。其中请求分页调度和请求分段调度意味着当程序运行时，一部分程序驻留在内存中，而一部分程序则放在硬盘上，这种技术叫做\"虚拟内存\"。\r\n\r\n### 进程管理器\r\n首先需要理清程序，作业和进程的概念：\r\n* 程序是一组稳定的指令，存放在磁盘上，可能会成为作业；\r\n* 一个程序被选中执行，到其运行结束并再次成为一个程序的过程中，该程序被称为\"作业\"；需要明白的是在整个过程中，作业可能被执行也可能不被执行\r\n* 进程是一个运行中的作业，该程序开始运行但未结束，换句话说：进程是一个驻留在内存中运行的作业。一个进程可以处于运行状态或者等待CPU调用状态\r\n\r\n进程管理器使用作业调度器和进程调度器来改变程序的状态：\r\n* 作业调度器将一个作业从保持状态转入就绪状态，或者从运行状态转换为终止状态\r\n* 进程调度器将一个进程在就绪-运行-等待状态中切换\r\n\r\n所有的进程管理思想都是使得拥有不同资源的不同进程同步，遇见的两个问题有死锁和饿死：\r\n* 死锁指操作系统没有对进程的资源进行限制，导致两个进程之间所依赖的资源互相被占据且无法被释放的情况发生\r\n* 饿死指操作系统对进程的资源有太多限制，导致进程无法获取对应资源\r\n\r\n### 设备管理器\r\n设备管理器负责管理输入/输出设备，让这些设备使用起来更有效\r\n\r\n### 文件管理器\r\n文件管理器用来控制对文件的访问\r\n\r\n## 算法\r\n算法是一种逐步解决问题或完成任务的方法。更准确的定义是：一组明确步骤的有序集合，产生结果并在有限的时间内终止。\r\n计算机专家为算法定义了三种结构：顺序，循环和选择。已经证明了其他结构都是不必要的（这都能证明！！）\r\n有一系列算法在计算机科学中应用相当普遍，被称为“基本算法”，包括求和，乘积，求极值，排序和查找。\r\n### 排序\r\n排序指根据数据的值对他们进行排列，基本的排序算法有：选择排序法，冒泡排序法和插入排序法。\r\n```\r\nvar arr = [];\r\nvar num = 10;\r\nfor (var i = 0; i < num; ++i){\r\n    arr.push(Math.round(Math.random()*100));\r\n}\r\nconsole.log(arr);\r\n\r\n// 选择排序\r\n// 每次从未排序子列中挑选最小与该子列第一个元素交换位置\r\nfor (var i = 0; i < num; ++i){\r\n    var min = i;\r\n    for (var j = i + 1; j < num; ++j){\r\n        if (arr[min] > arr[j]){\r\n            min = j;\r\n        }\r\n    }\r\n    var temp = arr[i];\r\n    arr[i] = arr[min];\r\n    arr[min] = temp;\r\n}\r\n\r\n// 冒泡排序\r\n// 把较大的数冒泡最后，\r\nfor (var i = 0; i < num; ++i){\r\n    for (var j = 0; j < num-i; ++j){\r\n        if (arr[j+1] < arr[j]){\r\n            var temp = arr[j+1];\r\n            arr[j+1] = arr[j];\r\n            arr[j] = temp;\r\n        }\r\n    }\r\n}\r\n// 插入排序\r\n// 把未排序子列的第一个数插入到已排序子列的正确位置\r\nvar sortArr = [];\r\nsortArr.push(arr[0]);\r\nfor (var i = 1; i < num; ++i){\r\n    for (var j = 0; j < i; ++j){\r\n        if (arr[i] <= sortArr[0]){\r\n            sortArr.unshift(arr[i]);\r\n            break;\r\n        }\r\n        if (arr[i] < sortArr[j]){\r\n            sortArr.splice(j-1,0,arr[i]);\r\n            break;\r\n        }\r\n\r\n        if (arr[i] >= sortArr[sortArr.length-1]){\r\n            sortArr.push(arr[i]);\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nconsole.log(arr);\r\n```\r\n### 查找\r\n查找是另外一种十分常见的基本算法，用于在列表中确定目标所在位置的算法，常见的有顺序查找(无序列表)和折半查找(有序列表)法。\r\n\r\n## 数据结构\r\n一个数据结构表示有关系的数据的集合，基础的数据结构包括：数组，记录（关联数组）和链表。\r\n### 数组\r\n数组是元素的顺序集合，通常这些元素具有相同的数据类型（但是在部分编程语言如JS中数组各元素可以是不同的类型），数组元素通过索引独立的给出了地址并在内存中连续存储，通过数组名称使用`[]`，带上索引值便可以访问数组中的任意元素。\r\n在内存中如何存储每个数组元素取决于计算机：大部分计算机都采用\"行主序存储\"，但是计算机也可以使用\"列主序存储\"。\r\n在数组中检索一个元素十分方便：只需要通过索引值一条指令就可以做到；但是在数组中插入或删除元素则变得比较困难，需要整体移动改动位置之后的数组元素。\r\n因此，当需要进行的插入和删除数组较少，而需要大量的查找和检索操作时，数组是比较合适的数据结构。\r\n\r\n### 记录\r\n记录是一组相互关联元素的集合，他们可能是不同的类型，但是整个记录有一个名称，记录中的每个元素称为域，域能够被赋值，也能被选择和操作。\r\n记录中的每个元素都与一个对象关联，在大部分语言中，在该对象上可以通过`.`运算符来访问\r\n\r\n### 链表\r\n链表是一个数据的集合，其中每个元素都包含了数据(可用信息)和链(下一个元素的地址)，习惯上将链表上的元素称为“节点”。\r\n链表和数组的区别在于元素之间的连接方式不同：\r\n* 数组通过索引值计算对应元素的地址偏移量，便可以获取目标元素，这一切的基础建立在“数组在内存中是连续存储”的基础上\r\n* 链表通过一个额外的属性保存下一个节点的地址，从而获取目标元素，这样就可以在不连续的内存中存放一个链表，而要做的就是保存下一个节点的地址（以此类推）\r\n\r\n由于存储在不连续的内存中，检索链表中的元素必须从从节点开始，并逐个遍历节点以获取下一个节点的地址，直至找到对应的元素为止；而这样的好处在于向链表中插入或删除节点就变的十分方便，只需要找到待操作为位置，并改变其前后节点的链指向即可。\r\n如果需要大量的插入和删除，那么链表十分合适。但是在链表中查找元素比在数组中查找要慢\r\n\r\n## 抽象数据类型\r\n为了处理数据，我们需要定义数据类型和数据上能够进行的操作，这就构成了抽象数据类型（ADT）的基础。定义并实现ADT之后，用户就可以直接使用相应的操作而不需要了解实现的细节。一个抽象数据类型包括：\r\n* 数据的定义\r\n* 操作的定义\r\n* 封装数据和操作\r\n\r\n常见的抽象数据类型有：栈，队，广义线性表，树和图等。\r\n### 栈\r\n栈是一种后进先出的结构，一般可以使用数组实现栈，栈包含的基本操作有：初始化，入栈，出栈和清空。\r\n栈的应用可以分为：倒转数据，配对数据，数据延迟使用和回溯步骤\r\n\r\n### 队列\r\n队列是一种先进先出的结构，队列包含的基本操作有：初始化，入列，出列和清空。\r\n队列在操作系统和网络中大量应用，在其他领域的应用也是数不胜数。\r\n\r\n### 广义线性表\r\n栈和队列都是限制性线性表，因为其插入和删除都被限制在指定位置进行；广义线性表是一个插入和删除等操作可以在任意位置进行的抽象数据结构。广义线性表包含的操作有：初始化，插入，删除，检索，遍历和清空，使用链表来实现广义线性表是一个不错的主意。\r\n\r\n### 树\r\n树包括一组有限的元素，称为节点；同时包含一组有限的有向线段，用来连接节点，称为弧；没有进入弧的那个节点，称为树的根。各个节点之间的关系可以用双亲，兄弟和子孙这三种关系来表示。\r\n树结构中有一种特殊的树：二叉树。二叉树是其任意节点所含有的子树个数都不超过两个的树。二叉树包含的基本操作有：初始化，插入，删除，检索，清空和遍历。现在只讨论遍历。\r\n二叉树遍历需要按照预定的顺序处理每一个界定啊且仅处理一次，两种常见的遍历次序是：深度优先和广度优先：\r\n* 深度优先根据起点的不同又分为了前序遍历，中序遍历和后续遍历\r\n\t* 前序遍历中：根首先被访问，然后是左子树，最后是右子树\r\n\t* 中序遍历中：先处理左子树，然后是根，最后是右子树\r\n\t* 后序遍历中，先处理右子树，然后是跟，最后是左子树\r\n在广度优先的遍历中，先处理节点的子节点，然后进行下一层。\r\n\r\n## 编程语言\r\n计算机唯一识别的是机器语言，为了简化编程，出现了使用符号或助记符的指令和地址代替二进制编码的汇编语言。到后面，为了提高编程效率以及从关注计算机转到关注要解决的问题，出现了高级编程语言。\r\n高级编程语言旨在帮助程序员摆脱汇编语言的繁琐细节。然而与汇编语言相同，他们都必须转化成机器语言，这个从高级语言编写的源程序转化为机器语言组成的目标程序的过程被称为解释或编译。\r\n### 编译和解释\r\n#### 编译\r\n编译程序通常把每个源程序翻译成目标程序。这样，程序在运行的时候就会非常迅速。\r\n#### 翻译\r\n解释是指把源程序中的每一行翻译成目标程序中相应的行，并执行他们的过程。由于程序在执行的时候才进行解释，因此运行效率要低于编译型语言\r\n\r\n### 模式与通性\r\n如今的计算机语言按照他们解决问题的方式分为了不同的类型，其中，模式是计算机语言看待要解决问题的一种方式，因此，计算机语言可分为四种模式：过程式，面向对象，函数和声明式。\r\n\r\n尽管计算机语言的模式不同，各语言之间仍有很多相似的地方，包括：标识符，数据类型，变量，字面值，常量，输入和输出，表达式，语句，函数等概念和实现。\r\n\r\n## 软件工程\r\n软件工程指利用合理的工程方法和原则来获得在真实机器上工作的可靠软件。\r\n软件生命周期是软件工程中的一个基础概念：软件在开发完成之后，在使用和修改的过程中反复进行并持续到软件过时的周期。\r\n软件的开发过程主要可分为：瀑布模型和增量模型：\r\n* 在瀑布模型中，开发过程只能向一个方向流动，这意味着前一个阶段不结束，则后一个阶段不能开始\r\n* 在增量模型中，首先完成整个系统的简单版本，然后再该版本上添加功能。\r\n\r\n软件的开发过程分为了：分析，设计，实现和测试四个步骤，每个步骤都很重要！\r\n\r\n## 文件结构\r\n文件是数据记录的集合，文件一般存储在辅助存储设备或二级存储设备中。在设计文件中，关键问题在于如何从文件中检索信息：存储方法决定了如何检索记录。\r\n* 如果需要按顺序地存取记录，则使用顺序文件结构\r\n* 如果想要存取某一特定的记录而不检索之前的所有记录，则可以使用随机存取的文件结构：索引文件和散列文件\r\n\r\n## 数据库\r\n数据的存储传统上是使用单独的没有关联的文件（平面文件），而数据库是一个组织内被应用程序使用的逻辑相一致的关联数据的集合。与平面文件系统相比，数据看的冗余较少，数据的一致性很高，存取效率和数据的完整性，以及系统的安全性也更高\r\n### 数据库管理系统\r\n常说的数据库，实际上是指数据库管理系统，是用来定义，创建和维护数据库的一种工具。\r\n#### 数据库体系\r\n数据库管理系统规定了三层体系结构：内层，概念层和外层：\r\n* 内层决定了数据在存储设备中的实际位置\r\n* 概念层定义数据的逻辑视图，数据库管理系统的主要功能（如查询）都在该层进行，概念层是中介层，使用户不必与内层打交道\r\n* 外层直接与用户交互，将来自概念层的数据转化为用户所熟悉的格式和视图。\r\n\r\n#### 数据库模型\r\n曾使用了三种数据库模型：层次模型，网状模型和关系模型。其中前两种模型已经过时。在关系型数据库中，数据是通过关系的集合来表示的，关系就是二维表（需要注意的是数据的物理存储与数据的逻辑组织方式毫无关系），每一种关系都有唯一的名称(表名)，关系中的每一列都称为属性(字段)，而关系中的每一行都称为元组。\r\n\r\n数据库最常用的操作就是增删查改（CURD）\r\n\r\n## 结语\r\n花了大概近两个月的时间，断断续续的读完了这本《计算机科学导论》（实际上后面还有数据压缩和安全等章节并没有全部看完），感触颇深，对整个计算机知识体系有了一个大概的了解（虽然还很模糊），所以打算再另起一文，思考一下现在自己的状态和未来的学习路线。总之，“长路漫漫，一往无前，终得拨开云雾见青天”！\r\nPS：最后我并没有写那篇文章，太矫情了，所以...\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '《正则指引》读书笔记', `created_at` = 1481114575, `category` = 'JavaScript', `tags` = '读书笔记, 正则', `content` = '\r\n爬虫真的非常有意思。为了更高效的处理获取的数据，开始正儿八经的学习正则表达式。\r\n<!--more-->\r\n## 字符组\r\n字符组就是一组使用`[]`中括号包围的字符集合，表示“在同一个位置可能出现的各种字符”。\r\n```\r\n// 这本书前面的章节都是使用Python来书写测试代码的\r\n// 这篇笔记使用下面这段JS代码来测试正则表达式\r\nvar str = \'cat\'\r\nvar re = /[abc]/g;\r\nvar result = null;\r\nwhile(result = re.exec(str)){\r\n\tconsole.log(result[0]); // c,a\r\n}\r\n```\r\n\r\n### 范围表示法\r\n字符组中普通字符的排列顺序并不影响字符组的功能（因为只是在该位置上匹配一个字符），但是为了简化表达式，对于多个连续字符的处理可以使用__`-`范围表示法__，所谓的连续字符，实际上是根据字符的ASCII编码来决定的，在使用范围表示法中，编码小的字符在前，编码大的字符在后：\r\n```\r\nvar re = /[0-9]/;\r\nvar re = /[a-zA-Z]/; // 在一个字符组中可以使用多个范围表示法，并且这些表示法的顺序无关\r\n```\r\n\r\n### 元字符与转义\r\n正则表达式所使用的一些字符，比如`^`,`$`,`-`等（这些字符被称为元字符）在字符组中不能直接被使用，而是要使用转义符 \"\\\"进行转义，此外\"\\\"也是元字符，因此如果需要匹配反斜杠本身，则也需要进行转义（就如现在我在写markdown，如果想要达到正确的转义符代码效果`\\\\`，则必须使用双斜杠...）。\r\n字符组范围表示法元字符`-`如果靠近`[`（或者是下面的排除型字符组的`^`）则会被当作是普通字符，而在其他位置则会被当作元字符；其他元字符都必须通过转义才能被当作普通字符。\r\n```\r\nvar re = /[-ac]/; // 表示匹配字符 -, a, c\r\n\r\n```\r\n\r\n### 排除型字符组\r\n在某些时候需要匹配一个不处于字符组中的字符，这时候就必须使用到排除行字符组`[^]`。\r\n```\r\nvar re = /[^0-9]/; // 匹配非数字的字符\r\n```\r\n作者在这里指出，需要注意：“在当前位置，匹配一个没有列出的字符”和“在当前位置，不要匹配列出的字符”这两种说法实际上是不一样的。排除型字符组的正确含义是前者，也就是实际上必须在当前位置匹配一个字符，且该字符不属于字符组；而后者暗示可以不匹配任何字符。\r\n\r\n### 字符组简化标识符\r\n正则表达式提供了常用的字符组的简写标识符：\r\n* `\\d`数字(digit) 和 \\D非数组\r\n* `\\w`字符(word) 和 \\W非字符\r\n* `\\s`空白(space) 和 \\S非空白符\r\n\r\n### 通用字符\r\n元字符`.`可以用来匹配除换行符外的全部字符（牢记这点：`.`不能匹配换行符！）。如果需要匹配真正意义上的“全部字符”，则可以使用[\\w\\W]来表示。\r\n\r\n## 量词\r\n字符组用来匹配单个字符，而量词则用来匹配多个字符，使用`{}`来表示某个数量范围内的量词。\r\n```\r\nvar re = /\\d{3}/; // 匹配3个数字\r\nvar re = /\\d{1,3}/; // 量词也可以用来表示某个数量范围的不确定长度\r\n```\r\n需要注意的是表示范围的量词中，逗号与前后的数字之间不能有空格。量词一般有固定的长度或者明确的范围下限，如果下限为0则可以直接省略（在某些语言中不支持）；量词的范围上限可以是不固定的。\r\n\r\n### 常用量词标识符\r\n`{m,n}`是通用形式的量词，此外还有三个常用量词元字符（在大多数情况下只需要表示这三种意思）:\r\n* `+`表示`{1,}`一个或多个\r\n* `*`表示`{0,}`0个或多个\r\n* `?`表示`{0,1}`0个或一个\r\n\r\n```\r\nvar re =/<[^>]+>.*<[^<]+>/g; // 匹配一个HTML闭合标签，当然现在这里并没有考虑标签名前后一致以及标签嵌套\r\n```\r\n\r\n### 贪婪匹配\r\n通用字符`.`与量词组合就可以匹配任意长度的字符，但是事实上会存在一些问题\r\n```\r\nvar re =/\".*\"/g; // 匹配一个由双引号包围的字符串\r\nre.exec(\'\"title\"abcef\'); // \"title\"\r\nre.exec(\'\"title\"abc\"ef\'); // \"title\"abc\"\r\n```\r\n产生上述结果的原因是：`.*`在匹配过程结束之前，每遇到一个字符,都\"可以\"进行匹配，但是到底是匹配这个字符，还是忽略它，这将取决于`*`量词后面的`\"`字符来决定。\r\n默认`.*`属于\"匹配优先量词\"（这是作者的叫法，在很多地方被称为贪婪匹配），下面是一个关于`\"title\"abcef`贪婪匹配的假想过程：\r\n* 首先逐个匹配字符串中的字符并将字符依次记录（因为在匹配过程中并不确定是否保留该字符，所以优先线记录该字符），即使是遇见了双引号`\"`，但此时仍然处于`.*`的匹配过程中，程序并不知道下一个字符是`\"`，所以会继续匹配后面的字符并记录。\r\n* 至字符串（或换行符，因为`.`不能匹配换行符）末尾（表示`.*`匹配过程已经结束，接下来应当匹配`*`量词后面的字符，这里也就是双引号`\"`），发现“哦，后面原来是要匹配双引号啊”。\r\n* 但是现在所记录的字符串最后（可能）并不是双引号，\"不满足要求啊我要反悔\"，因此正则表达式就开始从记录的最后往回查询（这里跟前面的依次记录不同，现在知道要查询的字符是双引号`\"`了），这个过程被称为\"回溯\"，然后在记录中寻找`\"`，当找到倒数第一个目标字符`\"`，嗯，就是你了，最后舍弃后面的字符，返回正确的匹配结果（所以这个匹配结果就尽可能多的包含了`\"`，返回的字符串也就会比较长）。\r\n\r\n书中的描述是会回溯到倒数第一个双引号之前，以便让正则表达式`.*`后的`\"`可以匹配到`\"`，大概意思应该也是差不多的吧。\r\n\r\n因此，如果需要精确的匹配一个只由双引号围成的字符串，则最好不要使用通配字符:\r\n```\r\nvar re = /\"[^\"]\"/;\r\n```\r\n\r\n### 非贪婪匹配\r\n上面阐述贪婪匹配的原理，但是在某些时候我们更希望获取最短的匹配结果，比如一个单层闭合的的div标签（在HTML文档中存在无数个嵌套的div标签）。所幸还有另外一种非贪婪匹配（作者称为惰性匹配）的量词类型`.*?`。\r\n贪婪匹配的原理是，遇见一个`.`能匹配的字符就优先进行匹配记录，最后再反悔回溯匹配到量词后面的那个字符。\r\n而非贪婪匹配的原理恰好相反：遇见一个`.`能匹配的字符就优先进行忽略，并直接匹配`?`后面的那个字符，如果匹配不成功则将前面的字符记录并尝试匹配下一个字符，依次进行（好像一步一步地探地雷，生命只有一次，没有后悔药可以吃），如果在某次忽略并对`?`后面的那个字符匹配成功之后，则直接返回记录的字符串，整个匹配过程到此结束（因此非贪婪匹配的字符串会尽可能短）。\r\n```\r\nvar str = \'<div>head</div><div>body</div>\';\r\n// 由于html文档中可能出现大量的换行，因此最好不要直接使用通配符进行匹配\r\nvar re =/<div>[\\w\\W]*?<\\/div>/g; // \"<div>head</div>\"\r\nvar re =/<div>[\\w\\W]*<\\/div>/g; // \"<div>head</div><div>body</div>\"\r\n```\r\n由于非贪婪匹配必须兼顾他所限定的字符与之后的字符，因此效率相对于贪婪匹配会更低，如果字符串很长，则速度差异会更加明显（这里理解的并不是很透彻）。\r\n\r\n## 括号\r\n\r\n### 分组\r\n量词不仅可以用来表示字符的数量，也可以用来表示表达式的数量，使用`()`来定义一个表达式（通常被称为正则表达式的子表达式），子表达式作为一个整体参与匹配\r\n。\r\n在使用正则表达式时经常会遇到并没有直接相连，但确实存在联系的部分，分组可以把这些概念上相关的部分“归拢”到一起，以免割裂。作者在这里列举了一个URL的例子：\r\n```\r\n// 目的是匹配/moudle/controller_action.php这样的路径\r\n// 规则是/moudle必须出现，而方法名可以省略或控制器与方法名可同时省略\r\n// 难点在于虽然有些元素不一定出现，但是不一定出现的元素之间是有关联的，要么同时出现，要么同时不出现\r\n\r\nvar re = /\\/[a-z]+(\\/[a-z]+(_[a-z])?\\.php)?/g;\r\n```\r\n关于正则表达式，一定要明白它不过是按顺序匹配相应关系的字符串，因此书写正则表达式之前，应当首先理清所需要的规则，以及各依赖元素之间的关联，思路清晰了，写起来肯定务必顺畅！\r\n\r\n### 多选结构\r\n可以在括号内以`|`竖线分隔开多个子表达式，在匹配时，只要其中某个表达式能够匹配，整个多选结构就匹配成功\r\n```\r\nvar re = /([0-9]|[1][0-9]|[2][0-5])/; // 匹配0-25之间的数字\r\n```\r\n实际上也可以不在括号中使用分割符`|`，括号的真正作用是用来限定多选结构的\"范围\"，如果没有括号，则相当于把整个表达式当作一个多选结构。\r\n多选结构看起来与字符组十分相似，但是也有很多区别：可以使用排除型字符组来表示“无法由某几个字符匹配的字符”，而多选结构并没有类似的结构，即不存在\"无法由某几个表达式匹配的字符串\"\r\n\r\n### 捕获分组\r\n使用括号之后，正则表达式会保存每个分组真正匹配的文本（JS是保存在一个数组中）。因为\"捕获\"了文本，所以这种功能叫做\"捕获分组\"。\r\n被捕获的分组保存在数组中，那么每个分组的索引是什么呢（因为可能存在分组嵌套的情况）？无论括号如何嵌套，分组的编号都是根据开括号从左向右出现的顺序来计数的。\r\n```\r\nvar str = \'1-4\';\r\nvar re = /([0-3])-([4-5])/;\r\nre.exec(str); // [\'1-4\',\'1\',\'4\'] 索引0为匹配到的完整表达式\r\n```\r\n利用捕获，可以很轻松地找到某个规律字符串下的具体信息，而不必再单独为该信息重新编写正则表达式。\r\n此外，当为分组使用量词的时候，捕获到的值是最后一次匹配到的子表达式的结果，而具体的细节是每重复出现一次，就要重新更新一次捕获的分组：\r\n```\r\nvar str = \'2010\';\r\nvar re = /(\\d){3}/; // res[1] == 1;\r\n```\r\n### 反向引用\r\n前面提到的引用分组，能捕获某个分组内的子表达式匹配的文本，但是捕获都是在匹配完成之后进行的，怎么匹配一个HTML闭合标签呢？实际上也可以在正则表达式匹配过程中使用引用，这种功能被称为“反向引用”。\r\n反向引用允许在正则表达式内部引用之前的捕获分组匹配的文本（即表达式左侧的分组），使用`\\num`来表示一个反向引用，其中num是对应分组的编号。使用反向引用可以很方便地使用反向引用来建立前后联系\r\n```\r\nvar re = /([a-z])\\1/g; // 匹配两个连续相同的字符\r\nvar re = /<([a-z]+)(\\s[^>])?>[\\s\\S]*?<\\/\\1>/g; // 匹配一个闭合标签\r\n```\r\n需要注意的是反向引用是由前面的捕获分组所匹配的__具体文本__，而不是那个子表达式。此外还需要注意的是由于`\\\\`也是转义符的标识，加之如果分组多余9个则存在二义性(`\\11`是第一个分组后跟字符1还是第11个分组？)，不过一般在表达式中出现数十个分组是比较少见的情形。\r\n解决这个问题可以使用类似于`?P<name>`的命名方式为分组命名，但是并不是所有语言的正则都支持（比如JS就不支持）\r\n\r\n### 非捕获分组\r\n默认只要使用的小括号，就会捕获相应的分组，如果实际上并不需要获取相应的子表达式，则为了提高性能可以显式地声明非捕获分组。\r\n非捕获分组使用`(?:)`来进行声明，他只能限定量词和都多选结构的作用范围，不捕获任何文本，并且在统计捕获分组的标号时，非捕获分组会被忽略掉。\r\n```\r\nvar str = \'2016-12\';\r\nvar re = /(?:\\d{4})-(0[1-9]|1[0-2])/g; // res[1] = 12;\r\n```\r\n\r\n## 断言\r\n正则表达式中的大多数结构匹配的文本都会出现在最终的匹配结果中，但是有些结果只是用来判断某个位置左/右侧的文本是否符合要求，这种结构被称为\"断言\"。\r\n\r\n### 单词边界\r\n某些单词可能是其他单词的子字符串（比如java和javascript），在子希望匹配具体单词而非某个子字符串时，单词边界`\\b`十分有用\r\n```\r\nvar re = /\\d\\w+\\b/; // 匹配文本中全部单词，当然这里只能是\\w字符能表示的单词\r\n```\r\n\r\n### 行起始/结束\r\n匹配某个位置的元素叫做“锚点”，用来定位到某个位置，最常见的锚点就是`^`和`$`，用来表示字符串的开始位置和结束位置\r\n* `^`用来表示单行匹配模式下的字符串起始位置或者多行匹配模式下每一行的起始位置;如果不论多少行都只想匹配第一行的起始位置则使用`\\A`（貌似JS下也没有效果）\r\n* `$`通常匹配整个字符串的结束为止\r\n\r\n### 环视\r\n有时候需要在某个位置向左或者向右看，要求必须出现或者不能出现某些字符，这种需求在正则表达式中十分有用，对于这种需求正则表达式提供了\"环视\"（更常见的叫法叫做“向前/后捕获”）。\r\n`(?!)`就是“向后环视”，真正需要被观察的表达式位于`!`之后，这个子表达式表示当前位置之后，不允许存在这个子表达式能够匹配的字符，从而限定匹配前面的字符或分组，根据正则表达式从左向右的匹配顺序，`?!`也被称为“否定顺序环视”。\r\n而如果需要限定当前位置之后必须匹配环视子表达式，则使用`(?=)`来声明一个“肯定顺序环视”。\r\n```\r\nvar str = \'xabacy\'\r\nvar re = /[a-z]a(?!b)/g; // 表示匹配字符[a-z]a且其后不为字符b，结果为ba\r\nvar re = /[a-z]a(?=b)/g; // 表示匹配字符[a-z]a且其后为字符b，结果为xa\r\n```\r\n\r\n既然存在\"向后环视\"，想必也存在“向前环视”。在大部分语言的正则中，使用`(?<!)`来声明“否定逆序环视”，表示在当前位置之前不允许出现环视子表达式所能匹配的内容;使用`(?<=)`来声明\"肯定逆序环视\"。然而令人悲伤的是：JS并不指出逆序环视，Ruby也是如此。\r\n实际上，可以使用分组来代替肯定逆序环视，但是关于否定逆序环视，并没有比较好的解决办法。\r\n\r\n最后，需要注意的是最后的匹配结果中不会包含环视子表达式所匹配的内容。所以在环视匹配之后会继续从表达式前面的那个位置继续向后匹配\r\n```\r\nvar str = \"12345\";\r\nvar re = /\\d(?=(\\d{3})+)/g; // 结果是 1, 2\r\n```\r\n环视的一个重要作用是：即可以集中关注某个部分，添加全局性的限制，又不会干扰其他部分的匹配。\r\n环视的另一个作用是：提取数据时杜绝错误的匹配，一般来说，只要是提取有长度特征的数据，都需要用到环视。\r\n\r\n## 匹配模式\r\n匹配模式是指匹配时使用的规则，设定特定的规则，可能会改变对正则表达式的识别，常见的模式包括四种：不区分大小写模式，单行模式，多行模式和注释模式。\r\n一般有两种方式来指定匹配模式：模式修饰符指定和预定义常量（gim）。但是JS中只支持预定义常量指定匹配模式。\r\n\r\n### 不区分大小写\r\n一般用来匹配只关系字母含义而不在乎具体的大小写的情形。不区分大小写模式对应的模式修饰符是`i`\r\n\r\n### 单行模式\r\n前面起到，通用字符`.`可以匹配除`\\n`换行符之外的任意字符，因此最多匹配到单行行尾，但有时候需要匹配行尾的`\\n`，于是可以声明单行模式，单行模式对应的模式修饰符是`s`，主要用来改变`.`的匹配规则。\r\n\r\n### 多行模式\r\n实际上单行模式与多行模式没有任何关系。多行模式影响的是`^`和`$`的匹配规则：在默认模式下，他们匹配的是整个字符串的起始位置和结束位置；在多行模式下，他们匹配的是字符串内部某一行文本的起始位置和结束位置。\r\n多行模式对应的模式修饰符是`m`。\r\n\r\n### 注释模式\r\n如果正则表达式非常复杂，则可能会需要在其中添加注释（一脸懵比）\r\n\r\n## 结语\r\n至此第一部分到此结束，应当停下来写几个爬虫练习一番，然后再继续阅读。\r\n';
INSERT INTO shymean_article SET `title` = '使用BEM声明CSS样式名', `created_at` = 1486649070, `category` = 'CSS', `tags` = 'BEM, 代码格式', `content` = '\r\n\r\n折腾`CSS`类名已经很长一段时间了，也得到了一些教训和经验。维护`CSS`有几个比较困难的问题：\r\n* 默认全局命名空间，样式冲突十分常见\r\n* 混乱的样式重用或选择器的滥用，导致改动牵一发而动全身\r\n* 修改样式表的同时可能会改动页面结构，而且往往不只一个页面\r\n\r\n之前的关注点是通过选择器嵌套和样式复用来决定样式名，由于过分考虑样式的复用，又没有进行正确的限制，样式耦合十分严重。最后回过头一想，如果是使用类名来决定选择器的嵌套和样式重用，情形应该会怎么样呢？恰好之前也了解了一点`BEM`的东西，这篇文章是我关于`BEM`的思考和尝试。\r\n\r\n<!--more-->\r\n\r\n参考文档：\r\n* [BEM的定义](http://www.w3cplus.com/css/bem-definitions.html)\r\n* [网易NEC前端规范](http://nec.netease.com/standard/css-practice.html)\r\n* [WeUI](https://weui.io/#/)，微信前端UI框架，就是使用`BEM`来管理命名的,可以用来参考\r\n* [BEM常见的10个疑问](https://www.smashingmagazine.com/2016/06/battling-bem-extended-edition-common-problems-and-how-to-avoid-them/)，解答了关于`BEM`命名的疑惑\r\n\r\n\r\n## 理解BEM\r\n在我的项目中，我使用`_`声明元素，使用`-`声明修饰符，连词之间使用驼峰，这个类名可能会有些“三不像”，但是只要明确了他们的含义并一直保持，跟这种命名方式带来的便利比起来，看起来丑陋的名字也就无关紧要了。\r\n\r\n### 块和元素\r\n选择器并不需要完整反映页面结构的嵌套，而应该尽量精简。`BEM`尽管看起来是根据元素的嵌套来进行命名的，但实际上只有两层结构：块名和块下面的元素：\r\n* 一个块是一个独立的区域，就像页面的一块“积木”，一个块既可以是简单的也可以包含其他的块。\r\n* 元素是块的一部分，具有某种功能或位置含义。元素是依赖上下文的：它们只有处于他们应该属于的组件的上下文中时才是有意义的。\r\n\r\n也就是说，没必要将块下面的每个标签都定义为元素（甚至没有必要为所有的标签都使用`BEM`命名），有的标签尽管出现在块的内部，但可以看作一个独立的组件或颗粒类，不需要使用`_`进行命名。最重要的是，不能出现`B_E_E`这样的类名，遇见这种情况，将元素转换成组件是更好的选择。\r\n\r\n#### 块的独立性\r\n为了详细的阐述我的理解，不厚道地把[官网](https://en.bem.info/methodology/key-concepts/)上的图拿过来了。\r\n![bemDemo](/uploads/bemDemo.png)\r\n单单只考虑这张图的话，以独立的单词表示`块`，以`_`连接块和组成这个块的元素，可以采用下面的类名和页面结构：\r\n```\r\n<div class=\"head\">\r\n    <ul class=\"menu\">\r\n        <li class=\"menu_item\"></li>\r\n        <li class=\"menu_item\"></li>\r\n        <li class=\"menu_item\"></li>\r\n        <li class=\"menu_item\"></li>\r\n    </ul>\r\n    <div class=\"head_left\">\r\n        <div class=\"logo\"></div>\r\n    </div>\r\n    <div class=\"head_main\">\r\n        <form action=\"\" class=\"search\">\r\n            <input type=\"text\" class=\"search_input\">\r\n            <button class=\"search_submit\" type=\"submit\"></button>\r\n        </form>\r\n    </div>\r\n    <div class=\"head_right\">\r\n        <form action=\"\" class=\"auth\">\r\n            <div class=\"auth_group\">\r\n                <input type=\"text\" class=\"auth_input\">\r\n            </div>\r\n            <div class=\"auth_group\">\r\n                <input type=\"text\" class=\"auth_input\">\r\n            </div>\r\n            <div class=\"auth_group\">\r\n                <input type=\"text\" class=\"auth_button\">\r\n            </div>\r\n        </form>\r\n    </div>\r\n</div>\r\n```\r\n样式表就应该为\r\n```\r\n.head{\r\n    &_left {}\r\n    &_main {}\r\n    &_right {}\r\n}\r\n.menu {\r\n    &_item {}\r\n}\r\n.search {\r\n    &_input {}\r\n    &_submit {}\r\n}\r\n.auth {\r\n    &_group{}\r\n    &_input {}\r\n    &_submit {}\r\n}\r\n```\r\n\r\n使用`BEM`，需要理解的是，__每个块之间相互是独立的__。\r\n块中可以包含其他的块，每个块之间相互是独立的，块只决定了他包含的元素的样式（实际上样式表中，元素是不必嵌套在块中，这么做主要是为了可以使用`&`快速构建样式表）。\r\n\r\n块的独立性的另一个含义是：在样式表中，声明块的前面不能有其他块的命名空间的限制，也就是说，块放在页面上的任何地方都可以维持他的基本样式。。\r\n\r\n\r\n#### 不要使用相同的元素名\r\n使用`BEm`时，尽管`Webstrom`和`SCSS`已经帮我们解决了大部分问题，单书写很长一段的限制类名前缀仍旧是一件让人苦恼的事情。也许你会想到，可以参考`NEC`那样使用`u-hd`,`u-bd`这样的类名作为元素名，然后通过块名的命名空间，使用后代选择器限制样式，这样就不需要写那么多元素名了嘛！（没错，这就是我之前趟过的坑。千万不要这么做！）。\r\n\r\n原始的`BEM`禁止使用后代选择器，更准确的说法并不是禁止使用后代选择器，而是禁止在不同的块中使用相同的元素名。 原因是后代选择器存在潜在性的样式污染的风险，因为块中允许嵌套块，因此父块就可能通过后代选择器影响子块中的元素，这违背了块的独立性，带来的就会是无穷的灾难。\r\n\r\n也许使用子代选择器`>`是一个解决办法。呃好吧，这个选择器受HTML结构的严重限制，总之，最好还是放弃使用相同的元素名吧，除了整个样式表看起来没有那么统一之外，暂时也没有发现什么坏处。\r\n\r\n### 修饰符\r\n造成区分块和元素较困难的一种情形是：在`head`块中的`auth`块，也应用在其他地方比如`foot`，只不过有些许区别，这时候，相当于`auth`根据所处的块样式发生了改变，这时候应该将`auth`还看做是独立的块，还是依赖于`head`块的元素`head_auth`和`foot`块的元素`foot_auth`呢？\r\n\r\n答案是：将`auth`看做是一个独立的块！这也正是上面代码的做法，并且，这也正是修饰符存在的理由。\r\n\r\n如果需要创建一个和已存在的块非常相似的块，只是外观或行为有些许改变，则可以使用修饰符；同理，也可以为元素添加修饰符。\r\n\r\n最简单的修饰符大概莫过于数字了，这时候你想到了什么？没错，网格系统`col-xs-3`这样的类名，就可以看做是`col`这个类拥有两个修饰符`xs`和`3`，至于他们的具体含义是什么，就需要我们自己定义了。\r\n\r\n#### 避免结构语义化的修饰符\r\n回到上面那个问题，为了区分`head`和`foot`块中的两个`auth`，我们可以添加后缀`auth-inHead`和`auth-inFoot`这两个修饰符，当然，这两个修饰符完全没有扩展性，如果在侧边栏也使用了`auth-inHead`块的样式，那么这个命名就容易让人混淆。\r\n\r\n也就是说：修饰符尽量避免关联结构上的语义，比如`-inHead`这样的，哪怕是直接使用没有语义的数字来命名修饰符；而应当根据两个相似的块的实际样式差别来取舍，而不是这两个块所处的结构上的不同。\r\n\r\n如果一个块在页面上大量应用，而另一个相似的块使用次数较少，可以考虑不设置这个使用次数较多的块的修饰符，而将他作为`SCSS`的继承基类，其他带修饰符的类通过继承该基类，然后在定制专属的样式。\r\n\r\n#### 慎重使用实际语义化的修饰符\r\n如果某个块在页面上大量使用，则这个块的名字不应该是“实际语义化”的。回到上面的例子，`search`和`auth`都包含元素`_input`,`_submit`，他们的本质都是`form`标签，因此，更明智的做法是都将他们看做是`form`块，而不是两个独立的块:\r\n* `search`对应`form-inline`\r\n* `auth`对应`form-horizontal`\r\n\r\n这样，就可以统一他们的元素为`form_group`和`form_input`。至于`_submit`，不觉得把它们看做是独立的`btn`块更合适吗？当然，如果这个按钮的样式是这个块独有的，作为元素也是十分合适的，这样就回到了前面的问题：明智地决定一个标签到底是块还是元素！\r\n\r\n\r\n\r\n### 区分块和元素\r\n正确区分块和元素是非常重要的。前面提到：\r\n* 元素是依赖于块的，只有处于他们的块中元素才是有意义的。\r\n* 块是由元素组成的，不存在没有任何元素的块（那个时候应该被称为颗粒类）\r\n\r\n由于块可以嵌套块（这句话貌似出现了很多次），块和元素之间的界限比较模糊，怎么处理这个问题十分困难。\r\n\r\n#### 选择性使用后代选择器\r\n使用修饰符最大的困难就是找到一个合适的名称用来指定修饰符，同样是上面这个`head`块和`foot`块的`auth`问题，如果这两个略有差别的`auth`块的样式是他们父块所独有的，不在页面上其他地方被复用，可以考虑使用后代选择器而不是重新指定两个不同的修饰符来描述。\r\n```\r\n.head {\r\n    .auth{}\r\n}\r\n.foot {\r\n    .auth{}\r\n}\r\n```\r\n\r\n使用后代选择器，就仿佛将一个块完全变成了父块的元素来指定样式，这似乎违背了“独立块”的原则（块前面不能有任何选择器的限制）和原始`NEM`中“禁止使用后代选择器”的原则。这么做有两个理由：\r\n* 考虑到这个块的独立样式不会被重用，单独声明一个修饰符，然后只使用一次是一件很浪费的事情。\r\n* 页面上一般不太会出现块的循环嵌套的问题，即很少出现一个块下面的某个子块是它本身的情况。如果我们严格使用`B_E`的方式声明块和元素，则不会出现使用后代选择器造成的样式污染问题。\r\n\r\n因此，在声明块的基本样式的时候，应当保持块的独立性；而当父块严重影响（限定）这个块的某些样式的时候（导致他不会在其他地方被重用），使用后代选择器。\r\n\r\n一个简单的判断方法是：如果想出一个合适的修饰符非常困难，正如[BEM常见的10个疑问](https://www.smashingmagazine.com/2016/06/battling-bem-extended-edition-common-problems-and-how-to-avoid-them/)中第五条提到的“为了声明新的标识符，已经将这个块全部的样式都用掉了”（原文的建议的重新声明一个块），那么就使用后代选择器；如果明确知道样式被其他地方重用的可能性很大（浏览设计图），则使用修饰符。\r\n\r\n#### 元素与块的多重性\r\n是否允许一个标签同时拥有多个状态（多个块，或者即是块又是元素）？这个问题不是那么明显，举两个个例子：\r\n* 有时候发现某个块具有前面两个块的部分样式，比如`list`和`nav`，可以简单将他们组合在一起然后进行一次样式覆盖，而不需要单独声明新的块（为什么写到这里我想到了`I have a pen, I have an apple...`）。\r\n* 由于强迫症的存在，我希望尽量精简HTML文件的结构（块的元素和子块存在同一个标签上），比如前面的`head_left`元素和`logo`块。\r\n\r\n\r\n关于问题1，我的看法是：不允许一个标签同时存在多个块！即使一个块下面只包含一个块，完全可以使用修饰符进行处理。如果一个容器具有多个块，则内部的元素就会混乱，某些标签就可能成为不同块的元素，代码的逻辑立马变得复杂起来。\r\n\r\n关于问题2，我的看法是：允许一个标签作为父块的元素和子块。前面提到，可以选择性使用后代选择器，这样的话，将元素与子块放在同一个标签上也是可以接受的，这样可以简洁页面的结构。但是，这并不意味着非得把只包含一个子块的元素修改到与这个子块同一个标签上。总之到底是父元素包含子块，还是父元素与子块公用标签，我并没有确切的结论，上面那篇文章提到“没有人拍着你的肩膀让你把这个`div`标签去掉”，大概的意思是完全保证块的独立性，包括HTML结构的独立性吧。\r\n\r\n### 颗粒类\r\n颗粒类指的是那些完成独立功能，且不依赖任何父块或者限制任何子元素的独立样式类，比如整个网格系统和`flexbox`布局系统中的类，以及某些功能类，比如`fl`，`fr`，`clearfix`等。\r\n使用颗粒类可以比较灵活地使块具备通用样式，而无须单独再使用修饰符。某些地方颗粒类被称为原子类。\r\n颗粒类也可以使用修饰符进行修饰，比如前面提到的`.col-xs-3`。一个块上，可以带有某些单独的样式，比如`head`块同时具备网格系统的`container`颗粒类。\r\n\r\n#### 减小对颗粒类的依赖\r\n颗粒类在某种程度上与行内样式无异，只是从重复书写样式转变到了重复引入类。表面上我们可以通过颗粒类方便地定制样式和组合样式，而无须在组件中重复书写样式，貌似大大提高了样式的重用。但是，一个组件应该是独立的，如果在组件上大量使用颗粒类，则去除这些颗粒类之后，组件可能就无法维持他最基本的样式了。\r\n\r\n因此组件中诸如布局（浮动，定位，盒子模型）和尺寸（宽高，内外边距）等决定组件在文档流中的样式，最好不使用颗粒类；而诸如边框，颜色等基础样式，可以使用修饰符来代替颗粒类。\r\n\r\n为了提高样式的重用，正确的做法应当使用在`SCSS`中使用混合器，而不是在`HTML`中使用颗粒类。\r\n\r\n\r\n#### 标识类\r\n修饰符用来表示块或元素的某些状态，其中，有一类状态，比如高亮，禁止这些状态，是多数元素都会存在的，因此为了方便（不需要在前面添加块_元素前缀，且方便JS动态设置），统一命名为`is-active`，`is-disabled`等，且这些类只作为标识，只依赖具体的块或元素名称，而不能有默认的公有样式。\r\n\r\n为了避免违反前面\"不要使用相同的元素名\"的规则，标识符类应当作为多类选择器而不是后代选择器来使用。由于块是可以嵌套的，代表着一个块中可能同时存在数个`active`标识类，如果使用后代选择器且最外层的active生效了，则内部的`active`都可能受到污染。\r\n\r\n### 结论\r\n上面啰里八嗦扯了一堆，总结了使用`BEM`比较困难的几个地方：\r\n* 区分块和元素\r\n* 区分修饰符和后代选择器\r\n* 修饰符的命名\r\n* 颗粒类的使用\r\n\r\n如上面的内容提到的，有的问题已经有结论了，有的问题仍旧需要进一步的探索和思考。总之，尽管很早之前就开始纠结这个问题，然而正如前辈所言，样式表才是所有语言中最难维护的代码（如果CSS也算编程语言的话，好吧肯定有人说不算），长路漫漫，上下而求索也。\r\n\r\n\r\n## 名称库\r\n`NEC`提供了许多的类名参考，根据需要可以拿来作为块名，元素名，和类名\r\n* 实际语义名用作块名（）\r\n* 语义名和`hd`,`sd`等方位名可用作元素名（注意上面提到的坑）\r\n* 修饰符在实际需求中进行指定（可以跟据尺寸，方位和基础样式等命名）';
INSERT INTO shymean_article SET `title` = '使用Node.js写爬虫（初级篇）', `created_at` = 1482668320, `category` = 'JavaScript', `tags` = 'NodeJS, 爬虫, 正则', `content` = '\r\n最近两周，写爬虫写出魔怔了。很早之前就打算用Python写爬虫，可一直没有时间重新学习Python。刚好现在正在学习Nodejs，用JS写爬虫，实际上也很酷炫。额当然我现在也只会爬一些很简单的静态爬虫，这篇文章主要是整理一下这两周的心得，由于我也是爬虫菜鸟，如果有错误的地方还请指正，感激不尽。\r\n\r\n<!--more-->\r\n## 什么是爬虫\r\n下面是百度百科的关于爬虫的定义:\r\n> 网络爬虫（又被称为网页蜘蛛，网络机器人，web crawler），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。\r\n\r\n没必要去记住这些定义，我觉得，在浏览网页的时候，我们自己就是一个爬虫，在互联网上获取想要的信息，只是我们浏览网页的速度很慢，而预先写一个脚本，先将相关网页上的信息整理出来，这种获取数据的方式可以节省大量的时间————更重要的是，这真的很酷！\r\n过去的几天，我爬了糗事百科，暴走日报以及某个表情包网站。想一想，短短几秒钟就可以获取数千条笑话和表情图片，这让我感觉到满满的成就感（哈哈我就这点追求了）。\r\n\r\n## 基础\r\n那么，言归正传，一个爬虫可以工作可以拆分为两步：\r\n* 获取目标网页的内容\r\n* 分析并提取网页的内容\r\n* 保存收获的内容\r\n\r\n先来学习最基本的爬虫吧。\r\n### 获取网页内容\r\n跟我们访问网页一样，爬虫也是通过向Web服务器发起HTTP请求，然后等待并接收响应报文的。我们要做的就是提供一个url，剩下的事情（包括怎么建立TCP连接，怎么发送和接收报文，怎么传输数据）都不用我们管了。我们使用浏览器输入网址访问网页，不也是一样的嘛~\r\n```javascript\r\n// http模块用于发起和接收http请求\r\nvar http = require(\'http\');\r\n\r\n// 提供一个url\r\nvar href = \'http://www.qiushibaike.com/\';\r\n\r\n// 发起请求并接收响应\r\nhttp.get(href,function (res) {\r\n\t// 存放网页数据\r\n    var pageData = \'\';\r\n\r\n    // 在data事件中持续接收数据\r\n    res.on(\'data\',function (chunk) {\r\n        pageData += chunk;\r\n    });\r\n    \r\n    res.on(\"error\",function () {\r\n        console.log(\'something wrong!\');\r\n    })\r\n\t// end事件表明整个网页数据已经下载完成\r\n    res.on(\"end\",function (err,res) {\r\n        if (err) throw err;\r\n        \r\n        //整个网页的数据都保存在pageDate变量中等待下一步处理\r\n        console.log(pageData);\r\n    })\r\n});\r\n```\r\n\r\n你看，整个爬去网页的过程完全不用我们干些什么。稍微思考一下，网站中的数据分页，其URL都是按照一定规律组成的（一般都是拼页码的GET参数），使用一个循环，就可以获取很多链接并使爬虫在极短的时间内完成对相应页面内容的下载。\r\n再思考一下，一个网页并不是独立的存在于网站中：页面中包含大量的a标签，我们可以从获取到的数据中提取出相关的链接，然后重复爬取相应链接的页面，如此重复，爬取整个互联网的全部网页，指日可待了！（哈哈，当然事情远比这复杂的多，不过，最基本的爬虫原理大概就是这样）\r\n\r\n### 提取网页内容\r\n从页面中提取所需要的信息至关重要，这时候就要用到酷炫的正则表达式了。一般情况下（绝大部分情况下），需要的信息都被某个特定的标签所包围或者是就保存在某个标签的属性中，这些标签具有特定的类名或者id名（这对于我们这些切页面的来说实在是太熟悉了）。可以使用开发者工具快速确定所需信息所处的标志标签，再使用一个分组，就可以完美地将信息提取出来。\r\n\r\n```html\r\n// 通过观察可以发现，我们需要的信息如下嵌在页面中\r\n<div class=\"content-text\">\r\n    <a href=\"/article/118257676\" onclick=\"_hmt.push([\'_trackEvent\', \'list_content\', \'chick\']);\" >\r\n        <div>\r\n            <span>\r\n\r\n            有一个爱打麻将的老妈是一种怎样的体验呢？<br/>开店中，生意不大好。老妈打电话来说，店里生意怎样啊，不好吧，不好就抓紧回来吃饭，你大姨和大姨夫被留在这吃饭了，三缺一啊。。。。<br/>心好累\r\n\r\n            </span>\r\n        </div>\r\n    </a>\r\n</div>\r\n```\r\n于是可以封装一个函数从页面中提取全部有用的信息。\r\n```javascript\r\nfunction getInfo(htmlStr) {\r\n    var info = \'\';\r\n    var re = /class=\"content-text\"[^]*?<span>([^]*?)<\\/span>/g;\r\n    var res = null;\r\n    while (res = re.exec(htmlStr)){\r\n        info += res[1] + \'\\r\\n\';\r\n    }\r\n\r\n    return info;\r\n}\r\n```\r\n在循环中可以对单条数据进行一些其他操作比如换行，编号等你想做的任何操作。\r\n提取网页信息最重要的操作就是学会正则表达式，在某些时候，如果一次性写出合适的正则比较困难，可以通过多个正则表达式从大范围缩小到具体的标签，然后再进行处理，拿上面段HTML代码举例：\r\n```javascript\r\nvar re = /class=\"content-text\"([^]+?)<\\/div>/g;\r\nvar re2 = /<span>([^]+?)<\\/span>/;\r\nvar res = null;\r\nvar info = \'\';\r\nwhile(res = re.exec(htmlStr)){\r\n    info +=  \'\\r\\n\' + re2.exec(res[1])[1].trim() + \'\\r\\n\';\r\n}\r\n```\r\n尽管在这个例子不太明显，在某些时候这种办法还是挺有效的，因为所需信息的标识各不相同，因此这些爬虫的正则一般都是一次性的，对于出学者而言，提取到正确信息才是最重要的。当然，处于性能和学习的目的，深入学习正则表达式是很有必要的（我现在只是一个菜鸡...）\r\n\r\n### 保存网页内容\r\n实际上保存提取的信息已经不能算在是爬虫的范围内了，因为我们可以采用多种方式保存数据：从基本的文本文件到系统的数据库，都可以用来保存信息。根据各自的需求，选取合适的保存方式。\r\n我现在爬取的都是简单的文本和图像，因此直接保存使用文本和文件夹来保存在本地的，\r\n```javascript\r\n// 引入nodejs的文件系统\r\nvar fs = require(\'fs\');\r\n\r\nres.on(\"end\",function () {\r\n    pageInfo = getContent(pageDate);\r\n    // 保存所需信息\r\n    fs.appendFile(\'demo2.html\',pageInfo,function (error) {\r\n        if (error) throw error;\r\n        console.log(\"success\");\r\n    })\r\n})\r\n```\r\n关于文件保存这一块，现在并没有深入地了解，只是大致看了相关的API，因此有待学习。\r\n\r\n### 小结\r\n看吧，一个简单的爬虫就这么完成了，并不是什么高级复杂的东西。用到的知识也就是有：\r\n* HTTP请求与响应\r\n* 正则表达式\r\n* 文件IO\r\n\r\n实际上，现在已经有很多成熟的爬虫框架（或工具），这些框架能够让我们更好地专注于所需要获取的信息，而不是爬虫代码方面的东西（当然，了解爬虫的原理还是很有学习意义的）。\r\n\r\n## NodeJS爬虫工具\r\n社区里面提供了大量的爬虫工具，有专门用于网页请求的，有处理请求并发的，有解析页面内容的等等，数不胜数，我在最近的学习中，接触到了几个比较好用的工具\r\n\r\n### superagent\r\n[SuperAgent](http://visionmedia.github.io/superagent/)，一个用于发起网页请求和接受响应的库，提供链式的KPI接口，可以使用它替代基础的http模块\r\n```javascript\r\nvar superanget = require(\'superagent\');\r\nvar href = \'http://www.qiushibaike.com/\';\r\n\r\nsuperanget.get(href).end(function (err,res) {\r\n\t// 网页内容保存在res.text属性中\r\n    console.log(res.text);\r\n});\r\n```\r\nsuperagent提供的方法远不止这些基础的请求，诸如爬去需要cookie验证登陆的网站（知乎，微博等），就需要对爬虫做进一步的处理，这是我接下来的学习任务之一。\r\n\r\n### cheerio\r\n[cheerio](https://github.com/cheeriojs/cheerio)，当作服务端的jQuery使用，学DOM的用处终于体现出来，提取数据真的太方便了。\r\n使用cheerio，我们甚至不需要写一行正则表达式，就可以通过向操作DOM树一样，快速的解析目标信息，最关键的是，cheerio提供了jQuery一模一样的接口！\r\n```javascript\r\n// 初始化$对象，当然也可以取个其他的名字\r\nvar $ = cheerio.load(res.text);\r\n// 真的是一模一样的用法哦\r\n$(\".content span\").each(function () {\r\n    pageInfo += $(this).text() + \'\\r\\n\';\r\n})\r\n\r\nconsole.log(pageInfo);\r\n```\r\n使用cheerio似乎可以完全不用再学习正则表达式了，然而，写爬虫的乐趣之一不就是处理文本的成就感嘛（对我来说）。不过对于使用NodeJs写爬虫的前端来说，cheerio跟我们的日常习惯真的是太搭了，哈哈。\r\n\r\n### eventproxy\r\n[eventproxy](https://github.com/JacksonTian/eventproxy)，用于解决回调地狱的一个方案，通过事件监控异步程序，以一种优雅的方式解决多重异步嵌套的问题。\r\n\r\n\r\nNodeJs里面使用了大量的回调来实现异步，但是，如果后面的操作需要异步的结果才能进行（比如先爬去获得了网页上所有图片的链接，然后去根据链接去爬取每个图片），之前的解决办法是多重嵌套实现。这样做的话，代码看起来会非常恐怖。\r\n\r\neventproxy通过事件来解决这个问题的。NodeJS里面的事件系统十分重要，然而我也还没有开始学习，接下来又有事情做了。\r\n\r\n## 总结\r\n最近正在阅读《计算机网络》和学习NodeJs，而之前又学习了一段时间的正则表达式，恰好碰在一起，写爬虫真是太合适不过了。爬虫是一件很有意思的事情，期待之后的学习发现更多有意思的事情。我还打算学习一些Canvas，然后写小游戏玩玩...\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '《计算机网络-自顶向下的方法》读书笔记', `created_at` = 1480605634, `category` = '计算机基础', `tags` = '读书笔记', `content` = '\r\n大概是几个月前，曾被赶鸭子上架似的学习了一阵子socket，作为没有一丁点网络基础的菜鸟，完全无从下手，靠死记硬背写了几端代码，最后还是将它搁在哪里了。在现在的前端工作中，仍免不了要跟网络请求打交道，然而只明白几个http状态码，调用个Ajax接口是远远不够的，带着弄明白“从浏览器地址栏输入网址到看见整个网页发生了什么”这个经典面试题的目的，打开了《计算机网络》这本书。\r\n<!--more-->\r\n## 计算机网络和因特网\r\n因特网是一个世界范围内的计算机网络。\r\n### 网络边缘\r\n数以亿记的设备与因特网相连接，这些设备被称为“主机”或“端系统”:\r\n* 因为这些设备处于因特网的边缘，所以称为端系统\r\n* 因为这些设备容纳（即运行）应用程序，所以也被称为主机。实际上主机又可以分为“服务器”和“客户机”。\r\n主机间通过__通信链路__和分组交换机连接在一起，并向彼此交换__报文__。\r\n主机，分组交换机和其他因特网部件都要运行一系列__协议__，协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送/或接受到一条报文或其他事件所采取的动作。\r\n这些协议控制着因特网中信息的接受和发送。最主要的两个协议是TCP（传输层控制协议）和IP（网际协议）。\r\n\r\n### 网络核心\r\n网络核心指因特网网端系统的分组交换机和链路构成的网状系统。\r\n\r\n当一台主机向另一台主机发送报文时，发送端主机会将数据分段，然后再每段数据加上首部字节，由此形成的信息包称为“分组”：\r\n* 通信链路由不同的物理媒体组成，比如电缆，铜线，光纤，无线电等，传输的速率按bit/s（通常说的宽带20M，指的就是M节而不是M字节...）\r\n* 分组交换机从他的一条“入通信链路”接收到到达的分组，并从他的一条出通信链路转发该分组。最常见的分组交换机是__路由器__（用于网络核心）和__链路层交换机__（用于接入网）\r\n\r\n存储转发传输：多数分组交换机在入通信链路使用“存储转发传输”：在交换机能够开始向出通信链路传输该分组的第一个比特之前，必须接收到整个分组（需要耽搁一定时间）。\r\n排队时延和丢包：每个分组交换机与多条链路相连，对于每条链路，交换机都有一条输出队列，该队列存储着发往这条链路的分组，这些分组按照先进先出的规定，排队等待被传输（需要耽搁一定时间）。如果网络十分拥塞，则可能发生输出队列被塞满的情况，这时候某些分组就可能被丢失（丢包）。\r\n路由协议：前面提到每个分组交换机与多条链路相连，则需要按照一定规定选择发送分组的链路。每个主机都有一个IP地址，而每个路由器都有一个转发表，用于将分组的目的地址映射为出通信链路。\r\n\r\n### 协议分层\r\n网络设计者以分层的方式组织协议以及实现这些协议的硬件和软件，某层向他上一层提供的服务，则成为服务模型。\r\n每层有很多协议，该层的全部协议被称为协议栈。因特网的协议栈由物理层，链路层，网络层，运输层和应用层组成（这也是这本书的目录形式）。\r\n* 应用层是网络应用程序以及他们的应用层协议存留的地方（比如现在从事的web应用程序），通常把处于应用层的信息分组称为报文。\r\n* 运输层在应用程序端点之间传送应用层报文，主要存在两个重要的协议:TCP和UDP，通常把处于运输层的信息分组称为报文段。\r\n* 网络层负责将网络层的数据分组（通常称为数据报）从一台主机移动到另一台主机，该层最著名的协议为IP协议，该协议定义了在数据报中的各个字段以及端系统如何作用于这些字段。\r\n* 链路层将从网络层获取的数据包沿着路径传递给下一个结点，在下一个结点将数据报上传给网络层，通常包链路层的数据分组称为帧。\r\n* 物理层是将链路层每个帧中的一个一个比特从一个结点移动到下一个结点，根据实际传输媒体的不同，物理层有多种协议。\r\n\r\n\r\n## 应用层\r\n研发网络应用程序的核心是写出能够在__运行在不同的端系统__ 且 __通过网络彼此通信__的程序。根据应用程序在各种端系统上的组织形式，可分为“客户-服务器体系”结构和“对等（P2P）”体系。\r\n* 客户-服务端体系中，客户相互之间不直接通信，而是与运行的服务器通信，该服务器拥有固定且周知的地址(即IP地址)\r\n* P2P体系中，应用程序在简短链接的主机对之间使用直接通信\r\n\r\n从操作系统的角度看，应用程序之间的通信实际上是进程（处于激活状态的程序）通信，进程之间通过网络传递报文进行通信。而进程是通过一个被称为__套接字__（socket）的软件接口从网络发送或接收报文。\r\n进程之间通信，不仅需要他们所处主机的地址（IP地址），也需要知道进程的标识符（一台主机上可能会同时运行多个进程），这个标识符被称为\"端口号\"。\r\n\r\n常见的应用层协议有HTTP，FTP...\r\n### HTTP协议\r\nHTTP定义了Web客户向Web服务器请求Web页面的方法，以及服务器向客户发送Web页面的方式。\r\n* HTTP使用TCP作为运输层协议，因此不必担心数据的丢失。\r\n* HTTP服务器不保存关于客户的任何信息，因此HTTP是一个无状态协议。\r\n* HTTP可以使用“非持续连接”和“持续连接”两种方式处理多对“请求-响应对”。\r\n\r\n#### 请求报文\r\n下面是一个常见的HTTP请求报文。\r\n```\r\n// 请求行\r\nGET /somedir/page.html HTTP/1.1 \r\n// 首部行\r\nHosr: www.xxx.com\r\nConnection: close\r\nUser-agent: Mozilla/5.0\r\nAccept-language: fr\r\n// 请求实体，也就是常说的参数\r\n```\r\n* 请求行包括方法字段，URL字段和HTTP版本\r\n* 首部行提供的信息可能是Web代理告诉缓存所要求的\r\n* 请求实体指请求报文中所需要传递给服务器的“真正的数据”\r\n\r\n#### 响应报文\r\n```\r\n// 状态行\r\nHTTP/1.1 200 OK\r\n// 首部行\r\nConnection: close\r\nDate: Tue, 09 Aug 2011 15:44:04 GMT\r\nServer: Apache/2.2.3(CentOS)\r\nLast-Modified: Tue, 09 Aug 2011 15:24:04 GMT // 影响缓存\r\nContent-length: 6000\r\nContent-type: text/html\r\n// 响应实体\r\n```\r\n* 状态行包括协议版本，状态码和响应状态信息，常见的状态码有（200，301，400，404，505）\r\n* 每个首部行提供相应的信息用以达到不同目的，浏览器产生的首部行与很多因素有关\r\n* 响应实体包含实际的响应返回结果\r\n\r\n#### cookie\r\nHTTP是一个无状态的协议，不保存客户的任何信息，但是很多情况下服务器需要识别客户或者做出某些限制，这里可以使用cookie来标识一个用户。用户首次访问时，服务器在HTTP响应报文中返回一个Set-Cookie，在后续会话中，浏览器的请求报文包含了这个cookie首部，从而向服务器标识该用户。\r\n因此cookie可以在无状态的HTTP协议之上建立一个用户会话层。\r\n\r\n#### Web缓存\r\nWeb缓存器也叫代理服务器。经过配置，浏览器建立与Web缓存器之间的连接，发送请求报文，如果缓存器上存在请求对象则直接返回；如果不存在，则缓存器向初始服务器发送请求报文，并在接受到初始服务器的响应报文之后将请求对象在该缓存器上备份（这里就发生了“缓存”），然后返还给浏览器。\r\n* Web缓存器大大减少了浏览器请求的响应时间\r\n* 减少一个机构的接入链路到因特网的通信量，减少因特上的Web流量，从而改善所有应用的性能。\r\n\r\nWeb缓存还有一个十分重要的应用：内容分发网络（CDN），安装许多在地理上分散的缓存器，实现大量流量的本地化，后面将会提到。\r\n\r\n#### 条件GET\r\nWeb缓存器向返回浏览器的请求对象，但是，存放在缓存器中的文件副本可能已经过时了。幸好HTTP有一种“条件GET”方法：\r\n* 请求报文使用GET方式\r\n* 请求报文包含一个`If-Modifid-Since`首部行\r\n\r\n同时具备上述两个条件的请求报文就构成了一个条件GET请求报文。当Web缓存器结构到着这种条件GET。\r\n\r\n当Web缓存器从服务器第一次获取请求对象时，服务器的响应报文中会包含一个`Last-Modifyied`首部行。\r\n当一段时间过去后，Web缓存器接受到浏览器的条件GET请求报文时，由于不确定初始服务器是否更新了文件，因此Web缓存器也会向初始服务器发送一个包含`If-Modifid-Since`的条件请求报文。\r\n初始服务器会根据文件对象的`Last-Modifyied`的值是否在`If-Modifid-Since`之后，只有当在指定日期之后对该文件对象修改过，才会返回修改后的新对象，否则，返回`304 Not Modified`（返回新的文件对象会浪费大量的带宽，而返回304表示告知Web缓存器可以使用它自己的缓存对象副本）。\r\n\r\nPS：这里突然想到之前项目里面，由于微信开发者工具的缓存十分严重，在服务器上修改了CSS文件一直得不到刷新，后面写了段JS，每次在请求后面带上了一个随机的GET参数，然后就成功解决了，大概就是这里的条件GET原理吧。\r\n\r\n### DNS协议\r\nDNS（Domain Name System）是因特网上的目录服务。主机都可以通过多种方式进行标识。主机名更容易被人们接受（www.foo.com），但是却没有提供多少该主机在因特网中的位置。实际上，主机通过使用IP地址来表明他自身的位置（IP地址后面提）。\r\n也就是说主机既可以使用主机名来标识（人们更喜欢好记的主机名），也可以使用IP地址来标识（路由器更喜欢定长的有层次结构的IP）。因此需要一种进行主机名到IP地址转换的目录服务：DNS。\r\n\r\n下面是简单的DNS工作流程：\r\n* 浏览器从URL中抽取出主机名，并将主机名传递给DNS客户端（就运行在该主机上）\r\n* DNS客户端向DNS服务器发送解析主机名的请求报文\r\n* DNS服务器返回包含对应主机名的IP的响应报文，并被DNS客户端接受。\r\n* DNS向浏览器提供相应主机名的IP地址。浏览器向位于该IP地址的服务器发送请求报文并建立TCP连接。\r\n\r\n为了处理扩展性问题，DNS使用了大量的DNS服务器，并以层次方式组织这些服务器，通常包括：\r\n* 根DNS服务器\r\n* 顶级域服务器\r\n* 权威DNS服务器\r\n* 本地DNS服务器\r\n\r\n没有任何一台DNS服务器保存了因特网上全部主机的IP映射。通过递归和迭代查询主机名对应的IP地址并返回给浏览器。\r\n为了改善时延性能并减少DNS报文数量，DNS广发使用缓存技术。每当本地DNS服务器从某个DNS服务器接收到响应报文后，就将相应的主机名和IP地址保存起来，接下来的一段时间内接受到相应的解析请求就直接返回该IP地址，而不必再查询其他DNS服务器\r\n\r\n### 套接字编程\r\n学习C++的时候曾经翻过这小节，当时完全看不明白，全靠死记硬背的。现在再看，实际上套接字跟DOM一样，也是提供了一套很方便接口，让我们不用去关心具体的网络实现细节，而专注于应用层的逻辑处理。（当时我压根不明白“接口”到底是一个什么样的概念...）\r\n\r\nSocket套接字提供给的接口是用于连接应用层和传输层，而实际上，开发者在应用层的一侧可以控制所有东西（业务逻辑），而对传输层的一侧基本上没有控制权。前面提到，传输层两个最重要的协议是TCP和UDP，这两者的传输方式完全不相同，因此，在数据分组从应用层推送到传输层之前，在套接字的应用层这一侧，我们必须根据选择的传输层协议做一些准备工作。\r\n\r\n#### UDP\r\n使用UDP时，每个分组上都必须包含目的主机的IP地址（这样路由器才能将报文路由到正确的主机上）和接收端口号（一台主机上可能运行着多个进程，这些进程又可能包含一个或多个端口号，必须明确指出是哪一个端口号的进程处理这个分组）。\r\n```\r\n# 直接把书上的示例代码敲了一遍，啊很久没写python了，当初真是靠背下来的\r\n\r\n# client\r\nfrom socket import *\r\nserverName = \'127.0.0.1\'\r\nserverPort = 12000\r\nclientSocket = socket(AF_INET,SOCK_DGRAM)\r\nmessage = raw_input(\'input a message:\')\r\nclientSocket.sendto(message,(serverName,serverPort))\r\n\r\nmsg, serverAddress = clientSocket.recvfrom(2048);\r\nprint msg\r\nclientSocket.close()\r\n\r\n# server\r\nfrom socket import *\r\nserverPort = 12000\r\nserverSocket = socket(AF_INET,SOCK_DGRAM)\r\nserverSocket.bind((\'\', serverPort)) # 任意请求IP\r\nprint \'server start..\'\r\nwhile True:\r\n    msg, clientAddress = serverSocket.recvfrom(2048)\r\n    msgModify = msg.upper()\r\n    serverSocket.sendto(msgModify,(clientAddress))\r\n```\r\n\r\n#### TCP\r\nTCP是一个面向连接的协议，因此客户机和服务机在发送数据之前，必须通过“三次握手”建立连接：客户端套接字地址（客户端IP和端口号）与服务端套接字地址之间的链接。连接建立之后，只需要将数据推送给TCP连接就可以了（不需要再额外想分组中添加目标主机的IP和端口号）。“三次握手”和“四次挥手”是TCP连接中十分重要的过程，后面也会提到。\r\n```\r\n// client\r\nfrom socket import *\r\nserverName = \'127.0.0.1\'\r\nserverPort = 12000\r\nclientSocket = socket(AF_INET,SOCK_STREAM)\r\nclientSocket.connect((serverName,serverPort))\r\n\r\nmessage = raw_input(\'input a message:\')\r\nclientSocket.send(message)\r\n\r\nmsg= clientSocket.recvfrom(2048)\r\nprint msg\r\nclientSocket.close()\r\n\r\n// server\r\nfrom socket import *\r\nserverPort = 12000\r\nserverSocket = socket(AF_INET,SOCK_STREAM)\r\nserverSocket.bind((\'\', serverPort))\r\nserverSocket.listen(1) // 欢迎套接字\r\nprint \'server start..\'\r\nwhile True:\r\n    connectionSocket,addr = serverSocket.accept() // 连接套接字\r\n    msg = connectionSocket.recvfrom(2048)\r\n    msgModify = msg.upper()\r\n    print msgModify\r\n    connectionSocket.send(msgModify)\r\n    connectionSocket.close()\r\n```\r\n\r\n### 其他\r\n书中还介绍了诸如FTP，SMTP等应用层协议以及P2P体系，但这些我只是大致浏览了一下，毕竟现在的重点是弄明白浏览器发送请求到展示网页的过程，因此其他的部分待日后再回头看看吧。\r\n\r\n\r\n## 传输层\r\n传输层协议为运行在不同主机上的应用进程提供了逻辑通信：\r\n* 在发送端，运输层从应用程序进程接收到的报文（包含数据分组）转换成运输层报文段（报文段尺寸比较小，且每段报文段之前都包含了运输层首部信息）。\r\n* 在接收端，网络层从数据报（即网络层分组）中提取运输层报文段，并将该报文段向上传递给运输层\r\n\r\n将主机交互扩展到进程间的交互被称为运输层的多路复用和多路分解：\r\n* 在接受端，运输层检查报文段，并标识出套接字，从而将报文段定向到该套接字将运输层报文段中的数据交付到正确的套接字的工作称为__多路分解__\r\n* 在源主机，从不同的套接字收集数据块，并为每个数据块封装首部信息从而生成报文段，然后将白报文段发送到网络层，这个工作称为__多路复用__\r\n\r\n一个UDP套接字由一个二元组来标识（目的IP地址和目的端口号），因此，即使两个UDP报文具有不同的源IP地址和(或)源端口号，只要他们的目的IP地址和目的端口号相同，这两个报文段都能被定向到目的主机同一个目的进程上。而在UDP的报文段中，源端口号只是为了目的主机响应报文的返回地址而已（完整的返回地址包括源IP地址和源端口号）。\r\n\r\n一个TCP套接字由一个四元组标识（目的IP地址和目的端口号，源IP地址和源端口号）。考虑上面UDP中例子，两个具有不同源IP地址和（或）源端口号的TCP报文，访问相同的目的IP和目的端口号，他们也会被定向到同一个目的主机不同的端口号上（这里就能理解为什么说TCP报文中的目的端口号只是一个欢迎端口号了）。后续到达的报文，如果他们的四个值与目的主机上某个套接字的四个标识符都相同，就会定位到相应的套接字上。\r\n拿Web服务器来说，服务器会为每一个链接生成一个新进程（独一无二的套接字），通过这些套接字，每个连接都可以与服务器请求和发送HTTP报文。实际上，连接和进程并非是一一对应的，某些高性能Web服务器为每个连接生成一个线程而非进程。\r\n\r\n### UDP\r\nUDP的传输速率十分高：\r\n* UDP是除了最基本的复用/分解和极少量的差错检测之外，几乎没有对IP增加其余的东西\r\n* 由于UDP套接字由一个二元组标识，数据报首部行开销小（仅需8字节）。\r\n* UDP没有拥塞控制机制，只要应用程序将数据传递给UDP套接字，套接字就会将此数据打包成UDP报文段并立即传递给网络层\r\n\r\n因此,UDP常用于无需建立连接，无需可靠数据的网络请求中。最常见的例子就是DNS：路由选择表被周期性的更新，更新的丢失可以被下一次更新所替代，因此丢包，过期的更新是无效的。\r\n\r\n#### UDP报文段\r\nUDP报文段的首部行只有4个字段，每个字段由两个字节组成：源端口号，目的端口号，长度，校验和。\r\n* 源端口号和目的端口号用来将报文段定向到对应的进程，执行分组/复用功能\r\n* 接收方使用长度字段来检验和检查该报文段中的数据是否出现了差错\r\n* 由于不能保证源和目的主机之间的所有链路都提供了差错检测，因此，即使报文段经链路正确传输，也可能引入报文差，因此UDP就必须在端到端的基础上为运输层提供差错检测（只能是检测而对于差错的恢复无能为力）\r\n\r\n### 可靠数据传输原理\r\n书中用了大量的篇幅，从简到深，介绍如何运输层是如何实现可靠数据传输的，然而！我！看！不！懂！这真是一个悲伤的故事。\r\n可靠数据传输包括差错检测，重传，累积确认，定时器以及用于序号和确认号的首部字段等等。\r\n\r\n### TCP\r\nTCP是一个面向连接的过程，这句话已经被重复了很多次了，在两台主机彼此发送数据之前，必须相互发送某些报文段内，以建立“确保数据传输”的参数：\r\n* 客户进程首先通知客户运输层并发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段响应，然后客户再用第三个特殊的报文段响应，这种连接建立过程被称为__三次握手__\r\n* 建立连接之后，主机间通过套接字传递数据流：数据一但进入套接字，就由运输层控制了，TCP将这些数据引导至发送缓存，并不时从里面取出一块数据，配上TCP首部行，形成TCP报文段，然后向下传递给网络层；而当另一端的TCP接收到一个报文段后，就将数据存放在TCP的接收缓存中，应用程序从此接收缓存中读取数据流。（需要注意的是主机之间的网络元素没有为该TCP链接分配任何缓存和变量）。\r\n\r\n#### TCP报文段\r\nTCP的首部行一般是是20字节（UDP的首部行是8个字节）。与UDP一样，TCP报文端首部行包括源端口号，目的端口号以及检验和字段。此外还包括：\r\n* 32位的序号字段和32为的确认号字段，用来实现可靠数据传输服务\r\n* 16位的接收窗口字段，用于流量控制\r\n* 4位的首部长度，需要注意的是TCP首部的长度是可变的。\r\n* 可选与变长的选项字段\r\n* 6位的标志字段，用来标识TCP连接状态\r\n\r\n一个TCP报文段的序号，是该报文段首字节的字节流编号（比如一段数据流有1000个字节，报文段每次传输200个字节，则第一个报文段的序号是0，第二个报文段的序号就是200，第三个400...）;\r\n一个TCP报文段的确认号就是发送该报文段的主机期望从另一台主机收到的下一字节的序号：\r\n* 如果主机A已经收到了编号为0-200的数据流，此时他向主机B发送的报文段确认号就是201\r\n* 如果A已经收到了0-200和400-600的数据流，但是没有收到200-400的数据流，则主机A为了重新构建主机B的数据流，则仍然会等待201及后面的数据（虽然已经收到了400-600），因此此时主机A发送的报文段确认号仍然是201。因为TCP只缺认该流中至第一个丢失字节为止的字节，所以TCP被称为__提供累积确认__\r\n* 上面第二条例子中，400-600的数据流可以看作是一个失序的报文段，然而TCP并没有显式规定如果处理这个失序的报文段，它由实现TCP的编程人员去处理，决定是否保留（节省带宽）还是直接丢弃（重新请求有序的报文段）。\r\n\r\n#### 可靠数据传输\r\nTCP的可靠数据传输确保一个进程从其接收缓存中读出的数据流是无损坏，无间隔，非冗余和按序的数据流，从TCP的发送方高度简化的角度来看，需要监控三个事件：运输层从上层应用接收数据，定时器超时和收到ACK\r\n* 第一个事件发生，TCP将接收到数据封装成报文段，每个报文段都包含一个序号。另外，如果此时定时器如果没有为其他某些报文段运行，则将数据传递给IP层时，TCP会启动该定时器（定时器与最早的未被确认的报文段相关联）。\r\n* 如果触发了超时事件，则TCP会重传引发超时事件的那个报文段，并重启定时器\r\n* TCP维护一个状态变量`sendbase`，是最早未被确认的字节的序号。当TCP接收到来自接收方的ACK响应后，会将ACK的值`y`与`sendbase`进行比较，TCP采用的是累积确认，即y确认了字节编号在y之前的所有字节都已经接收到了。如果`y > sendbase`，则发送方更新`sendbase`。\r\n\r\n#### TCP连接管理\r\n\r\n__三次握手__\r\n客户中的TCP会以下面的方式与服务器中的TCP建立一条TCP连接：\r\n* 客户端TCP首先发送一个特殊的TCP报文段，该报文段首部行的一个标志位（即SYN比特）被置为1（因此这个特殊的报文段被称为SYN报文段），此外，客户会随机选择一个初始序号`client_isn`，并将此编号放在SYN报文段的序号字段中。\r\n* 服务端接收到这个TCP SYN报文段之后，为该TCP连接分配TCP缓存和变量，并向客户TCP发送允许连接的响应报文段（有时候被称为SYNACK报文段，告诉客户端服务器同意建立TCP连接）。这个响应报文段的首部包含了3个重要信息：\r\n\t* SYN 比特被置为1\r\n\t* 确认号字段被置为`client_isn + 1`\r\n\t* 序号字段是服务端自己选择的初始序号`server_isn`\r\n* 在收到SYNACK响应报文段之后，客户端也要为该TCP连接分配缓存和变量，然后向服务端再次发送一个报文段，这个报文段对服务器允许连接的SYNACK报文段进行确认：客户将`server_isn+1`放入该报文段首部行的确认字段中，并将SYN比特置为0（表示连接已经建立了）。此外，这个报文段实际上就可以携带数据到服务端了。\r\n\r\n在之后的连接中，SYN比特都被置为0，为了创建这个链接，客户端和服务器发送了三个分组，因此被称为“三次握手”。\r\n\r\n__四次挥手__\r\n参与一条TCP连接的任意一方都能够终止该连接。以客户端发送关闭连接为例：\r\n* 客户TCP向服务器进程发送一个特殊的TCP报文段，这个报文段首部的FIN比特标志位被设置为1\r\n* 服务端接收到该报文段，就向发送端回送一个确认的报文段；然后，服务端会向客户端进程发送另一个特殊的报文段，该报文段的FIN比特标志位被设置为1；\r\n* 客户端接受到服务端的FIN报文段之后，也会再次向服务端发送一个确认报文段。最后，两台主机用于该连接的资源都被释放了。\r\n\r\n由于关闭连接一共发送了四个分组，因此被称为“四次挥手”。\r\n\r\n### 拥塞控制和流量控制\r\n书中也有相当的篇幅介绍这方面的知识，然而...\r\n\r\n\r\n## 网络层\r\n网络层也是协议栈最复杂的层次之一。\r\n\r\n### 网络层的功能和服务\r\n两台主机之间通过数台中间路由器相连，路由器具有截断的协议栈（即没有网络层之上的传输层和应用层）。网络层的目的看似非常简单：将分组从一台数据移动到另一台接收主机。为此，需要实现两项基本的功能：转发和路由选择\r\n* 转发：将一个分组在单一的路由器中从一条输入链路移动到适当的输出链路（微观上）；\r\n* 路由选择：当分组从发送放流向接收方时，网络层必须决定这些分组所采用的路由或路径，计算这些路径的算法被称为路由选择算法（宏观上）\r\n\r\n每一台路由器都具有一张转发表（转发表是根据路由选择算法所决定的），路由器根据到达该路由器的分组（报文段）首部字段的值，从转发表中查找该分组将被转发的输出链路接口，然后将该分组移动到对应的输出链路。\r\n\r\n同运输层类似，网络层也能够在两台主机之间提供无连接服务或连接服务，但是仍有很大的区别：\r\n* 仅在网络层提供连接服务的计算机网络被称为虚电路网络，比如ATM,帧中继的体系结构\r\n* 仅在网络层提供无连接服务的计算机网络称为数据报网络，比如因特网\r\n\r\n在数据报网络中，每当一个端系统要发送分组时，它就为该分组加上目的端系统的地址，然后将分组推进网络中，路由器无需维护任何虚电路。\r\n当分组从源到目的地的传输过程中，中间路由器都使用分组的目的地址来转发该分组（通过将目标地址映射到转发表的输出链路出口）。\r\n\r\n### 路由器的工作原理\r\n前面已经提到，网络层的转发功能，实际上是将分组从一台路由器的输入链路转移到这台路由器的输出链路。具体的细节是，路由器使用分组首部目的地址的前缀（目的地址的前缀是具有一定规则的，后面会提到）与这台路由器的转发表进行匹配：\r\n* 如果存在一个匹配项，则路由器想与该匹配结果相关联的链路进行转发；\r\n* 如果存在多个匹配项，则使用最长前缀匹配原则\r\n* 如果不存在匹配项，则想最后一条链路出口转发（？不太明白）\r\n\r\n一台路由器包括基本的：输入端口，交换结构，输出端口和路由选择处理器。影响转发过程的效率包括：前缀与转发表的匹配速度，以及从输入链路到输出链路的数据堵塞情况。下面来看看路由器的各个部分。\r\n\r\n__输入端口__\r\n在输入端口中，最主要的操作便是通过IP地址查找转发表，确认分组的输出端口，除此之外，还必须检查分组的版本号，检验和以及寿命字段，并更新用于网络管理的计数器。\r\n\r\n__转换结构__\r\n交换结构是一台路由器的核心，常用的交换方式有：\r\n* 经内存交换，类似于传统操作系统中的IO设备一样，分组从输入端口被复制到内存，然后将该分组复制到输出端口的缓存中\r\n* 经总线交换，输入端口经一条共享主线直接传送到输出端口，不需要经过路由处理器的处理\r\n* 经互联网络交换\r\n\r\n__输出端口__\r\n输出端口取出其内存上的数据并发送到输出链路上。在输出端口上的分组调度程序控制排队分组的发送\r\n\r\n### 网际协议\r\n因特网编码和转发是网际协议的重要组成部分。\r\n\r\n#### 数据报\r\n网络层分组被称为数据报，一个数据报具有20字节的首部行，其中，最重要的字段有：\r\n* 标识，标志，片位移，主要用于重新拼接组合完整的分组\r\n* 首部检验和，帮助路由器检测接收到的IP数据报中的比特错误\r\n* 源和目标地址，当某个源生成一个数据报时，它在源IP字段中插入他的IP地址，在目的IP地址字段中插入其最终的目的地址（通常源主机通过DNS解析获取目标地址）\r\n* 数据，主要承载需要交付给目的运输层的数据\r\n\r\n#### IP编址\r\n主机与物理链路的边界叫做接口（一般只有一个），路由器与它的任意一条链路之间的边界也叫做接口（一般会有两个或多个，因为它是路由器~），一个IP地址技术上是与一个接口相关联的。\r\n每个IPV4地址展32比特，因此总共有2^32个可能的IP地址，而每一台路由器上的每一个接口和连接的每一台主机，都必须有全球唯一的IP地址。然而这些IP地址并不能随便选择，而是由其需要连接的子网决定的。\r\n\r\n一个路由器接口与几台主机相连组成的网络称为__子网__（这里可以理解为一台路由器为数台主机服务，他们组成的小圈子称为子网），IP编址为这个子网分配一个类似于`223.1.1.0/24`的地址，其中`/24`的记法，被称为__子网掩码__，表明32位地址最左侧的24位定义了子网地址，然后，该子网的每台主机以及与这台路由器相连的那个接口，由最右边的8位区分（因为他们的子网掩码都是相同的）。\r\n\r\n使用这种`a.b.c.d/x`的地址分配策略，将子网寻址的概念一般化了，该IP地址的最左侧`x`位构成了IP地址的网络部分（通过路由器与网络相连），而剩下的最右侧`32-x`位用来区分该子网内部不同的主机。此时，该子网外部的其他路由器（即不直接与子网内部相连的中转路由器），只需要识别前x位地址即可，则相当大地减少了网络IP地址在这些外部路由器中转发表的长度——当接受到数据报的时候，只需要使用最长前缀匹配原则进行转发即可，而不需要完全校32位全部地址。最后，只有子网的内部路由器使用剩下的32-x位决定将数据转发给这个子网内部的某台主机。\r\n\r\n#### 分配IP\r\n为了获取一块IP地址用于一个组织的子网，该组织的网络管理员需要向他的网络服务商申请，并从该服务商的地址块中获取到一部分IP地址，ICANN向区域性因特网注册机构分配地址。\r\n然后，网络管理员就可以为本组织内的路由器和主机挨个分配IP地址了，一般地需要手动地设置路由器的IP地址，而使用DHCP（动态主机配置协议）配置主机IP地址（每次为主机分配一个临时的IP地址）。\r\n\r\n此时又会出现另一个问题：如果子网内需要连接网络的主机超过分配的IP地址，需要怎么处理呢？有一种__网络地址转换__方法可以使用。';
INSERT INTO shymean_article SET `title` = '从零开始实现一个简易的PHP框架', `created_at` = 1483847840, `category` = 'PHP', `tags` = 'MVC', `content` = '\r\n\r\n在11月份的时候，参照慕客网的视频，照猫画虎折腾了一个非常简陋的PHP框架半成品，简陋到只勉强实现了自动加载类和路由功能，由于功力不足暂时将这个小项目放在了旁边，到后面补习了一些PHP的基础知识，又花了大概一周的时间去了解Laravel，对于PHP框架的运行流程稍微长进了一点。现在趁着周末重新整理了之前的笔记：一个简易的PHP MVC框架的实现。\r\n\r\n<!--more-->\r\n\r\n## MVC框架\r\n\r\n### 概念\r\n流行的PHP框架都是采用MVC形式，就我现在对于MVC的理解是这种设计将整个项目分为了三层：\r\n* M(模型层),主要负责与数据路交互并提供获取相应数据的接口\r\n* V(视图层),主要负责数据的提交和显示,与用户进行交互\r\n* C(控制层),主要处理业务逻辑，连接模型层与视图层。\r\n\r\n简单地说，控制层就是获取用户的请求，并将对应的请求转发到模型层，获取模型层返回的数据，然后再提供给视图层展示。而实际上，一个PHP程序也可以抽象地划分为3个组成部分，然后在MVC结构中：\r\n* 数据的采集(从视图层提交数据)\r\n* 数据的处理(控制层捕获到数据并转交给模型层进行逻辑处理，然后从模型层返回经过处理的数据到控制层)\r\n* 数据的输出(控制层将模型返回的数据传递给视图)\r\n\r\n### 单入口文件\r\n与MVC相关还有另外一个比较重要的概念：__单入口文件__。比如，ThinkPHP根目录下的`index.php`和Laravel根目录下的`public/index.php`，就是整个框架的入口文件。\r\n单入口文件的原理是：通过单入口文件加载整个项目的核心文件，核心文件中通过解析路由获取需要调用的控制器，然后加载对应的控制器并调用相关方法，控制器方法处理对应的逻辑并加载需要的视图文件，最后输出视图。\r\n那么，也就是说，访问所有的控制器方法，实际上都是访问这个`index.php`文件(假设我们的入口文件名就是`index.php`，下同)，在默认情况，每个URL开头都会带有`index.php`。\r\n\r\n一般情况下，都会通过`.htaccess`文件进行服务器路径重写，隐藏URL路径中的`index.php`，我们看到的URL一般就成了`www.xxx.com/Index/index`这样的形式。\r\n\r\n在这个简易框架的单入口文件中，我们需要做两件事情：\r\n* 定义路径常量，整个框架主要包含__核心文件夹__（用于存放框架的核心文件，诸如路由，数据库，日志类以及相关的配置文件）和__项目文件夹__（用于存放项目代码，包括控制器和模型）。\r\n* 注册自动调用方法\r\n\r\n```\r\n// 定义路径常量\r\ndefine(\'ROOT\',dirname(__FILE__));\r\ndefine(\'CORE\',ROOT.\'/Core\');\r\ndefine(\'APP\',ROOT.\'/App\');\r\ndefine(\'MOUDLE\',\'App\');\r\n\r\n// 调试模式\r\nini_set(\'display_errors\',\'1\');\r\n\r\n// 加载函数库\r\ninclude CORE.\'/Common/function.php\';\r\n// 加载核心文件\r\ninclude CORE.\'/Core.php\';\r\n\r\n// 自动加载类\r\nspl_autoload_register(\'Core\\Core::load\');\r\n\r\n// 启动程序\r\n\\Core\\Core::run();\r\n```\r\n\r\n## 路由\r\n单单访问`index.php`是无法完成我们的业务逻辑的，我们必须通过解析URL的参数，调用对应的方法。这里使用的方法是PHP的超全局变量`$_SERVER`的属性`[\'REQUEST_URI\']`来实现URL的解析的。\r\n\r\n### $_SERVER\r\n`$_SERVER`是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个关联数组中的属性由 Web 服务器创建（但是不能保证每个服务器都提供全部属性）。 我们使用的是其中的\'REQUEST_URI\'属性，也就是 \'URI\' 用来指定要访问的页面。\r\n\r\n### URI\r\n那么问题来了，\'URI\'和\'URL\'长的这么像，他们的关系是什么呢？首先来看一看什么是URI。参考[网络爬虫](http://blog.csdn.net/pleasecallmewhy/article/details/8922826);\r\n> URI，是uniform resource identifier，统一资源标识符，用来唯一地标识一个资源，Web上每种可用的资源，如 HTML页面、图像等都由这个标识符进行定位。\r\n\r\n通常，一个URI由三部分组成，比如`http://www.shy.com/Index/index`：\r\n* 访问资源的命名机制`http`\r\n* 存放资源的主机名`www.shy.com`\r\n* 可以通过路径访问`Index/index`\r\n\r\n我们需要解析的就是这个`Index/index`，这正是`$_SERVER[\'REQUEST_URI\']`提供的值（所以前面隐藏`index.php`也是为了更轻松的获取到URI）。\r\n\r\n### URL\r\n接下来就是常说的URL了。\r\n> URL，是uniform resource locator，统一资源定位符，主要用在各种WWW客户程序和服务器程序上，采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。\r\n\r\nURL的格式如下：\r\n```\r\nprotocol :// hostname[:port] / path / name\r\n```\r\n* 协议名\r\n* 主机名，有时还包括端口号\r\n* 资源保存的路径和名称\r\n\r\n乍一看URL跟URI貌似并没有什么区别嘛!实际上可以把URI看做URL更低层次的抽象，只一种字符串文本标准。两者的区别在于：\r\n* URI表示请求服务器的路径，定义这么一个资源（并没有指定它的用途）；\r\n* 而URL同时说明要如何访问这个资源（指明网址 ftp服务器 文件路径）。\r\n\r\n这里引申还之前看见的一个题目:\"输入`www.shy.com`和`www.shy.com/`的区别。咳咳，偏离文章主题了，就此打住。\r\n\r\n### 小结\r\n通过获取`$_SERVER[\'REQUEST_URI\']`，然后将他分解成所需要的控制器和方法名，再考虑实现GET参数的传递，一个简单的路由类就实现了。\r\n```\r\nnamespace Core\\Lib;\r\nclass Route {\r\n    public $ctrl = \'Index\';\r\n    public $action = \'index\';\r\n\r\n    public function __construct(){\r\n        $urlArr = explode(\'/\',trim($_SERVER[\'REQUEST_URI\'],\'/\'));\r\n        if (isset($urlArr[0]) && $urlArr[0] != \'\'){\r\n            $this->ctrl = $urlArr[0];\r\n        }\r\n        if (isset($urlArr[1])){\r\n            $this->action = $urlArr[1];\r\n        }\r\n\r\n        // 如果传参则必须显式声明控制器和方法名\r\n        if (isset($urlArr[2])){\r\n            $getArr = explode(\'&\',$urlArr[2]);\r\n            foreach($getArr as $v ){\r\n                $pair = explode(\'=\',$v);\r\n                $_GET[$pair[0]] = $pair[1];\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n假定输入的URL为：`http://www.shy.com/Index/index/id=100&age=200`，则路由解析获得的结果是：\r\n* Index控制器\r\n* index方法\r\n* $_GET[id]=100,$_GET[age]=200\r\n\r\n这个路由方式参照的是ThinkPHP的做法，然而我并没有去研究TP的源码，里面应该有更全面的处理方式。实际上我更倾向于Laravel的自定义路由，虽然只会一点点皮毛，哈哈。\r\n\r\n## 自动加载类和命名空间\r\n从路由中获取到了请求的控制器和方法名，然后只要加载相应的控制器文件，顺利调用目标方法，整个程序就能跑起来了。加载控制器类，需要弄明白两个语言基础：自动加载类和命名空间。这里从《Modern PHP》这本书中收获颇多。\r\n\r\n### 自动加载类\r\n自动加载类指的是，PHP在运行时按需要查找类并加载到相关文件，从而不需要显式地提前声明`require`或`include`。在入口文件看见了`spl_autoload_register`这个函数\r\n\r\n> bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )，将函数注册到`SPL__autoload`函数队列中。如果该队列中的函数尚未激活，则激活它们。\r\n\r\n通过自定义一个注册函数，这个函数接收一个类名作为参数，当程序运行到需要实例一个对象却找不到对应的类的时候，就会自动调用`__autoload`，通过在注册函数中定义的规则加载相应的类文件。\r\n\r\n我们可以随心所欲的定义注册函数中的加载规则。实际上，PSR-4标准指定的自动加载策略依赖PHP命名空间和文件系统目录结构查找并加载PHP类，即：将命名空间的前缀和文件系统中的目录对应起来（我们知道命名空间和实际的文件目录并没有直接关系）。通过将完全命名空间映射成文件目录，可以定义很直观的类加载规则。\r\n\r\n那么，PHP中的命名空间是怎么一回事呢？\r\n\r\n### 命名空间\r\n尽管在C++中就知道了命名空间的概念，却没有明白它真正的意义。之后再Laravel的使用中体会到了命名空间的强大。有了命名空间，我们可以很直观地组织和封装相关的PHP类（假装这里体会到了模块化思想），避免与第三方的类库发生命名冲突。\r\n\r\n使用`namespace`关键字来定义命名空间，与目录和文件的关系相似（但是并没有直接的关联），PHP命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义（这正是实现自动加载类所需要的）。需要注意的是必须在文件的开头部分声明整个文件的命名空间（尽管一个文件可以同时声明数个命名空间，但是一般不推荐这么做）。\r\n定义一个命名空间之后，其中声明的类和函数就有了名称限定，调用命名空间中的类或函数可以通过三种方式引用。\r\n\r\n#### 非限定性名称\r\n非限定性名称,或者不包含前缀的类名，会被默认解析在当前文件的命名空间下，如果当前文件没有命名空间，则会解析为全局函数名称（即不包含任何命名空间）或者常量名称。 以上面的代码为例，如果在file2中以非限定性名称调用:\r\n```\r\nnamespace name2;\r\ninclude \'1.php\';\r\nfoo();\r\n```\r\n就会将foo()解析为name2\\foo()，如果在name2的命名空间下不存在这个函数就会报错；如果不声明name2，就会在将foo()解析为一个不在任何命名空间下的全局函数，当然，如果无法找到依旧会报错。\r\n\r\n使用非限定性的名称就会出现一种情况：如果需要使用的类名或变量是全局的，而当前文件存在命名空间，如果不加以处理，会优先将其解析为当前命名空间下，出现错误。那么，如何解决这种问题呢？这时就可以使用完全限定名称。\r\n\r\n#### 完全限定的名称\r\n在命名空间前加上全局前缀操作符`\\`，就会从全局开始，依照命名空间的层级寻找对应的变量，实际上，只需要在文件使用namespce声明命名空间名称的前面在加上`\\`就可以了（因为声明命名空间必须显式地指定命名空间的层级）。\r\n\r\n而前小节提出的问题现在也很容易解决：只需要在全局函数或类名全加上全局前缀操作符：\r\n```\r\nnamespace name2;\r\ninclude \'1.php\'; // 注意此时1.php中是不存在命名空间的\r\n\\foo(); \r\n```\r\n\r\n#### 局部限定名称\r\n局部限定名称和非限定性名称的区别就在于：在函数或类名前使用了一个不是完全限定的命名空间（没有全局前缀操作符）。\r\n此时，如果会将当前文件的命名空间存在，则会将该命名空间名称添加到所使用的局部限定名称前\r\n；如果不存在，则会直接去寻找对应名称的命名空间下的类或函数（跟非限定性名称一样）。\r\n\r\n### 文件路径的小问题\r\n注意到命名空间的一个小细节：`\\`反斜杠限定符。这个斜杠跟文件路径`/`十分相似！虽然已经写了很多次路径，也没有发现什么错误，但是决定稍微深究一下这个问题。\r\n\r\n正斜杠，又称左斜杠，符号是`/`；反斜杠，也称右斜杠，符号是`\\`。\r\n* 在Unix/Linux中，路径的分隔采用正斜杠`/`，比如`/home/index`；\r\n* 在Windows中，路径分隔采用反斜杠`\\`，比如`C:\\Windows\\System`。\r\n\r\n微软这么做的原因是：在Windows设计初期，正斜杆`/`作为DOS命令提示符的参数标志，而文件路径为了和Unix一些特征区别开，因此...(任性)。 而常见的浏览器地址使用的是正斜杠，此外，网络文件路径也必须使用正斜杠。而在windows下的文件路径，使用反斜杠来表示。\r\n然而我发现即使是在windows(win10)下，也可以使用正斜杠来访问到指定路径的正确文件。一种解释是Windows的资源管理器正确的处理了用户有可能产生的输入错误，因此就算是我们正反斜杠混合使用都是可以实现对于文件的定位。\r\n\r\n由于反斜杠也是转义符标识，所以在书写路径的时候有可能出现解析错误的情况，因此有时候也会看到`C:\\\\Windows\\\\System`这样对反斜杠先进行转义的路径写法。\r\n\r\n更新：在PHP中，预定于了一个关于目录分隔符的常量`DIRECTORY_SEPARATOR`，该变量会返回一个跟操作系统相关的路径分割符，这样就不用纠结使用正斜杠还是反斜杠的问题了。\r\n\r\n### 小结\r\n有了上面的基础，实现一个自动加载类就很简单了：需要加载的、带有命名空间的类名，传递给注册函数，在注册函数中将命名空间映射为文件路径，并加载定义该类的文件，大功告成。此外，如果考虑路径使用反斜杠，则最好对路径中的反斜杠进行转义，这里我的做法是将在使用正斜杠来表示路径（在win10下是可以正常运行的哦）。\r\n```\r\nstatic public function load($class){\r\n    $class = str_replace(\'\\\\\',\'/\',$class);\r\n    $path = ROOT.\'/\'.$class.\'.php\';\r\n    if (is_file($path)){\r\n        require_once $path;\r\n    }\r\n}\r\n```\r\n这样，只要我们将文件路径和命名空间保存一致，就可以实现自动加载了。为了方便，将这个注册函数定义为了Core核心类的静态方法。\r\n\r\n## 控制器和方法\r\n\r\n### 调用\r\n前面我们通过路由类，获取到了目标控制器和方法名；通过注册函数，实现自动加载类的功能。接下来，只需要实例控制器对象，调用指定方法就行了，这项工作放在`Core.php`核心文件中实现。\r\n```\r\nstatic public function run(){\r\n\r\n    $route = new Lib\\Route();\r\n    $ctrl = $route->ctrl;\r\n    $action = $route->action;\r\n\r\n    // 控制器完全限定名称\r\n    $ctrlName = \'\\\\\'.MOUDLE.\'\\Controller\\\\\'.$ctrl.\'Controller\';\r\n\r\n    // 加载控制器文件\r\n    try{\r\n        $ctrl = new $ctrlName();\r\n        $ctrl->$action();\r\n    }catch (\\Exception $e){\r\n        echo \'找不到控制器:\'.$ctrl;\r\n        echo $e->getMessage();\r\n    }\r\n}\r\n```\r\n现在我们在`APP/Controller/`目录下建立`IndexController.php`，并定义好相关的命名空间和类，然后访问`www.shy.com/Index/index`就可以访问相应的控制器方法了。\r\n```\r\nnamespace App\\Controller;\r\nuse Core\\Lib\\Controller;\r\n\r\nclass IndexController{\r\n    public function index(){\r\n    \t dd(\'PHP是世界上...\');\r\n    }\r\n}\r\n```\r\n这里将`Controller`目录写死并不是最明智的做法，也还没有对项目进行分组，但是，一切都从最简单的开始吧，接下来，需要处理的是\r\n\r\n\r\n### 控制器基类\r\n前面在介绍MVC的时候提到，控制器的任务分为如下两方面：\r\n* 处理传入数据（在控制器中需要对视图层的提交数据进行过滤和检测，并根据检测结果判断用户是否合法），然后将数据参数传递给模型；\r\n* 从模型获取返回数据，根据视图需要进行处理，然后将结果集赋值到页面上(assign())，并展示相应的视图页面(view())\r\n\r\n这里先看输出视图的方面，实际上，输出视图可以简化为加载相应的视图文件，然后通过`<?php echo $var ?>`进行赋值就可以了。我们将`Controller`基类放在`\\Core\\Lib`目录下，当然，命名空间也是。而关于向视图赋值方面，使用的是`extract()`将数组打散获取单个变量。\r\n```\r\nnamespace Core\\Lib;\r\nclass Controller {\r\n    public $assignArr = [];\r\n\r\n    public function assign($key,$val){\r\n        $this->assignArr[$key] = $val;\r\n    }\r\n\r\n    public function view($file){\r\n        try{\r\n            extract($this->assignArr);\r\n\r\n            $pathArr = explode(\'\\\\\',get_class($this));\r\n            $pathArr[count($pathArr) - 2] =\'View\';\r\n            $ctrName = $pathArr[count($pathArr) - 1];\r\n            $pathArr[count($pathArr) - 1] = str_replace(\'Controller\',\'\',$ctrName);\r\n\r\n            $path = ROOT.\'/\'.implode($pathArr,\'/\').\'/\'.$file.\'.html\';\r\n\r\n            include_once $path;\r\n        }catch(\\Exception $e) {\r\n            echo $e->getMessage();\r\n        }\r\n    }\r\n}\r\n```\r\n然后让`IndexController`继承`Controller`，大功告成。\r\n```\r\nclass IndexController extends Controller{\r\n    public function index(){\r\n   \t\t$this->assign([\r\n        \t\'text\'=>\'Hello　PHP\'\r\n        ])\r\n        $this->view(\'index\');\r\n    }\r\n}\r\n```\r\n\r\n### 小结\r\n就这样，简单地实现了视图文件的加载与变量赋值。上面的代码写的比较丑陋，因为我正在取舍TP关于视图文件的管理和Laravel的视图文件管理，我更倾向于后者（尽管视图文件和控制器文件在文件目录下隔了很远），这是进一步学习需要深思的问题，总之，大概的视图文件加载原理就是这样。此外，由于原生的PHP标签缺乏判断和循环等模板标签，加之我实在不想再HTML文件中书写PHP代码，，因此之前的处理方式是使用`Vue.js`，这么用`Vue`会不会被打死...\r\n\r\n## 最后\r\n现在，一个很简陋的PHP框架就搭好了，好吧，这根本算不上是个框架，不过，还是能够学到一点关于框架工作的流程。关于模型是另外一个很重要的知识点，因此打算单独整理一篇关于PDO的文章。学习一点后端知识，只是为了更好的写前端，好好努力啦！\r\n';
INSERT INTO shymean_article SET `title` = '关于CSS代码维护的思考', `created_at` = 1482851475, `category` = 'CSS', `tags` = '工程化', `content` = '\r\n\r\n最近有个项目，已经开发了近两个月，然后客户说之前他们提供的设计图不满意，然后前端页面全部重新修改，个人中心页面维持现状并作相应调整...整个人都不好了，维护CSS代码真是一件可怕的事情，尽管是自己写的。这几天被折磨的死去活来，总结了一点经验，希望以后少给自己以及后面的哥们挖坑。\r\n\r\n<!--more-->\r\n\r\n社区和论坛上到处都在谈论模块化，组件化，对于这些我只是略有耳闻，未曾深入，总觉得过于高深莫测，不太适合现在的我。就我本人而言，目前得到的关于维护CSS代码的教训有三个方面：\r\n* 组织合理的文件目录结构\r\n* 正确的样式命名和代码重用\r\n* 写文档！写文档！写文档\r\n\r\n## 文件目录\r\n之前的项目一直是按照最基本的“根据资源划分目录”，即在根目录下：\r\n```\r\n- css\r\n- js\r\n- img\r\n- fonts\r\n- ...\r\n```\r\n好吧，这是刚学切页面时所使用的目录划分。这种结构真的是太脆弱了！临时占位图片，精灵图混在一起；scss，项目CSS，外部CSS文件混在一起；不同页面的html文档也混在一起；JS这里就不说了。改个东西需要在一堆文件里面找半天。\r\n总之，要避免无法维护的风险，一定要划分一个良好的目录结构。论坛上有一种按照模块分目录的做法：将一个模块（比如登陆）相关的`html`,`css`,`js`和其他相关的文件关联在一起，修改的时候可以很轻松的定位到相关文件，但是整个页面就比较分散，（我们后台使用TP框架，用这种结构分目录很难被后端同事接受）。\r\n结合实际生成环境，我尝试采用了下面目录结构来管理页面和样式表，尽管可能还是不合理，但确实比之前要好的多了：\r\n```\r\n- css\r\n\t-  main // 用来存放编译后的CSS文件\r\n\t-  plugin // 用来存放外部插件的CSS依赖文件\r\n- img\r\n\t- tmp // 临时的占位图片，比如轮播，广告，商品头像啥乱七八糟的\r\n\t- sprite // 精灵图\r\n- scss\r\n\t- animate // 动画\r\n\t- base // 基础\r\n\t- utils // 组件\r\n\t- layout // 布局\r\n\t- page // 不同页面的布局样式\r\n\t\t- page1\r\n\t\t- page2\r\n\t- main.scss // 引入下面的各个入口文件并输出单个main.css样式表\r\n\t- _animate.scss // animate文件夹样式表的引入入口文件，下同\r\n\t- _base.scss\r\n\t- _confit.scss // 配置项目相关的变量，如基础边距，基础色等\r\n\t- _layout.scss\r\n\t- _utils.scss\r\n\t- _page.scss\r\n- html\r\n\t- page1 // 一组功能相近的页面\r\n\t- page2 // 另一组功能相近的页面\r\n```\r\n\r\n用scss写样式表，是一件让人身心愉悦的事情。这里先谈scss在目录划分中的作用。\r\n使用scss的`@import`将不同模块和功能的样式表分离，管理起来就十分方便，此外，将单个样式表的规模减小，并同意在单个入口文件中进行加载管理维护起来更加轻松，根据相应的文件名可以迅速定位到需要修改的文件（必要情况下可以添加静默注释）。在`main.scss`中按依赖顺序引入相关的样式表入口文件，编译输出到`/css/`文件夹下。\r\n\r\n分离的样式表实际上也可以按照某些的规律归拢在一起。\r\n\r\n### 基础样式\r\n在之前的工作中，我整理了关于自己的一套基础样式，包括：\r\n* `_reset` 样式重置，选择性的重置部分标签（我一般都是表单元素和盒子模型）\r\n* `_css3` 主要定义了一些CSS3属性混合器，之后就不用书写浏览器前缀了，实际上在webstrom中安装了prefix之后是可以不用再考虑前缀的问题，看个人习惯\r\n* `_color` 定义页面相关页面的变量，以及背景色和字体色颗粒类，防止某些抽疯的需求，其他样式表中不要再出现独立的颜色\r\n* `_font` 定义字体相关的变量和属性\r\n\r\n上面这些基础样式都保存在`scss/base`文件夹下，除了`_color`和`_font`，其余的基础样式表改动可能都不大，所以我们可以使用优秀的样式库来实现。比如，使用[Normalize.css](http://necolas.github.io/normalize.css/)来代替`_reset`\r\n\r\n### 动画样式\r\n如果某些`duang`的特效需要编写动画，则最好单独放在一个文件夹中，因为动画一般是比较独立的，又需要较多的代码量，还需要一些其他的兼容处理，单独在一个文件中比较容易管理，也预防日后需求变更，或者是积累代码日后重用。\r\n\r\n### 布局样式\r\n根据项目的需求和运行平台，可以大致确定项目的整体布局，是固定布局还是栅格布局，又或者是rem或flex布局。关于后面三种布局方式，我整理了单独的文件，根据需要在项目入口文件`_layout`灵活引入。\r\n\r\n### 组件样式\r\n实际上我对于组件啊模块啊的概念仍处于一个比较模糊的概念。我对于组件的理解是：同时出现在多个页面的某种特定元素及其子元素所组成的布局和样式。简而言之就是抽取出可复用的代码，比如`tabs`，`collapse`，`btn`这些重复出现的HTML结构及样式。\r\n`utils`文件夹下主要存放的就是各个组件的样式，每个组件都被`_utils.scss`文件引入，然后在`main`文件中引入`_utils`\r\n。在切图之前，应该大致先浏览全部的设计图，明确哪些地方是可以重用的组件，心中有数才开始写代码，比一上来就从首页开始，从上到下，从左到右闷头写要好的多。\r\n另外，随着代码量的增加，甚至可以抽取出多个项目公用的组件样式，通过在入口文件控制是否引入，另外由于单个组件样式位于独立的文件，定位和修改就十分方便了。。\r\n\r\n### 页面样式\r\n尽管每个页面的样式细节可能不太一样，但按照整体布局或者逻辑功能也可以将他们进行分组。比如一个商城：\r\n* 登陆注册（注册，登陆，验证...） - 功能\r\n* 首页 - 独立\r\n* 热门，新品，折扣（统一的侧边栏、主界面宽度，广告...） - 排版\r\n* 购物车（订单，支付...） - 功能\r\n* 页眉，页脚 - 排版\r\n\r\n根据页面的分组，定义相关页面的容器名称，或是使用`%`定义相关的父类选择器提供继承继承。\r\n\r\n## 样式命名重用\r\n之前花了很多时间思考选择器的命名，最后是参照[NEC](http://nec.netease.com/standard/css-practice.html)\r\n* `g-`布局\r\n* `m-`模块\r\n* `u-`元件\r\n\r\n呃好吧，这个命名规范我现在仍处于摸索阶段，也遇见了一些坑，比如：布局命名`.sec-hd`和模块子元素命名`.tab-sec .sec-hd`这里就冲突了。不过，使用`hd`,`sd`,`mn`这些，确实能大大提高选择器命名的时间，之前一个名字真的要想很久。\r\n\r\n至于样式重用，也有一个比较蛋疼的地方：正确的抽取出公共样式，并在页面上很多地方都用上了，用的很爽，然而某一天，需求改了，某个地方的样式需要改动一下，此时，一不小心就会改动到很多地方（这就是错误使用样式重用的一个体现），这种情况下，可能只能小心翼翼地添加类名限制，进行样式覆盖，代码越来越多，越改越难（我现在这个项目就发生了这个情况...）。\r\n\r\n## 写文档\r\nCSS有什么文档好写的？一个月前的CSS代码，真的只有上帝知道是怎么回事了。\r\n在拿到设计图和需求文档之后，应当先大致整理整个项目的流程，后端同事是按照页面写逻辑的，在动手写页面之前就应该由我们剔除设计图上的坑（多余的功能，难以实现的分页等），并把项目的逻辑理顺，这不仅仅是为了后端，更是防止日后页面的大改动（逻辑一改页面肯定跟着动的）。而整理项目的逻辑和流程，除了依靠最原始的需求文档，我觉得我们也应该考虑书写前端的开发文档，包括项目的功能模块分类，技术选择等。\r\n另外，浏览设计图时，将公共样式，页面的分组，JS的模块等也记录在文档中，方便日后的维护。此外也可以在样式表中适当添加一些注释，真的，肯定有用到的时候！\r\n\r\n## 其他\r\n此外还有两个小小的心得。\r\n* 前面切好的小图标没有必要就直接做成精灵图，等待项目快上线的时候再弄（使用[工具](http://www.cn.spritegen.website-performance.org/)快速生成）可以节省大量的重复修改时间\r\n* 能定义变量就定义变量，不要再其他的样式表中出现独立的诸如颜色之类的属性值，一个该死的需求会气死人的！（我会说客户把LOGO都改了然后页面全部颜色都替换吗？幸好机智地存了变量！）\r\n\r\n任重而道远啊。';
INSERT INTO shymean_article SET `title` = '关于CSS选择器命名的思考', `created_at` = 1473255911, `category` = 'CSS', `tags` = '代码格式', `content` = '\r\n初学CSS之时，对选择器命名不屑一顾，心想不就是拼个单词吗？实在不行谷歌翻译一下就完事儿了。现在想想，真是可笑至极。选择器命名可以说是样式重用的基础，而最近面对一个几千行CSS代码的项目，大量的时间被耗费在选择器命名上，实在是再也不能忍受了。看了不少博客，也问了数位前辈，一直没能得到满意的答案。\r\n今天这篇博客，就草草总结一下工作两个多月以来被CSS选择器命名折磨所得到的感悟。\r\n<!--more-->\r\n## 原则\r\n\r\n### 样式重用\r\n#### 不要使用id选择器\r\n尽管处于同一个页面上的多个元素同时具有相同的id，其样式也会正确显示（在谷歌火狐等浏览器上进行测试），也就是说浏览器实际上并不会检测id的唯一性。然而，尽管如此，那么为什么不直接使用class选择器呢？\r\n* 在页面上使用多个同名的id选择器，会给Js挖一个很大的坑（JS只会获取到第一个id元素）;\r\n* 在页面上使用唯一的id选择器，由于规范限制，会导致该id选择器的样式无法被其他元素公用，毫无重用性可言。\r\n\r\n因此，在不能确保页面上是否会出现类似样式的元素时，不要对已有样式设置id选择器！\r\n\r\n#### 慎重使用语义化的选择器名称\r\n语义化选择器带来的好处就是可以直观地了解对应元素在页面中的扮演角色及对应的作用，比如.head,.banner等等，清晰明了。但是，随之而来的问题，却也是我最大的困惑：\r\n总不能在页脚区域写上.header这样的类吧（即使他们的样式十分相似），原本的语义化确限制了样式的重用。没错，的确可以在页脚区域写.header样式，浏览器也会正确显示，JS也没有问题，但是，你真的不觉得别扭吗？\r\n也许，你还会说，页首跟页尾的样式相同的概率没那么大吧？嗯，对的，那么想象一下，页面中有两个或者数个版式相似的区域，他们都有带下划线的标题，红色的边框，放上了数目不等的几张正方形图片，只是图片所代表的内容不同而已，这些区域放置了“旅行”“生活”“工作”balabala之类，难道要给每个区域都给上对应的\".travel\",\".life\",\".work\"么？\r\n也许分组选择器可以解决这个问题，我们还会沾沾自喜，使用一个逗号就完成了样式的复用。相信我，日子长了，你肯定会厌烦为每一个区域都绞尽脑汁地想对应的语义化名称的！\r\n\r\n#### 不要使用上下文相关联的标签选择器\r\n后代选择器允许我们根据元素的上下文关系来确定某个标签的样式，而无须指定class或id。首先必须承认，这是一个十分方便且强大的选择器，我们可以轻松加愉快地为目的元素加上样式，选择器命名什么的见鬼去吧。那么，选择器命名的问题就此终结了？怎么可能！\r\n假定有这么一个选择器ul .item，这表示为ul标签下的所有item类指定对应样式，当其他的某个地方也需要同样的样式时，却被其父元素必须为ul给定死了；或者是.items li，只有同为li的元素才能公用.items下的li样式。这意味着，复用这些样式，必须指定同样的DOM结构。并且.items下的所有li，包括li下的同为li的子元素也会获取同样的样式，也许\">\"是一个办法，然而，这只是使用上下文相关联的选择器所带来的弊端之一。\r\n虽然在部分情况下，样式重用的区域，他们的DOM层次确实相似。但是，当样式与结构互相纠缠在一起的时候，如果需求被更改，意味着不仅样式被更改，页面结构也会发生更改（深受折磨，唯有泪千行）。\r\n\r\n#### 小结\r\n也许过分纠结样式重用是一件费力不讨好的事儿，大不了就是多写几个类罢了嘛...然而我对于此却一直耿耿于怀。随着项目经验的增加，模模糊糊感受到了模块化页面的必要性，然而却一直没有完整的概念。\r\n\r\n### 便于维护\r\n“改不完的需求”是工作以来感受最深的一件事情，面对页面无休止的更改，到后面的css文件，被我瞎搞的面目全非，在项目开始还特别注重的样式规范，修改过程中被完全抛在脑后：为了解决样式冲突添加了各种页面样式甚至行内样式，还不得不提心吊胆万一更改到了某个重复的样式导致其他页面样式爆炸的情形；或者是为了不影响之前的代码，干脆又重新新建一个类吧，导致的结果就是样式表中多了许多重复的代码，或是DOM元素完全被移除其类名仍然存在于样式表的情况，周而复始，恶性循环。\r\n\r\n#### 简洁的类名\r\n都说“一个好的选择器命名，应当清晰明了，让刚接手项目的人也能明白其用途\"，然而，这句话本身就很难理解，什么是清晰明了？\r\n我所理解的清晰明了，并不是上面所谈论的具体语义化，而是该类名所代表的功能化。比如bootstrap中的.container和.container-fulid这两个名称，表达的是这个元素代表一个容器，至于是哪个具体区块下的容器，完全没有必要知道，如果使用.person-wrap这样的类，哎...\r\n\r\n#### 使用单一化功能的类\r\n功能越是单一的类，越容易被复用，且越容易被修改，同样的bootstarap中，比如文本对齐.text-center这样的类，如果页面中大量存在文本居中的情况，不妨将这条属性单独为一个类，这样，如果是某个时刻需要将左对齐更改为右对齐，只需要更改对应元素的类名就可以了。\r\n那么，什么才算是单一化功能呢，比如一个特殊的文本颜色.text-red，一个公用的竖直边距.mb20，都可以很独立为一个类并应用在对应的元素上。\r\n但是，这样做的缺点也很明显，如果滥用，会导致一个元素上挂上N多个类，增加页面大小还是次要的问题，如果需要修改的时候，这种情形会变得十分尴尬：比如需要将所有mb20(margin-bottom:20px)的元素底外边距更改为30px,是再单独新建一个.mb30，然后替换页面上所有的.mb20；还是直接将mb20的属性值改为30px，这样挂羊头卖狗肉的装作什么事都没有发生。\r\n初次在张鑫旭大神的博客中见到这种面向属性的命名方法，觉得十分神奇，然而遇到需要修改的时候，也变得十分蛋疼，原文的建议是：不要对任何任何网站通用的样式进行分离！\r\n所以，转念想想，只要不滥用单一功能化的类，如下定义一个完全居中的类，大概也是可行的吧！毕竟竖直居中这样的功能类，改动的几率会小那么一丁点，即使要修改某个元素，直接去掉这个类就可以了。\r\n```\r\n.vertical-center {\r\n\tposition: absolute;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    margin: auto;\r\n}\r\n```\r\n\r\n### 充分利用继承属性\r\n比如字体的大小，颜色，文本的行高这些属性，完全只对其父元素的类进行设置，并通过继承的方式传递给子元素，这样在修改的时候也可以减轻部分工作量，如果是大段相同的文本样式，设置可以在样式重置时设定，或者是单独剥离出一个文本类。\r\n\r\n#### 小结\r\n无休止的修改会带来无穷的噩梦，如果没有良好的规范和习惯，在反复地折腾下，样式表肯定会被我玩坏的。也许提前预知哪些地方将会被修改并做好准备，就可以躲过一劫，然而，提前预知不是超能力吗？\r\n\r\n## 方法\r\n\r\n上面吐槽了半天，却一直没有提到解决的办法。搜索了大量的资料和样式库，加上最近一直在使用scss，参考网易的[NEC的css命名规范](http://nec.netease.com/standard/css-name.html)，整理了一下内容：\r\n* 在类名前加上前缀，作为其命名空间：\r\n\t* 布局（grid）（.g-）；\r\n\t* 模块（module）（.m-）；\r\n\t* 元件（unit）（.u-）；\r\n\t* 功能（function）（.f-）；\r\n\t* 皮肤（skin）（.s-）；\r\n\t* 状态（.z-）。\r\n* 关于上面的命名空间，也许并没有必要完全照搬，如果项目多人协作，我自己经常使用的.t-，在选择器前加上姓名缩作为前缀，这样可以有效防止选择器冲突，当然，前提是确定没有使用同一姓名前缀的同事。\r\n* 作用于页面布局的类，不能是后代选择器，因为后代选择器存在依赖父级元素的情况，将来被污染的可能性比较大\r\n* 命名应简约而不失语义，这里的语义应当是功能化语义（描述这个选择器的作用），而不是具体到该元素的实际名称，比如应当是(一个文章列表采用m-list而不是article-list)。\r\n* 使用数字为具有相同语义的不同类命名，比如.m-list-1，.m-list-2（PS：之前就一直使用这种命名，需要及时注释防止过一段时间后就忘记了，此外，最好不要对颗粒化的类采用该条规则，因为颗粒化的类所附带的样式规则本身就很少，采用具体的语义化更合适，比如bg-red而不是bg-color-1）\r\n* 如果几个类的类型相同且样式相似区别不大时，将他们的公有样式抽离成单独的基类（可作为SCSS选择器继承的父类），比如基类.btn，可拓展.btn-default...这样的形式\r\n* 如果你的模块或元件可能嵌套或被嵌套于其他模块或元件，那么要慎用标签选择器，必要时采用类选择器\r\n* 各种常见元素的[命名缩写](http://nec.netease.com/standard/css-practice.html)，参考的也是网易NEC的规范，比如使用hd(head),bd(body),sd(side),mn(main),ft(foot)来划分某个具体的区块，使用作为具体元素的后缀修饰等\r\n\r\n最后，也是最重要的一点：在动手写页面之前先规划页面整体结构，搭建好布局DOM，抽离公用的结构和样式，使用合适的标签和类名，而不是边写边想，杂乱无章，这是被自己的CSS代码恶心到之后最大的收获。“磨刀不误砍柴工”用在这里，大概是非常合适的。\r\n立帖为证，关于上面的规范，在今后的工作中，一定会谨记的，如果违反了请打死我吧(-_-||)。\r\n* ';
INSERT INTO shymean_article SET `title` = '使用Hexo', `created_at` = 1471745945, `category` = '工具', `tags` = 'Hexo', `content` = '\r\n\r\nHexo是基于Node.js的静态博客框架，可以很快速地搭建个人博客。\r\n今天把自己的博客整个搬到了Hexo，挂在github上，真是累死人了，准确的说是累并快乐着。改天抽空自己改主题吧，先用着Next的主题也是极好的...\r\n<!-- more -->\r\n\r\n\r\n## 配置环境\r\n以下操作均在Windows10下进行。\r\n* 需要安装Node.js环境，直接上官网下载即可，我使用的版本是V4.4.4稳定版。\r\n* 需要安装Git环境，后面可以直接将博客挂在github上面\r\n\r\n## 安装Hexo\r\n新建一个文件夹（名称最好不要使用中文），进入文件夹并打开git bash，按顺序执行下列操作：\r\n```\r\nnpm install -g hexo //安装Hexo\r\nhexo init //初始化Hexo\r\n//请耐心等待相关文件下载，当控制台出现下列信息说明安装成功\r\nINFO Start blogging with Hexo\r\n```\r\n## 使用Hexo\r\n\r\n### 生成静态页面\r\n```\r\nhexo generate\r\n```\r\n\r\n### 本地预览\r\n首先开启本地服务器，默认端口号为4000\r\n```\r\nhexo server\r\n```\r\n然后在浏览器中输入 http://localhosr:4000/ 预览本地博客。\r\n\r\n### 更换主题\r\nHexo支持多种主题，可以从github的众多项目中选择你自己喜欢的，然后将项目克隆到themes文件夹下\r\n```\r\ngit clone https://github.com/iissnan/hexo-theme-yilia.git themes/nextTheme\r\n```\r\n然后修改主目录下的 **_config.yml** 文件中的 theme 属性值为刚才保存的主题文件夹名称 nextTheme 即可；\r\n\r\n在切换主题之前，最好使用 __hexo clean__ 来清除Hexo的缓存，然后重新生成静态页面并发布;\r\n\r\n关于相关主题的具体使用，建议查看其使用文档。\r\n\r\n### 新建页面\r\n每个主题所给定的导航栏可能不一样，比如现在我使用的Next主题，默认并未开启标签页面，此时可根据自己需要新建页面：\r\n```\r\nhexo new page \"pageName\" //新建页面\r\n```\r\n注意此时需要修改**主题配置文件**在导航栏开启页面的链接。\r\n默认会生成一个index.md，可以将其删除之后新建index.html并将其修改成自己喜欢的风格\r\n\r\n## 将Hexo部署到github上\r\n部署之前，需要首先创建项目仓库，名字只能使用如下格式：\r\n```\r\nyourname.github.io //将yourname替换成你的github的名字\r\n```\r\n然后需要修改主目录下的_config.yml文件中的 deploy 属性值为下面格式：\r\n```\r\ndeploy:\r\n  type: git\r\n  repository: git@github.com:tangxiangmin/tangxiangmin.github.io.git //改为自己的项目路径\r\n  branch: master\r\n```\r\n然后发送部署命令\r\n```\r\nhexo deploy\r\n```\r\n待部署完成之后，在浏览器中输入 tangxiangmin.github.io 就可以看见整个博客了，然后就尽情的折腾去吧\r\n\r\n## 进阶\r\n### 几个快捷命令\r\n```\r\nhexo g ==  hexo generate\r\nhexo d ==  hexo deploy\r\nhexo s ==  hexo server\r\nhexo n ==  hexo new\r\n```\r\n\r\n';
INSERT INTO shymean_article SET `title` = '再探原型和闭包', `created_at` = 1479051899, `category` = 'JavaScript', `tags` = '原型, 闭包', `content` = '\r\n最近看见一篇关于原型和闭包的博文，十分精彩，传送门：[深入理解javascript原型和闭包（完结）-王福朋](http://www.cnblogs.com/wangfupeng1988/p/3977924.html)。看完有种茅舍顿开的感觉，之前自己总结的原型链和闭包，实在是有失偏颇，因此在参考这篇文章，重新整理了原型链和作用域链的知识，加以巩固。\r\n<!--more-->\r\n## 原型链\r\n\r\n### 原型\r\n所有的对象都是由其构造函数创建，基础对象最基本的构造函数是Obecjt()。    \r\n每个对象都有一个\" __ proto__ \"的属性，指向该对象构造函数的原型，该属性也被称为隐式原型。    \r\n每个函数都有一个\"prototype\"的属性，表示这个构造函数的原型，函数的原型实际上是一个对象，并且该对象有一个construct的属性，指向构造函数本身。\r\n\r\n同时，由于函数也是对象，所有函数的构造函数都是Function()。函数的隐式原型就是Function()的显式原型。\r\n甚至连Object()函数的构造函数都是Function()，假设存在构造函数Aoo()和其实例化对象a，存在下面的关系：\r\n```\r\na.__proto__ == Foo.prototype; // 对象的隐式原型指向其构造函数的显式原型\r\n\r\nFoo.__proto__ == Function.prototype; // 函数的构造函数是Function()\r\n\r\nFoo.prototype.__proto__ == Object.prototype; // 原型也是一个对象，对象的基本构造函数是Object()\r\n\r\nObject.__proto__ == Function.prototype; // Object()函数的构造函数也是Function()\r\n\r\nFunction.__proto__ == Function.prototype; // Function()函数是被自身创建的-_-\r\n\r\nFunction.prototype.__proto__ == Object.prototype; // Function()的原型也是对象\r\n\r\nObject.prototype.__proto__ == null; // Object.prototype 是第一个对象，所有对象的基础属性和方法都源于此,所以他的隐式原型是null。\r\n\r\n```\r\n### 继承\r\nJS中的继承是通过原型链来体现的：访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。\r\n如果将构造函数A的原型是构造函数B的实例对象，则A的实例对象就可以通过A.prototype获取到b的属性和方法（因为A.prototype == b）。\r\n可以使用hasOwnProperty方法来判断一个属性到底是实例对象的还是其原型的。\r\n    \r\n可以通过使用instanceof来判断两个类是否存在继承关系，其规则为：  \r\n沿着左操作数的__proto__这条线来找，同时沿着右操作数的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。   \r\n通过上面的关系，就可以解释下面的问题了：\r\n```\r\nconsole.log(Object instanceof Function); // true \r\nconsole.log(Function instanceof Function); // true\r\nconsole.log(Function instanceof Object); // true\r\n\r\n```\r\n\r\n## 闭包\r\n### 环境上下文\r\n环境上下文，分为全局上下文和函数上下文：\r\n* 全局上下文中的数据内容包括\r\n    * 普通变量声明\r\n    * 函数声明\r\n    * this\r\n* 函数上下文中的数据内容除了上面三种情形，还包括\r\n    * 参数\r\n    * arguments\r\n    * 自由变量（指不在该上下文中声明的变量）\r\n\r\n所谓的执行环境上下文，指的是：在执行代码之前,解析器会进行变量声明提前，也就是说会把这段代码将要用到的所有变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。\r\n* 变量、函数表达式声明，默认赋值为undefined占位；\r\n* this——赋值；\r\n* 函数语句声明——赋值；\r\n\r\n### 上下文栈\r\n下面是代码执行的大致过程：\r\n1. 在加载程序时，已经确定了全局上下文环境以及执行上下文（变量声明提前等准备工作），并随着程序的执行对变量进行赋值。    \r\n2. 在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。因此，函数每被调用一次，都会产生一个新的执行上下文环（即使是同一个函数（甚至是相同参数），在不同的调用下产生的上下文环境也是不一样的）。    \r\n3. 当程序运行到将要调用函数的时候，会生成该函数的上下文环境，然后将此上下文压入上下文环境栈并设置为活动状态。  \r\n4. 然后执行函数内部的代码，如果遇见函数调用则重复上述步骤：产生新的上下文->入栈并设置为活动状态->执行函数代码; \r\n5. 当这个函数调用完毕,则其上下文环境被销毁，从上下文环境栈弹出，此时程序又回到了其父作用域下的上下文环境，并在栈中将其置为活动状态\r\n6. 按照此过程进行，到最后上下文环境栈中只剩下了全局上下文环境（当然这是在没有闭包的情况下）\r\n\r\n### 函数内部的数据内容\r\n上面提到，函数上下文中的数据内容，除了普通变量声明，函数声明和this之外，还多了参数，arguments对象和自由变量。\r\n#### 自由变量\r\n自由变量的定义：在fn函数中使用的变量x，却没有在A作用域中声明，对于fn函数作用域来说，x就是一个自由变量。  \r\n函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。\r\n```\r\nvar a = 10;\r\nfunction fn(){\r\n    console.log(a);\r\n}\r\n\r\nfunction foo(f){\r\n    var a = 20;\r\n    f();\r\n}\r\n\r\nfoo(fn); // 10\r\n```\r\n#### this\r\n跟自由变量不同的是，函数内部的this取何值，是在函数真正被调用执行的时候确定的，因为函数定义的时候根本确定不了。\r\n\r\n* 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象,在原型链中，this代表的也都是当前对象的值;但是如果直接把构造函数当作普通函数调用，则其的this会变成window\r\n* 如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象;但是如果方法函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，此时就无法在函数中使用this获取原对象的属性\r\n* 当一个函数被call和apply调用时，this的值就取传入的对象的值\r\n* 全局环境下，this永远是window,普通函数在调用时，其中的this也都是window\r\n* 闭包函数中的this也是window。\r\n\r\n### 作用域\r\nJS中只有全局作用域和函数作用域，并没有“块级作用域”的概念，函数作用域是在函数定义时生成的。    \r\n作用域只是一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。牢牢记住，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。  \r\n\r\n作用域内部声明的变量（包括参数）会覆盖掉外部的同名变量，这正是我们需要的。那么，程序是如何确定作用域下的某个上下文中所使用的自由变量呢？\r\n\r\n前面提到过：函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。  \r\n在fn函数中，取自由变量x的值时，要到创建fn函数的那个作用域中取,无论fn函数将在哪里调用。 如果跨了一步，还没找到呢？接着跨！一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。\r\n\r\n这个一步一步“跨”来寻找自由变量的路线，就是我们常说的“作用域链”。\r\n\r\n### 闭包函数\r\n了解了作用域链，理解闭包就十分轻松了。关于闭包，有一个不那么精准的定义：一个作为函数返回值或者函数参数的函数。\r\n```\r\n// 作为函数返回值\r\nfunction fn(){\r\n    var a = 100;\r\n    return function foo(x){\r\n        if (x > a){\r\n            console.log(\"more\");\r\n        }else {\r\n            console.log(\"less or equal\");\r\n        }\r\n    }\r\n}\r\nvar a = 10;\r\nvar f = fn();\r\nf(50); // \"less or equal\"\r\n\r\n// 作为参数\r\nvar a = 10;\r\nvar fn = function(x){\r\n    if (x > a){\r\n        console.log(\"more\");\r\n    }else {\r\n        console.log(\"less or equal\");\r\n    }\r\n}\r\n\r\n!(function(f){\r\n    // 这里的闭包是形参f而不是实参fn，fn只是一个普通的函数表达式声明的函数\r\n    var a = 100;\r\n    f(50); // \"more\"\r\n})(fn);\r\n```\r\n\r\n在前面的上下文栈中提到：当函数调用结束，其执行上下文将从上下文栈中弹出并被销毁，其中的变量也随之被销毁，这里的例外就是闭包。\r\n\r\n由于闭包函数是在函数内部定义的函数（函数可以创建一个独立的作用域），因此如果在闭包中使用其定义函数上下文中的自由变量，或者在其他地方调用该函数，则必须保证其定义函数的执行上下文仍然存在（如果跟普通的函数一样调用结束就被销毁，则就无法找到其中的数据内容了。），所以如果函数上下文中存在闭包，则在调用结束之后不会被销毁，而是保存在上下文栈中（尽管活动状态已经被切换为上一层），而之所以说使用闭包会增加内存开销，就是这个原因。\r\n\r\n总之，理解闭包，弄清楚环境上下文和作用域链是十分必要的，此外，牢记“__函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域__ ”。\r\n\r\n## 最后\r\n这个世界上有无数优秀且勤奋的人，然而我并不是其中的一个。感谢这么多前辈愿意在互联网上分享自己的学习笔记和心得，我现在能做的就是抓紧学习，希望有朝一日也能为社区的发展贡献绵薄之力。加油吧！\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '关于img的两个小问题', `created_at` = 1465906708, `category` = 'CSS', `tags` = 'Bugs, 样式', `content` = '\r\n在实际练习中使用图片时经常碰见两个问题：图片的实际高度与换行。今天把在坑里面得到的收获整理一下。\r\n<!--more-->\r\n\r\n## 图片容器的高度\r\n关于图片高度的问题已经碰到过很多次了，以前还以为是兼容问题，简单的加上一个img {display block}就能够解决了，后来才明白问题的根源弄错了。先简单的描述一下问题：在默认情况下，当一个容器的高度是由内部的图片内容撑开的时候，其高度会比图片的实际高度会多出几个像素（3px？）。嗯，就是这么个小问题：\r\n```\r\n    <div class=\"wrap\">\r\n        <img src=\"1.png\" />hello\r\n    </div>\r\n```\r\n右键查看盒子模型可以很清楚的看见这个问题。最初百思不得其解，还以为是什么神奇的BUG，其实这是文本渲染正常显示的结果。为了搞定这个问题，需要了解两个知识点：img标签的vertical align属性和字体的基准线baseline。\r\n### baseline\r\nbaseline是西文字体中的概念，百科的定义是大部分字母所“坐”在的，字体的下降部之上的直线（好吧这个解释感觉很扯淡，转念想一想以前抄写单词的时候用的四线行练习本，有基线这个概念的够了。）中文采用的是宫格排版，因此没有基线概念（是不是由于以前的排版都是竖着的缘故...）。\r\n\r\n### vertical-align\r\nimg标签是一个内联-块状元素，当然这个跟该问题的牵连并不是很大。我们的目光应当放在其具有的vertical align属性上。这个属性直译为“竖直方向上对齐”，对齐指的是相邻的内联元素排版时定位参照的方式，对应的值有bottom,top,middle等，而默认的值就是上面提到的baseline。baseline距离文字的底部bottom有一定的高度（bottom和top之间的距离是行高，baseline和bottom之间的距离就是问题中所多出来的那几个像素，即使图片旁边并没有文字，也会按照默认的格式进行排版从而产生间距）。\r\n关于vectical-align这个问题，[这篇文章](https://css-tricks.com/what-is-vertical-align/)写得更加全面。\r\n\r\n### 解决方案\r\n图片排版多出来的这几个像素，表面上也没有什么影响，但在某些情况下会造成难以排查的BUG，比如浮动的块会卡住后面的浮动元素（饱受摧残，引以为戒，泪奔中）。\r\n知道了问题的根源，解决这个问题就很容易了：\r\n* 简单粗暴法：既然是文字排版的问题，对img使用display:block真是一劳永逸啊。缺点是会让其旁边的文字换行，适合单纯的只是为了消除多出来的那几个像素的情况下；\r\n* 追根溯源法：改变vectical align默认值为bottom,middle等需要的属性值，或者是vectical-align:-3px，完美解决；\r\n* 旁门左道法：设置其父容器的font-size大小为0，缺点是字没了；或者是line-height为0，字样旁边文字的基线以下部分会溢出容器。\r\n\r\n## 莫名奇妙的间隙\r\n在写代码的时候通常使用换行加缩进等方式增加阅读性，导致两个相邻的图片之间存在了一条莫名奇妙的间距，并且在盒子模型中还看不见任何margin的存在（不要说了，都是泪...）。这就是img标签内嵌-块状元素中的“内联”属性在作怪，并没有什么知识点可言。\r\n### 解析换行\r\n其实不单是图片，所有内联元素及内联-块状元素都会解析在HTML文档中的空格与换行，只是由于有了“代码的格式只会影响代码阅读性，不会影响代码的运行结果”这种先入为主的念头，因此一直没有重视罢了。\r\n### 解决方案\r\n那么，怎么解决换行所产生的间距呢？有下面几个方法：\r\n* 为内联-块状元素的父容器指定其font-size:0，并显示指定子元素的字体大小（在需要的情况下比如文本框等），这样可完美解决这个问题。\r\n* 不换行或者不使用空格，这样间距自然也就消失了，但是，代码的阅读性大大下降，并不可取（除非项目上线前进行代码压缩的时候）；\r\n* 借助换行的空注释连接两行，会在HTML文档中产生大量的注释，而注释本身又是为了加强代码的阅读性的，因此并不可取；\r\n* 使用负的margin值可以达到目的；\r\n* 此外还有一些其他的方法，比如负的letter-spacing和word-spacing等。如果要从完全解决解析换行的问题，可以使用浮动。\r\n\r\n## 总结\r\n上面两个问题可以看作是图片元素所具有的内联文本的一些默认规则，需要小心提防。';
INSERT INTO shymean_article SET `title` = '初识gulp', `created_at` = 1474469201, `category` = '工具', `tags` = 'gulp, 工程化', `content` = '\r\n\r\n前端技术日新月异，现在在工作中也尝试着使用一些工具简化业务开发，比如Koala来编译SCSS，使用图好快来压缩图片等。这些工具十分方便，但是也存在一个问题：面对不同的需求需要尝试使用不同的工具，而各个工具之间却没有任何之间联系，相当于我们仍然要手动管理最基本的流程，这样就不可避免地会出现错误。碰巧最近被一个规模比较大的项目搞得心烦意乱（前期没有进行管理规划），痛定思过，开始捣鼓gulp。\r\n\r\n<!--more-->\r\n\r\n文章参考：\r\n* [gulpjs](https://github.com/gulpjs/gulp)\r\n* [gulp中文网](http://www.gulpjs.com.cn)\r\n\r\n## 基础\r\n\r\n### 安装\r\n首先需要安装NodeJs环境，某些插件可能还需要其他环境（比如compass需要ruby），然后全局安装gulp，最后在项目目录下安装位本地依赖模块。\r\n\r\n```\r\n// 全局安装\r\nnpm install --global gulp\r\n\r\n// 项目目录安装,首先新建一个package.json\r\nnpm init\r\n\r\n// 安装本地依赖\r\nnpm gulp --save-dev\r\n\r\n// 最后安装实际需求的相关插件\r\nnpm install gulp-livereload --save-dev\r\n```\r\n\r\n### 配置任务\r\n安装成功之后，需要在项目文件夹根目录下创建一个名为`gulpfile.js`的文件，这个文件可以理解为gulp的配置文件，我们需要这个文件中引入相关插件，并指定任务需求\r\n\r\n```javascript\r\nvar gulp = require(\"gulp\");\r\n\r\n// 创建一个hello gulp的任务\r\ngulp.task(\'default\', function() {\r\n   console.log(\"hello gulp!\");\r\n});\r\n\r\n```\r\n\r\n在项目文件夹下打开控制台（windows下直接`shift + 右键`），输入`gulp default`，就会执行刚才的default任务，由于是default，因此该任务不需要指定任务名，直接敲入gulp也会执行。\r\n\r\n### 简单思考\r\n工作中简单反复的机械工作，比如编译SCSS，压缩文件，刷新浏览器等等，这些工作可以抽象成下面步骤让计算机自动处理：\r\n* 监听文件的变化用来触发任务处理函数；\r\n* 获取对应文件的内容，然后进行相关处理；或者只是简单执行某些逻辑操作；\r\n* 如果需要的话，将处理后的文件输出到某个文件；\r\n\r\n举个实例，比如我们需要将某些文件的内容拷贝到同一个文件下。如果需要挨个打开文件去手动复制粘贴，这肯定不是我们这些懒人的做法，因此我们可以用node写一个程序，读取相应文件夹下的文件内容，然后再依次追加到输出文件中。\r\ngulp正是用来帮助我们实现这些事情的，更好的是，gulp本身提供的API和数量庞大的插件，可以很轻松地帮助我们完成工作，且不用关注具体的实现。\r\n\r\n\r\n## 语法\r\ngulp只有5个API：task,src,dest,watch和pipe，为我们提供了文件操作和观察的接口，通过组合使用这几个接口，我们基本上就可以实现大部分需求了。\r\n但是，在学习这些接口之前，让我们先了解glob参数类型，这是gulp用来匹配我们需要处理的文件的手段。\r\n\r\n### glob\r\nglob实际上就是一种精简版的正则表达式，详情见[文档](https://github.com/isaacs/node-glob)，下面是基本的语法：\r\n* `*`表示匹配或多个字符\r\n* `?`表示匹配一个字符\r\n* `*.*`匹配如：[hello.txt,123.doc];`?.*`匹配如：[1.css,2.js];`*.gif`匹配如：[x1.gif,2.gif]\r\n* `[...]`匹配括号内的字符，如果其中第一个字符是`!`或者`^`则表示取反，即不匹配括号内的字符\r\n* `!(pattern|pattern|pattern)` 匹配不包括分组中的表达式\r\n* `?(pattern|pattern|pattern)`匹配0次或一次\r\n* `+(pattern|pattern|pattern)`匹配一次或多次\r\n* `*(a|b|c)`匹配0次或多次\r\n* `@(pattern|pat*|pat?erN)`完全匹配\r\n\r\n哈，确实像是精简版本的正则表达式，在gulp中，使用glob格式的字符串用来匹配相应的文件或文件夹的路径，这是整个自动化的基础。\r\n\r\n### API\r\n__gulp.src(globs[, options])__\r\n`gulp.src(\'test/*.md\')`，第一个参数接受一个golb模式的字符串或者数组，用于指定文件路径，并根据这个路径输出相应文件流（官方文档中成为stream），一般地会将这个文档数据流传递给其他插件进行处理（这个过程被称为pipe，跟前面的stream相呼应哦）。\r\n\r\n\r\n__gulp.pipe()__\r\n这个方法的参数接收某个插件，并且把gulp.src的输出作为该参数插件的输入，可以进行链式调用。\r\n```javascript\r\n// minify如名所示，是一个压缩插件\r\ngulp.src([\'1.md\',\'2.md\']).pipe(minify())\r\n```\r\n\r\n__gulp.dest(path[, options])__\r\n我们通过dest方法来接收相关插件进行处理后的新数据流，这个方法的参数表示匹配一个或多个文件夹（没错，可以是多个文件夹，且均是相对于gulpfile的相对路径，可以通过第二个参数的cwd属性配置），并将数据输出到这些文件夹下面，如果某文件夹不存在，将会自动创建它。\r\n同理，关于文档流的步骤，我们均可以使用链式调用来书写。\r\n```javascript\r\ngulp.src(\'test/1.md\')\r\n\t.pipe(plugin1())\r\n    .pipe(plugin2())\r\n    .dest(\'build\');\r\n```\r\n\r\n__gulp.task(name[, deps], fn)__\r\n用来注册一个任务。这里的任务指的是我们需要完成的某些特定需求。一个gulpfile文件中可以注册多个任务：\r\n* 第一个参数是任务的名字，如果需要在命令行中运行这些任务，则不要在名字中使用空格；此外前面提到，gulp的默认任务名是default。\r\n* 第二个参数是一个包含任务列表的数组，这些任务会在当前任务运行之前完成（为了达到这个目的则必须确保所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream）。\r\n* 第三个任务是一个回调函数，该函数定义任务所要执行的一些操作\r\n\r\n### gulp.watch()\r\n监视文件，并且可以在文件发生改动的时候(比如使用了`ctrl + s`保存文件)做一些事情（比如在保存了scss文件之后立即编译成css文件），在文件变动之后可以执行一个或多个任务\r\n```javascript\r\ngulp.watch(glob[, opts], tasks)\r\n```\r\n或者执行某个回调函数\r\n```javascript\r\ngulp.watch(glob[, opts, cb])\r\n```\r\n其中，该回调函数会被传入一个名为 event 的对象。这个对象描述了所监控到的变动，如果需要的话，可以根据事件对象的属性做对应的处理：\r\n* event.type 发生的变动的类型：added, changed 或者 deleted。\r\n* event.path 触发了该事件的文件的路径。\r\n\r\n## 插件\r\n最后在这里整理了常用的插件。\r\n\r\n### livereload\r\nlivereload可以在不使用刷新浏览器的情况下即时预览页面结构和样式改动，显著延长F5键的寿命。这个插件需要配合谷歌浏览器的插件livereload使用，直接在谷歌应用商店搜索安装即可。\r\n```javascript\r\nvar livereload = require(\'gulp-livereload\');\r\ngulp.task(\'watch\', function() {\r\n\t#旧版本的var server = livereload()已经失效\r\n    livereload.listen();\r\n    #css/**/*.* 的意思是 css 文件夹下的 任何文件夹 的 任何文件 \r\n    #也可以写成数组的形式\r\n    gulp.watch(\'css/**/*.*\', function(file) {\r\n        livereload.changed(file.path);\r\n    });\r\n});\r\n```\r\n\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '关于CSS选择器嵌套的思考', `created_at` = 1475545110, `category` = 'CSS', `tags` = '代码格式', `content` = '\r\n选择器命名对于样式表的作用至关重要；另一方面，选择器的嵌套可能也是比较重要的，选择器的嵌套决定了样式规则的权重值，浏览器的渲染效率等。当然，在《Sass与Compass实战》这本书中指出，“CSS的解析效率在页面加载速度中的影响力是比较低的”，论坛上有位网友指出，CSS 的解析时间跟 js 执行时间相比就像 PHP 代码的运行时间和数据库、I/O运行时间对比一样，不是一个数量级，因此不用担心。\r\n所以这篇关于CSS选择器嵌套的文章，就当是国庆在家百无聊赖而折腾出来的吧。\r\n<!--more-->\r\n## CSS解析顺序\r\n很早之前就提到（是在张鑫旭大神的博客上看见的），浏览器解析CSS选择器的顺序是从右向左的，而非我们书写时的语义上的从左向右。为什么会做出这样“反人类的”规定呢？这是在[stackoverflow上查到的答案](http://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left)。\r\n由于浏览器是根据节点树来匹配对应的选择器，如果是按照从左往右的顺序，则会在匹配失败后回溯到上一层重新匹配下一个节点，当节点树的规模十分庞大时，如此往复会造成巨大的浪费。相反，从右往左进行匹配，最开始就会筛选到目标元素，然后再判断其父元素是否符合条件，这样会大大减少不必要节点的匹配判断。然而需要注意的是，由于是从右往左进行匹配的，因此，浏览器会判断处于最右端的所有元素，如果是一个通配选择符，那么效率可能就不会那么高了（因为这会匹配页面上的全部元素，再判断其父元素是否满足要求）。不单单是通配选择符，如果页面上存在大量的同类选择器，比如a标签，那么浏览器也会对全部的a标签进行判断。解决这个问题，__可以使用类选择器代替标签选择器__，（解决问题的同时带来的麻烦大概就是如何为这些标签选择一个合适的类名）。\r\n\r\n## 嵌套深度\r\n选择器的匹配大概是一个递归的过程，从右往左，筛选出对应的元素并向上判断其父元素是否符合条件，依此递归，如果选择器的修饰过长（即嵌套层次过深），则额外的花费就会更多，因此，应尽量减少选择器的嵌套，这正是这篇文章的主题，自打用上LESS之后就一直在思考这个问题，略有一点总结。\r\n选择器的嵌套取决于页面结构，而又决定了样式的权重值。因此，为了将正确的样式规则应用在正确的元素上，就必须指定正确的选择器，并保证该选择器样式的权重值最为优先才行。\r\nSCSS,LESS这些工具所提供的选择器嵌套，极大地方便了选择器的书写，且能够很直观的看出页面结构。但是，如果一味按照页面结构来嵌套选择器，那么编译出来的CSS文件可能会十分恐怖，在不经意间甚至达到六七层嵌套（我曾经在body上定义了一个类作为该页面的选择器作用域，然后糊里糊涂地在里面进行嵌套，后面在线上需要直接修改CSS文件时，简直是一场灾难）。\r\n此外，选择器嵌套极大程度上限制了样式的重用，所需要的限定越多，能够重用的部分越少，甚至没有任何重用的可能性。\r\n总结一下，关于选择器嵌套所带来的问题：\r\n* 嵌套越深，浏览器需要的解析时间越长。\r\n* 嵌套越深，样式的重用性越低。\r\n* 嵌套越深，CSS文件越难维护。\r\n\r\n实际上，__后代选择器在标准中其实是一种不那么被推荐的写法__。那么，我们在书写CSS时，应在保证样式正确权重值，且能够匹配到正确元素的情况下，尽可能减少选择器的嵌套，剔除不必要的父元素，精简选择器的结构，比如移除多余的标签选择器。此外，选择器嵌套不应当仅仅是书写CSS文件时应当考虑的，正如前面所说，书写正确的HTML文档结构才是决定CSS选择器嵌套的关键。\r\n\r\n最后，由于ID选择器是页面唯一的，因此不需要有任何父选择器进行修饰（当然为了样式重用应少使用ID选择器）。\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '初识Vue', `created_at` = 1478263349, `category` = 'JavaScript', `tags` = 'vue', `content` = '\r\n\r\n大约两个月前其实就已经去尝试学习了Vue(实际上就是看了看文档，云里雾里不知道什么意思)，最近在使用原生PHP后端开发，完成第一个留言板的小项目之后着实被混杂的PHP和HTML代码给恶心到了，开始折腾如何分离代码。后来在论坛上看见一位前辈说初级的话不用去折腾什么页面静态化smarty之类的，使用include就够了，PHP本身就自带模板标签，那么怎么解决数据遍历的问题呢？突然灵机一动，想到了Vue（暴殄天物，让唾沫来淹死我吧...）下面重新过一遍文档（貌似现在是V2.0了）。\r\n<!--more-->\r\nVue跟jQuery直接操作数据库不同，他是直接操作数据来控制视图的，比如在jQuery中删除一个节点，使用remove()方法，而Vue删除一个遍历的节点，是找到对应的数组数据并根据节点的索引值使用数组原生的splice()方法，因此学习Vue，务必抛弃jQuery的思维方式...牢记“一切以数据为中心”的思想来学习Vue(MDZZ，这是我瞎掰的。)\r\n## 渲染模板\r\nVue内置了一些十分方便的指令，用来处理数据的输出\r\n### 分支\r\n\"v-if\"主要用来控制元素是否显示在页面中，这里的“显示”不是简单的\"display:none\"（显示隐藏DOM元素可以使用v-show指令），而是真正意义上的插入/删除DOM节点，当指令v-if=\"exp\"中的表达式exp的结果为假，则会将DOM节点删除。此外，还可以为v-if添加一个v-else模块。\r\n```\r\n\t<div id=\"t1\"  v-if=\"flag\"></div>\r\n\r\n    var t1 = new Vue({\r\n        el:\"#t1\",\r\n        data:{\r\n            flag:true //设置为false则元素不会加入DOM树中\r\n        }\r\n    });\r\n```\r\n\r\n\r\n### 遍历\r\n\"v-for\"主要用来遍历数组数据并批量生成节点。类似于for...in的功能。注意第二个参数index是对应元素的索引值，从0开始，在某些事件中需要操作对应元素的时候，应当使用该索引值操作员数据数组，这在篇头已经提到过。此外单条元素可带多个属性（比如数据库的元素，而现在PHP所需要做的就是拿出数据库的数据，然后echo赋值就可以了，简直爽!）\r\n另外，在遍历的时候也可以为该条元素加上\"v-if\"判断，跟在页面上写了一个完整的for循环实现的功能完全没有区别，真是太神奇了。\r\n```\r\n     <div id=\"t2\">\r\n        <ul>\r\n            <li v-for=\"(msg,index) in msgs\" v-if=\"msg.flag\">\r\n                {{ msg.word }} --- {{index}}\r\n            </li>\r\n        </ul>\r\n    </div>\r\n    var t2 = new Vue({\r\n        el: \'#t2\',\r\n        data: {\r\n            msgs: [{\r\n                word: \'msg1\',\r\n                flag: true\r\n            }, {\r\n                word: \'msg2\'\r\n            }, {\r\n                word: \'msg3\'\r\n            }]\r\n        }\r\n    })\r\n```\r\n## 数据解析\r\nVue中基本都是围绕数据进行操作，使用双大括号来处理数据，在双大括号中（这种语法叫做mustache）的内容会被当作JS表达式被解析，（注意只能是表达式而不是语句），此外还可以对表达式做进一步的处理\r\n### 过滤器\r\n表达式可以自定义一个过滤器（可以参考PHP中的date()格式化函数，将前面的表达式作为参数传递给过滤器并进行处理输出），Vue的过滤器语法采用的是\"|\"管道符，所有过滤器在构造函数参数的filters属性中定义。\r\n由于过滤器实际上是一个函数，因此可以带上参数，但是，由于默认的第一个参数实际上是管道符前面的JS表达式，因此过滤器函数带的第一个参数是在该函数调用的第二个参数，不妨打印过滤器函数的arguments查看一下。\r\n最后，多个过滤器可以连续使用管道符\"|\"进行串联。\r\n```\r\n    <div id=\"t2\">\r\n        {{num}}\r\n        <br>\r\n        {{num | mulTen}}\r\n    </div>\r\n    var t2 = new Vue({\r\n        el: \"#t2\",\r\n        data: {\r\n            num: 10\r\n        },\r\n        filters: {\r\n            mulTen: function(val) {\r\n                return val * 10;\r\n            }\r\n        }\r\n    })\r\n```\r\n\r\n### 修饰符\r\n在指定绑定的时候可以使用修饰符来限定绑定的形式，使用\".\"修饰符，常见的修饰符有\".prevent\"等\r\n```\r\nv-on:click.prevent\r\n```\r\n\r\n### 计算属性\r\n尽管可以在双大括号中进行表达式计算并输出正确的结果，但是如果逻辑比较复杂，则使用计算属性是一个更好的选择，在\"computed\"属性中定义相关的计算属性。\r\n```\r\n    <div id=\"t3\">\r\n        before computed: {{msg}}\r\n        <br>\r\n        after computed: {{msgSplit}}\r\n    </div>\r\n\r\n    var t3 = new Vue({\r\n        el:\"#t3\",\r\n        data:{\r\n            msg:\"test\"\r\n        },\r\n        computed:{\r\n            msgSplit:function(){\r\n                return this.msg.split(\"\").join(\"-\").toString();\r\n            }\r\n        }\r\n    })\r\n```\r\n可以看见，实际上也可以在methods中定义相关的方法，并在双大括号中调用方法并得到同样的效果。然而他们之间最大的区别在于：\"计算属性是基于它的依赖缓存，只有在它的相关依赖发生改变时才会重新取值\"；然而每当重新渲染的时候，method 调用总会执行函数且返回同样的结果。\r\n使用缓存在某个需要十分庞大的遍历和计算时特别有效。\r\n\r\n### 观察属性\r\n在有些时候需要监控某个数据的变化并做出处理时，可以使用观察\"watch\"，当wathc对象中的某个属性发生变化时就会调用对应的处理函数，观察者最主要的目的是用来观察数据的变化，实际的处理也可以放在methods中。\r\n```\r\n    <div id=\"t4\">\r\n        <p>{{msg}}</p>\r\n        <input type=\"text\" v-model=\"msg\">\r\n    </div>\r\n    var t4 = new Vue({\r\n        el:\"#t4\",\r\n        data:{\r\n            msg:\"test\"\r\n        },\r\n        watch:{\r\n            msg:function(){\r\n                console.log(\"change:\"+this.msg);\r\n            }\r\n        }\r\n    })\r\n```\r\n\r\n## 绑定属性\r\n首先必须抛弃jQuery操作DOM节点的思维方式，Vue为元素绑定属性采用了完全不同的方法。\r\n### 基础\r\n\"v-bind\"为DOM节点设置属性，类似于attr的效果，除了为节点本身的属性进行设置（比如title,class等），也可以设置自定义属性。\r\n由于绑定属性使用十分频繁，因此可以使用简写\":name\"来绑定对应属性。\r\n需要注意的是，在指令的赋值实际上是会在所属 Vue 实例的数据作用域下作为 JavaScript 表达式被解析，而非一个单纯的字符串中（我想到的是eval()函数，然而内部实现是什么样子的呢？待日后深究）。\r\n比如下面的例子，将元素的title属性设置的值是msg变量所对应的字符串，而不是\'msg\'，如果不定义msg变量（在data中定义），就会报错；而如果将代码改写成v-bind:title=\"\'msg\'\"的话，就相当于将字符串\'msg\'赋给元素的title属性，当然，单引号和双引号是可以互换的。\r\n\r\n```\r\n    <div id=\"t3\">\r\n        <div v-bind:title=\"msg\">\r\n            t3\r\n        </div>\r\n        <div :title=\"msg\">\r\n            t3\r\n        </div>\r\n    </div>\r\n\r\n    var t3 = new Vue({\r\n        el:\"#t3\",\r\n        data:{\r\n            msg:\"test title\"\r\n        }\r\n    });\r\n```\r\n\r\n### 类名与样式\r\n如前面所提到的，可以是用v-bind:class/style=\"\"来绑定类名或者行内样式。由于样式是页面中十分重要的部分，因此Vue对这个部分也有增强。\r\n#### 类名\r\n首先可以给v-bind:class绑定一个对象{active:isAcitve}，表示只有当isActive为真时才将active类绑定在元素上，当isActive变化时，会动态切换类名，多个类名只需要在对象上添加对应的键名即可。可以绑定返回对象的计算属性，十分方便的控制元素的类名。\r\n也可以对v-bind:class绑定一个数组，指明多个类名，数组的元素也可以是对象，用来切换类名的存在与否，十分方便。\r\n#### 行内样式\r\n至于行内样式，先在data中声明一个样式对象，再将样式对象绑定到对应的v-bind:style上是一个更好的选择，通常结合返回对象的计算属性使用，用来为元素添加特定的行内样式。\r\n```\r\ndata:{\r\n\tstyleObj:{\r\n    \tcolor:\'red\',\r\n        font-size: \'12px\'\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 数据双向绑定\r\n在表单输入和应用状态的即时改变中也可以同时改变数据（可以理解为表单为数据源），使用\"v-model\"指令来实现，效果类似于监听了输入框的“oninput”事件（实现的原理难道也是？肯定不是啦）\r\n```\r\n    <div id=\"t5\">\r\n        <p>{{msg}}</p>\r\n        <input type=\"text\" v-model=\"msg\">\r\n    </div>\r\n    var t5 = new Vue({\r\n        el:\"#t5\",\r\n        data:{\r\n            msg:\"placeholder\"\r\n        }\r\n    });\r\n```\r\n\r\n\r\n### 事件处理\r\n事件是DOM中非常重要的部分，在Vue中使用\"v-on:事件名\"来注册事件处理函数，跟原生的\"onclick\"非常相似，但是，注册的事件的作用域是当前元素而非全局对象。因此，如果想要在引号中使用onclick=\"alert(1)\"这样的效果时，如果没有在methods属性中声明对应的alert方法，会报方法未定义的错误，这里需要掌握的就是Vue中的作用域（都是限制在对应的new Vue对象中？）。\r\n此外，关于事件绑定还可以使用v-on的简写简写\"@click\"，\r\n```\r\n    <div id=\"t4\" v-on:click=\"clickHandle\">t4</div>\r\n    var t4 = new Vue({\r\n        el:\"#t4\",\r\n        data:{\r\n            // msg:\"test title\"\r\n        },\r\n        methods:{\r\n            clickHandle:function(){\r\n                console.log(\"click\");\r\n            }\r\n        }\r\n\r\n    });\r\n```\r\n\r\n\r\n## 组件系统\r\n我曾经花了很长一段时间来思考CSS选择器命名和样式重用（当然现在也还没有理清楚）。实际上Vue的组件系统可以让我们使用独立的小组件来构建整个项目，就跟搭积木一样，最重要的是“积木”是可以重用的！\r\n\r\n### 组件\r\n根据定义，一个组件实际上就是一个实例化的Vue对象，通过配置template属性定义组件的HTML结构，配置props属性将父元素中的数据传递给子组件（这里需要注意的是必须同时在页面的组件上使用v-bind:name = \"value\"的方式显式绑定数据）\r\n```\r\n    <div id=\"t1\">\r\n        <ul>\r\n            <cpt-1></cpt-1>\r\n        </ul>\r\n        <cpt-2></cpt-2>\r\n    </div>\r\n\t// 注册组件\r\n    Vue.component(\'cpt-1\',{\r\n        template:\'<li>this is li</li>\'\r\n    })\r\n    Vue.component(\'cpt-2\',{\r\n        props:[\'msg\'],\r\n        template:\'<p>{{msg}}</p>\'\r\n    })\r\n\r\n    var t1 = new Vue({\r\n        el:\"#t1\",\r\n        data:{\r\n            msg:\"this is a message in p!\"\r\n        }\r\n    })\r\n```\r\n\r\n';
INSERT INTO shymean_article SET `title` = '初识SCSS', `created_at` = 1470401070, `category` = 'CSS', `tags` = 'SCSS', `content` = '\r\n上一个项目是自己决定用LESS来写css的，结果遇到了一个很纠结的问题，比如为了规范代码采用的是“一行一对属性:属性值”的格式，这就造成了整个项目有近几千行LESS源码，后面修改的时候十分不方便，如果拆分成多个文件，引入文件路径又十分麻烦。这时候同事就推荐了sass，就这样入了另外一个坑。\r\n<!--more-->\r\n在简单地查看了sass语法之后，却生出了一种十分蛋疼的感觉，sass采用了类似于python那样严格的缩进，甚至更为苛刻：\r\n* 没有分号与大括号，采用严格的缩进；\r\n* 使用两个空格的缩进来表示代码的嵌套；\r\n* 也可以使用四个空格缩进，整个文件需要统一；\r\n* 选择器的属性值与属性值之间需要一个空格；\r\n\r\n之后为了减小学习成本，于是我就转向了SCSS。SCSS貌似是在原生sass的基础上转而采用类似与CSS的语法，使用大括号代替了缩进，与LESS相似但是具有更多的功能，大致摸索了一下，于是整理了下面的一点笔记。\r\n参考资料：[w3cplus](http://www.w3cplus.com/sassguide/)和[sass中国](http://www.sass.hk/sass-course.html)。\r\n\r\n## 变量声明\r\n```\r\n$base-color:#000;\r\n```\r\n* 与less中使用@来声明变量不一样，scss使用\"$\"符号来标识变量，因为\"$\"符号在CSS中并没有其他用途;\r\n* 变量不区分\"-\"和\"_\"，采用这两种分隔符命名的变量会被认为是同一个变量。\r\n\r\n## 计算\r\n类似与LESS，SCSS的属性值也是可以自动进行计算的，包括长宽，字体等，此外颜色还可以使用颜色函数进行调整。\r\n\r\n## 选择器嵌套\r\n```\r\n    .wrap {\r\n        background: #ccc;\r\n        h1 {\r\n            color: red;\r\n            a {\r\n               text-decoration: none;\r\n            }\r\n        }\r\n    }\r\n```\r\n* 与LESS相同的嵌套规则，但是为了浏览器的解析效率，千万不要滥用嵌套；\r\n* 多类选择器使用\"&\"符号，群组选择器也会被正确解析；\r\n* 属性嵌套与选择器嵌套类似。\r\n\r\n## 拆分并导入Scss文件\r\n可以将其他的scss文件引入到当前scss文件，即可以达到分模块编写css样式，然后统一编译为一个css文件中,甚至可以在多个项目中使用同个样式。支持拆分文件是我使用scss最主要的原因，这个功能能够十分清楚明白地组织项目css文件结构。大赞!\r\n```\r\n\t@import \"styleGroup/_wrap.scss\";\r\n```\r\n* 可以省略后缀名\".scss\"或者\".sass\"；\r\n* 专门为import命令编写的scss文件，，可以在命名时以下划线开头，这样就不会在编译时生成单独的css文件；\r\n* 由于默认后定义的变量会覆盖先前定义的变量，因此可以在定义变量的时候使用!default，如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。\r\n\r\n## 混合器\r\n```\r\n    @mixin border-default($width,$style,$color,$r) {\r\n        border: $width $style $color;\r\n        border-radius: $r;\r\n    }\r\n    .wrap {\r\n        @include border-default(1px,solid,#000,5px);\r\n    }\r\n```\r\n* 如果是属性值需要重用则可以使用变量，如果是一大段样式需要重用则可以使用混合；\r\n* 使用@minxin定义混合器，使用@include引用混合器\r\n* 混合器的命名应当充分表现该样式的作用，避免滥用混合器造成样式表的臃肿\r\n* 可以通过为混合器传参来建立不同的样式段代码\r\n* 可以通过$name : $value的形式来传参，这样可以不用记住参数的顺序\r\n* 可以为混合器参数设置默认值，即在设置参数时使用$name : $defaultValue形式\r\n\r\n## 继承\r\n选择器继承指的是一个选择器可以继承另一个选择器的所有样式\r\n```\r\n@extends .wrap\r\n```\r\n* 与混合器相比，继承生成的css代码相对更小\r\n* 继承存在样式重叠的问题，浏览器根据选择器权重值进行判断\r\n* 避免继承来自于后代选择器的样式，这样应用css规则的选择器情形无法判断\r\n\r\n## 最后\r\n刚开始学习less的时候心里的那个关于选择器嵌套的疑惑算是解开了：跟使用的预编译器无关，选择器嵌套是完全由我们自己决定的，至于编译出来的N层嵌套，完全取决于我们在预编译的时候是否真正思考了嵌套的作用，那么问题来了：到底该用什么姿势来书写正确的CSS代码呢？\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '在CSS中遇见的一些BUG', `created_at` = 1484486147, `category` = 'CSS', `tags` = 'Bugs', `content` = '\r\n\r\n今天打开有道云笔记，发现不知不觉中记录了不少关于CSS的BUG，有的问题在遇见的时候就成功解决了，有的却是采用某些折衷的办法进行处理。里面还有几个挺有趣的问题，一并整理一番，另外还有一篇是关于JS的浏览器的BUG。\r\n<!--more-->\r\n按照怎样的格式来记录这些问题，这也是一个问题。然后我就把笔记上的原话搬过来了，有的是几个月前的问题了，画风有些出入...\r\n## 兼容\r\n\r\n### 缓动动画与fixed\r\n当为元素设置缓动动画（或其他动画？）时，其子元素如果设置了fixed，则改fixed属性会失效。后来搜索的时候发现有人遇见了同样的问题\r\n* [问题1](http://www.cnblogs.com/skyweaver/p/4369276.html)\r\n* [问题2](http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/)\r\n\r\n回帖有人说是“父类元素 含有 transform,或者 will-chanage之类，会单独建立 gpu层，导致 子元素fixed，或者zIndex 之类失效”，这个问题有点深奥了，暂时还没有深究。\r\n\r\n### ie与form\r\nie下面的form 嵌套div，在某些情况下会重复出现一个div，这个BUG的原因并没有查到，有说是由于form规范的问题。出现问题的是一个登陆页面，客户用IE8登陆发现的问题（为毛还是IE8！！！），找BUG的时候是一行一行删代码找的，泪奔...最后的解决办法是去掉了form标签（因为数据是直接通过ajax提交的，所以这也算是个很扯淡的解决办法）。\r\n\r\n### CSS样式数值在浏览器显示为小数\r\n好吧，记录这个问题的时候我脑袋抽风了，因为这个问题是由于使用了浏览器的缩放功能引起的，然后比如边框宽度等大小都会重新计算为一个小数，这不是BUG而是浏览器做的处理，因此遇见这种问题最好检测浏览器的默认缩放大小是不是100%。好气哦，但还是要保持微笑...\r\n\r\n### iphone5下面的flex与内联子项\r\niphone5下面的flex容器中，如果子项是内联或内联块状元素，则justify属性貌似不会生效，也没有其他解决办法，只能将那段span和strong都写上了`display:block`，如果后面的同事去维护的话看见了希望不要骂我是傻Ⅹ。\r\n\r\n### IOS下input光标\r\n如果Input的高度和行高一致，则在ios上出现输入时光标不垂直居中的问题（光标靠上边框），解决办法是移除行高。事实上，没必要为button和input这些元素设置行高的...\r\n\r\n### 在火狐和360下的select高度\r\n接上一个问题，在chrome中只需要设置line-height就可以使select得高度撑开，但是在火狐和360等浏览器下不行，必须显式地设置高度，否则在浮动的情况下出现卡位的情况，（论多浏览器测试的重要性，然而我很不情愿换除了谷歌浏览器之外的其他浏览器进行测试，因！为！肯！定！有！问！题！）。\r\n\r\n### IE下背景图片不生效\r\n维护一个学校的项目，发现低版本的IE上背景图片不生效。起初以为是png的问题，然后发现根本没毛关系，上万能的互联网一搜，发现有个回答说，no-repeat两边需要加上空格！上源文件一看果然是这个问题尼玛!!! 另外ie9之前的不支持background-size。\r\n\r\n\r\n\r\n\r\n## 属性\r\n### translate\r\n`translate`这个属性对于内联元素无效，但是在HBuilder中却可以预览播放（现在我还是转向使用Webstrom了），实在是坑啊。\r\n\r\n### nth-of-type\r\n在写一个签到页面的时候发现的问题。无法根据元素索引使用正确的样式。\r\n实际上描述的type是标签类型，并不是类名，因此，如果兄弟元素都为div但是类名不同，使用这种方法无法得到正确的结果。折衷的解决办法是使用不同的标签。切记切记！！！。\r\n\r\n### overflow-y hidden\r\n使用overflow-y hidden容器自动换行，这个问题是为了写一个水平加载图片的插件发现的，记录的比较详细：\r\n```\r\n<!--css-->\r\n.wrap {\r\n    overflow-x: hidden;\r\n\twidth: 500px;\r\n\t/* height: 110px; */\r\n\tmargin:  200px auto;\r\n\tborder: 1px solid red;\r\n}\r\n.box {\r\n    box-sizing: border-box;\r\n\tfloat: left;\r\n\twidth: 100px;\r\n\theight: 100px;\r\n\tborder: 1px solid #000;\r\n}\r\n.box img {\r\n\theight: 100px;\r\n\tdisplay: block;\r\n}\r\n\r\n\r\n<!--html-->\r\n<div class=\"wrap\">\r\n\t<div class=\"box\">\r\n\t\t<img src=\"head.jpg\" height=\"100\" alt=\"\">\r\n\t</div>\r\n\t<div class=\"box\">\r\n\t\t<img src=\"head.jpg\" height=\"100\" alt=\"\">\r\n\t</div>\r\n\t<div class=\"box\">\r\n\t\t<img src=\"head.jpg\" height=\"100\" alt=\"\">\r\n\t</div>\r\n\t<div class=\"box\">\r\n\t\t<img src=\"head.jpg\" height=\"100\" alt=\"\">\r\n\t</div>\r\n\t<div class=\"box\">\r\n\t\t<img src=\"head.jpg\" height=\"100\" alt=\"\">\r\n\t</div>\r\n</div>\r\n```\r\n\r\n这是因为总容器`wrap`显式地设定了`overflow-x:hidden`，导致`overflow-y`属性变成了auto的原因\r\n> W3C : The computed values of ‘overflow-x’ and ‘overflow-y’ are the same as their specified values, except that some combinations with ‘visible’ are not possible: if one is specified as ‘visible’ and the other is ‘scroll’ or ‘auto’, then ‘visible’ is set to ‘auto’. The computed value of ‘overflow’ is equal to the computed value of ‘overflow-x’ if ‘overflow-y’ is the same; otherwise it is the pair of computed values of ‘overflow-x’ and ‘overflow-y’.\r\n\r\n[参考资料](http://caibaojian.com/overflow-x.html)\r\n\r\n此时，`wrap`某个内部子元素高度大于其父元素的高度（这里是图片高度100px，box的高度是98px），导致本来能在同一行显示所有的box，最后一个box却换行显示了。\r\n\r\n解决办法是：设置所有元素的高度都能容纳其子元素（增加box的高度或者`height:auto`）\r\n\r\n因此这里可以\r\n* 增加box的高度或者设定box高度`height:auto`\r\n* 增加wrap的高度或者设定box高度`height:auto`\r\n\r\n实际上只需要不限定父元素的高度就可以了，但是实际开发中总会遇见需要设定高度的地方，因此了解这个问题还是很有用的。\r\n\r\n## 小结\r\n还有一些其他的问题，现在回过头看是当时脑子短路了，就不贴上来了，另外这篇文章就用来记录之前及今后遇见的CSS的BUG吧。\r\n另：说是BUG，实际上大多数都是自己学艺不精造成的，无话可说。\r\n\r\n';
INSERT INTO shymean_article SET `title` = '在JS中遇见的一些BUG', `created_at` = 1484488529, `category` = 'JavaScript', `tags` = 'Bugs', `content` = '\r\n前面写了一篇记录遇见的CSS的BUG，这篇文章就用来整理和记录写JS遇见的坑。实际上项目基本上都使用了jQuery，因此绝大部分兼容性问题已经很少遇到了，然而，总还是有一些蛋疼的问题出现。\r\n\r\n<!--more-->\r\n\r\n## 兼容\r\n\r\n### 移动端获取触摸坐标\r\n由于代码都是在PC端使用模拟器进行测试的，一到真机上就嗝屁了。最初写了一个滑动图片的demo，手机上查看死活没反应，最后发现并不能使用`e.pageX`和`e.pageY`获取，而是`var startPoint = e.originalEvent.targetTouches[0].pageX;`获取...这个怎么能叫BUG！！\r\n\r\n### 手指按住屏幕时UI，JS线程不会执行的\r\n在IOS上发现的这个BUG，一个抢购倒计时，当手指按住屏幕的时候倒计时会暂停。\r\n一通查询，这个问题貌似是JS执行线程，UI线程，事件线程之间的关系，办法就是使用事件线程来协调JS线程和UI线程，因为在JS执行的过程中如果触发了UI事件那么就会引起UI更新；\r\njs中没有阻塞式的sleep。因为在浏览器中UI线程会随JS线程一起阻塞。如果JS阻塞了，界面也会失去响应，或者无法更新。\r\n附原回答，这个问题我到现在都没有解决，（要不是今天整理笔记我都忘记这茬了）\r\n* [问题1](https://www.zhihu.com/question/38337979)\r\n* [问题2](http://www.cnblogs.com/liuliang-wifi/p/5431726.html)\r\n\r\n### unbeforeunload不触发\r\n如果事件回调函数中存在报错，则窗口会直接关闭而不是在控制台显示错误并阻止程序执行。\r\n因此很难发现unbeforeunload不触发的问题，需要仔细排查！\r\n\r\n### touchstart之后的click事件不生效\r\n在使用touchstart之后页面上的链接都点击不了（后来发现是在touchend中使用了return false，实际上是e.preventDefault()导致整个页面的链接都失效。这个就是自己给自己挖坑了。\r\n附：[问题1](http://www.cnblogs.com/lvmingyin/p/5372678.html)\r\n\r\n## 语法\r\n### 字符串转数字\r\n之前写过的一端预约时间的的代码，采用的逻辑是根据后台传出的时间段及时间间隔，根据分数遍历出对应的option，但是360浏览器下的parseInt()有个很严重的BUG: `parseInt(\"01\")`..`parseInt(\"07\")`都会正确转换成1到7，但是\r\n`parseInt(\"08\")`,`parseInt(\"09\")`却转换成了0,这是一个十分严重的BUG,硬生生的将预约时间增加了数个小时\r\n解决办法是在使用使用隐式转换与显式转换，即`parseInt(\"09\"-0)`，这样才能解决问题。\r\n\r\n在阅读《JavaScript语言精粹》的时候终于知道了问题的缘由：parseInt()是一个把字符串转换成整数的函数，在遇见非数字时就会停止解析；然而如果第一个字符是0，则会默认按照八进制解析，由于8,9不是合法的八进制字符，因此会转换成0，产生了上面的BUG（在谷歌浏览器等先进浏览器下面已经解决了这个问题，因此没有发现这个问题）。解决办法是在使用parseInt的时候显式的指定第二个参数，即转换进制,parseInt(\'09\',10);\r\n\r\n### 函数返回true\r\n一个函数如果没有返回值则默认返回undefined；因此在判断语句中使用return true和false时，需要显式地将return true声明，否则函数会一直返回false或者undefined。这是一个很简单的基础问题，我当时去花了半个多小时，真是醉了。\r\n```\r\nfunction checkPhone(tel){\r\n    var re = /^1[358]{1}\\d{9}$/;\r\n    if (!tel || !re.test(tel)){\r\n        alert(\"请输入正确的手机号\");\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n```\r\n现在回过头看，明显应该修改判断条件，把`return true`写在判断里面，哎，想之前还写过`if {...} else { continue}`的代码呢。\r\n\r\n## 小结\r\n遇见的JS的问题还是比较少的，因为JS的代码写的比较少，也写的比较简陋，并且大部分问题都是前人碰见过的，总之，感谢互联网！\r\n';
INSERT INTO shymean_article SET `title` = '外边距重叠', `created_at` = 1464827030, `category` = 'CSS', `tags` = '样式', `content` = '\r\n外边距重叠是盒子模型中一个比较常见的情形，所谓重叠，指的是当两个在垂直外边距（指上下）相遇时，会按照指定的规则进行定位。\r\n<!--more-->\r\n两个外边距重叠的元素之间的距离按照下面标准取舍：\r\n* 全部都为正值，取最大者；\r\n* 不全是正值，则都取绝对值，然后用正值减去最大绝对值；\r\n* 全部都是负值，则都取绝对值，然后用0减去最大绝对值。\r\n\r\n## 定义\r\n标准里面关于外边距重叠的定义是：collapsing-margin，两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会重叠。这句话真是无比的精炼啊：\r\n* 只有竖直方向上的外边距才会发生重叠。\r\n* 最少存在两个块级元素才会发生外边距重叠。注意这里其实有两种情况的重叠：两个兄弟块元素之间的重叠，以及子块元素与父级元素之间的重叠。\r\n* 只有处于普通流中，且相邻的块才会发生重叠。注意，这里的相邻：如果是兄弟元素，指的是他们之间没有被非空内容，或者带有padding,border和clear等在文档流中占有面积的块分隔开来；如果是父子元素，指的是子块带有margin，父块没有padding和border的情况，此时如果父块没有触发BFC，则父块与子块的也会发生外边距折叠。（最常见的情形就是并没有为父块设置外边距时，整个父块却活生生地向下偏移了N个像素，而此时子块紧贴着父块的顶部，其本来具有的外边距却不见了的诡异事件，就像是外边距“渗透“了一样）\r\n* 这句话并没有表现出来，这是由BFC规定的。只有属于同一个BFC的两个块元素才会发生外边距重叠。\r\n\r\n\r\n## 清除外边距折叠\r\n有时候我们在布局的时候，并不希望产生外边距重叠，该如何解决呢？之前在记录BFC的时候简单提到了清除外边距重叠的方法，这里再详细的介绍一下。\r\n### 父子元素\r\n解决父子元素之间的外边距重叠问题，只需要父元素带上padding或者border就可以了，然而这会改变其盒子模型的大小；因此可以使父元素触发BFC，一般采用overflow： hidden，这样就可以解决了。\r\n### 兄弟元素\r\n浮动元素、inline-block 元素、绝对定位元素不会和垂直方向上相邻的其他元素发生外边距重叠。可以看出这些都是具有BFC属性的元素。但是！千万不要认为所有的BFC元素就都不会发生外边距重叠了，不然你用overflow:hidden试试。所以，应当将上面的这几种情形当作特例，最根本的原因是：只有在同一个BFC内的元素才会发生外边距的折叠，如果两个元素处在不同的BFC中则不会发生外边距折叠。因此，对于相邻元素，只要将它们放上不同 的BFC 中（比如为他们添加一个空的BFC包裹层），就能使它们的 margin 不重叠。\r\n\r\n## 最后\r\n外边距重叠只是CSS中一个很小的问题，路漫漫其修远兮啊。\r\n学习CSS第一天的感觉：好简单，我已经精通CSS了...\r\n学习CSS第十天的感觉：咦？这个东西我以前怎么没见过...\r\n学习CSS一个月的感觉：什么玩意儿？我特么什么都不会啊！！\r\n';
INSERT INTO shymean_article SET `title` = '初识正则表达式', `created_at` = 1468853833, `category` = 'JavaScript', `tags` = '正则', `content` = '\r\n其实一开始让我学正则我是拒绝的，因为你不能让我去学我就去学，我得先试一试，要是太难了我就不学了。然后一看，这一串中括号大括号是什么鬼，果断不学。后面打算搞一点爬虫的时候，才发现正则式绕不过去的槛，加上最近的项目，需要在页面先进行一遍表单验证巴拉巴拉之类的，然后才重拾正则的学习笔记，进行一番捣鼓。下面是正则基础篇，凑合着能应付普通的要求了。（会写正则的人都很酷的样子，哈哈!）\r\n<!--more-->\r\n学习的时候参照的两篇文章：[轻松学习正则表达式](http://www.cnblogs.com/jamesping/articles/2252675.html)（强烈推荐！！！）和[55分钟学会正则表达式](http://blog.jobbole.com/63398/。)。\r\n学习正则，最主要的知识点就是三类符号：括号（包括(),[],{}），起始符号（^）和结束符号（$）。\r\n## 起始符与终止符\r\n起始符和结束符的意义十分明确：起始符表示规定查找的字符串以“^”后跟的字符（或字符串——需要分组）开始；结束符表示规定查找的字符串以“$”前接的字符（串）结束，就是这么简单，比如表示以a开头，以b结尾的单词：\r\n```\r\n    var re = /^a.b$/;//“.”字符可以理解为类似于C语言的占位符，表示可以匹配任意字符\r\n    var s = \"axb\";\r\n    console.log(re.test(s));//true\r\n```\r\n当然，这两个符号并不是一个正则表达式所必须的，可以根据需要灵活使用。\r\n```\r\n    var re = /a.b/;\r\n    var s = \"Halbo\";\r\n    console.log(s.match(re));//alb\r\n```\r\n## 括号符号\r\n### 中括号\r\n“[]”内包含的是需要匹配的字符集合，可以只有一个字符，也可以是多个字符的集合（包括数字字母各种有意义的转义字符等等）。比如：\r\n* 可以是[0-9]（表示匹配一个数字），可以简写成[\\d]；\r\n* 可以是[a-zA-Z0-9_]（表示匹配一个常规字符），可以简写成[\\w]；\r\n* 在中括号中添加^就表示取反，即不匹配其中的字符。\r\n\r\n关于中括号惟一需要理解的就是：中括号内的字符自带了“|”（或）的属性（这句话是我瞎编的），不管中括号里面有多少个字符，在不加修饰的情况下都只会匹配其中的一个字符（所谓的匹配就是目标字符串与正则表达式有交集（如果有起始符合结束符则表示相同）），只会匹配一个字符未免太小气了，接下来的大括号就是为了解决这个问题的。\r\n### 大括号\r\n“{}”的内容为一对数字范围，意义为指定从方括号“[]”中匹配字符的个数。“一对数字”也只是一个相对的说法： 可以是{n}（匹配固定数目）； 或者是{,n}（从0到某个数字的范围）； 或者是{n,}（某个数字到正无穷的范围）； 或是{n1,n2}（某个闭合区间）；\r\n此外还有三种简写方式：\r\n* “*”表示{，}即不指定次数，匹配存在0个或多个；\r\n* “+”表示{1,}即至少存在一个；\r\n* “?”表示{0,1}即存在0个或者1个;\r\n\r\n上面提到的这些字符，[{^$|?*+.}]，都是正则表达式中的元字符（小括号后面再谈），如果想匹配他们的原本含义字符，需要加上转义符，也就是“\\”，当然转义符本身也是一个元字符。\r\n### 中场练习\r\n结合中括号和大括号，以及起始符与结束符就可以完成大部分的正则表达式书写。下面来做一些练习（这些练习题都是我自己瞎想的，有部分重复的地方也懒得改了，这个笔记都快过去一个月了，最近连续加班一周，泪奔）：\r\n```\r\n    //1.检测是否存在子字符串xyz\r\n            var re = /xyz/;\r\n    //2.检测是否是以xy开头的字符串\r\n            var re = /^xyz/;\r\n    //3.检测是否以xyz结束\r\n            var re = /xyz$/;\r\n    //4.匹配是否存在b-h之间的字符\r\n            var re = /[b-h]/;\r\n    //5.匹配是否存在连续三个在b-h之间的字符\r\n            var re = /[b-h]{3}/;\r\n    //6.匹配开头5位是数字的字符串\r\n            var re = /^[0-9]{5}/;\r\n    //7.匹配长度为5位的数字\r\n            var re = /^[0-9]{5}$/;\r\n    //8.匹配长度在3-5位的数字\r\n            var re = /^[0-9]{3,5}$/;\r\n    //9.匹配前三位为字母，后四位为数字的字符串\r\n            var re = /^[a-z]{3}[0-9]{4}$/;\r\n    //10.匹配不区分大小写开头的字符串\r\n            var re = /^[a-zA-Z]/;\r\n    //11.匹配以my或者your开头的字符串\r\n            var re = /^my|your/;\r\n    //12.匹配值在0-35之间的的字符串\r\n            var re = /^([0-9]|1[0-9]|2[0-5])$/;\r\n```\r\n从上面的练习得到的收获是：\r\n* 如果是为了获取固定长度的字符串（或或者是以XX开头或结尾），则应当使用^与$来表示准确的匹配；如果只是为了获取某个字符串的子串，则不需要使用这两个符号。\r\n* 中括号与大括号一般组合使用，再结合通配符，即可编写大部分正则表达式。\r\n\r\n此外需要注意的两点是：\r\n* 重复字符是没有记忆性的，比如[abc]{2}表示先匹配”a或者b或者c”，再匹配”a或者b或者c”，与匹配”aa或者ab或者ac或者ba或者bb或者bc或者ca或者cb或者cc“一样。[abc]{2}并不表示只匹配”aa或者bb或者cc“\r\n* 重复次数的范围可以是开区间,a{1，}表示匹配一个或一个以上的连续字符a。依然是匹配最长字符串。当找到第一个a之后，正则表达式会尝试匹配尽量多个的连续字母a。\r\n\r\n### 小括号\r\n然后来看一看小括号“()”。小括号主要有两个作用：改变限定符的作用范围和分组：\r\n* 改变限定符的作用范围：比如(a|b)c表示ac或者bc，而a|bc表示a或者bc，两者的含义完全不同了；\r\n* 分组，即创建子表达式，(a[0-5][bc]){3}表示匹配连续出现a[0-5]bc三次的字符串。关于小括号的分组功能远不止这点，现在暂时还没有深入。\r\n```\r\n    //改变限定符的作用范围\r\n    var s = \"apple\";\r\n    var re1 = /a|bc/;\r\n    console.log(re1.test(s));//true，匹配到了a\r\n    var re2 = /(a|b)c/;\r\n    console.log(re2.test(s));//false，并没有ac或者bc\r\n\r\n    //分组\r\n    var re = /(abc){2}/;\r\n    var s1 = \"abc\";\r\n    console.log(re.test(s1));//false\r\n    var s2 = \"abcabc\";\r\n    console.log(re.test(s2));//true\r\n    var s3 = \"aabbcc\";\r\n    console.log(re.test(s3));//false\r\n```\r\n\r\n## 贪婪匹配与非贪婪匹配\r\n最后来了解一下正则表达式的贪婪匹配和非贪婪匹配，整个正则入门大概就差不多了。\r\n* 贪婪匹配：正则表达式一般趋向于最大长度匹配，这是正式表达式的默认匹配模式；\r\n* 非贪婪匹配：匹配到第一个合适的字符就会返回，即匹配尽可能短的字符，在表达式后加上“?”就可以转变的非贪婪模式。\r\n\r\n概念区分十分简单，一般需要考虑选择匹配模式的情况出现在使用“*”的情况下。\r\n```\r\n    var s = \"abxyczc\";\r\n    var re1 = /ab.*c/;\r\n    console.log(s.match(re1));//abxyczc\r\n    var re2 = /ab.*?c/;\r\n    console.log(s.match(re2));//abxyc\r\n```\r\n正则表达式的贪婪匹配与贪婪匹配是一个比较重要的知识点，千万不能忽视。';
INSERT INTO shymean_article SET `title` = '浏览器渲染流程', `created_at` = 1467370007, `category` = 'HTML', `tags` = '浏览器', `content` = '\r\n浏览器通过其渲染引擎在窗口中显示经过CSS文件格式化之后HTML文档内容和图片。了解其渲染流程应当是前端学习过程中一个非常重要的环节，惭愧的是今天才开始整理相关的知识。\r\n<!--more-->\r\n本文参考了这两篇文章：[新式网络浏览器幕后揭秘](http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)和[浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)。\r\n经过查阅资料得知，渲染流程主要分为如下四个步骤：\r\n* 首先解析HTML构建DOM树，解析CSS文件构建CSS规则树（规则树只是firefox下的一个概念，就这样拿来用了）；\r\n* 接着关联DOM树和CSS规则树，构建渲染树；\r\n* 然后对渲染树中的元素节点进行布局；\r\n* 最后绘制整个页面。\r\n\r\n下面是关于整个流程的详细解释。\r\n## 解析\r\n解析文档指的是将文档转化成有意义的结构。解析器通常将解析结构分给词法分析器和解析器两个组件来处理，分别对应词法分析与语法分析两个方面。词法分析将输入内容分解成多个有效标记，并分离无关的字符（如空格换行）；语法分析是应用语言的语法规则的过程。解析是一个迭代的过程，类似于将一条英语句子翻译成中文的过程。\r\n### HTML文档解析\r\n* 解析顺序有自上而下与自下而上两种形式，但是由于HTML与XML不一样，HTML具有宽松的语法规范，且在解析过程中整个页面经常会发生改变，因此无法使用常规的解析技术。\r\n* HTML的解析分为标记化和树构建两个阶段。其中标记会对应词法分析，将解析的多个标记传递给树构建器进行处理，规范中定义的每个标记所对应的DOM元素会在树构建起接受到相应的标记时所创建，并添加到DOM树中。\r\n* 在解析不严格的HTML文档时如果遇见不符合XML规范的书写格式，浏览器解析器将对其进行处理并尽量使其内容显示出来。\r\n\r\n### CSS文档解析\r\n* 吸取了早年HTML的教训，CSS文档是上下文无关的语法，可以在各种解析器下进行正确解析。\r\n* webkit采用的是自下而上的解析器，而firefox采用的是自上而下的解析器。这两种解析器都会将CSS文件解析成stylesheet对象，每个对象都包含对应的CSS规则。\r\n\r\n## 渲染树\r\n这是由可视化元素按照其显示顺序组成的树，即文档的可视化表示，其作用是使浏览器按照正确的顺序绘制内容。 渲染树中的每个元素都代表一个矩形的区域，通常对应相关节点的CSS框（是包含块吗？），包含了宽高位置等几何信息。渲染树中的元素与DOM树中的元素相对应，但并非一一对应，非可视化的DOM元素并不会插入渲染树中（如head元素或display:none的元素）。\r\n* 构建渲染树时，需要通过计算每一个渲染树元素的样式属性来计算他的可视化属性。在计算某个特定元素的样式上下文时，首先计算规则树中的对应路径，并沿此路径应用CSS规则，在新的样式上下文中填充结构。\r\n* 如果不进行优化，则在计算过程中会造成很大的性能问题。为每一个选择器对应的元素节点遍历整个规则列表来寻找匹配规则是一项十分浩大的工程，因此，选择器的嵌套与组合十分重要。\r\n* 在样式表解析完成之后，浏览器会根据选择器将CSS规则加到某个哈希表中，这些哈希表中的选择器各不相同，包括ID,类，标签选择器等。这种处理会大大简化匹配规则。\r\n* 在某个元素节点上同时应用多个重复的样式时会根据选择器的权重值进行排序，并使用优先级高的样式。\r\n\r\n## 布局\r\n元素节点在添加至渲染树的时候并不包含位置和大小等几何信息，计算这些值得过程就称为布局或重排。\r\nHTML采用基于流的布局模型，因此处于流中靠后位置的元素不会影响到位置靠前的元素的几何特性。布局分为整体布局和增量布局两种：前者需要对整个页面进行重新布局，后者对标记了dirty的所有元素进行重新布局。dirty是为了避免一个细小的改动导致整个页面进行重新布局，而采用了的一种处理系统，如果渲染树中的某个元素发生了更改，或者其自身及后代标记了dirty，则表示需要重新布局。\r\n布局有两个很重要的概念，Repaint和Reflow。\r\n* Repaint表示页面上某个元素的的非定位样式需要重新绘制（比如利用JS改变了元素节点的背景颜色，此时不需要重新布局）；\r\n* Reflow表示元素节点的几何尺寸发生了变化，此时需要重新计算并构建渲染树（即此时需要重新布局）； 需要注意的是Repaint和Reflow可能同时发生在同一个元素节点上。\r\n\r\nreflow和repaint可能会严重影响性能，因此需要尽可能的减少reflow和repaint操作，下面是几条原则：\r\n\r\n* 不要一条一条地修改DOM的样式，如果修改的样式过多可以将样式统一在某个类中，然后直接更改元素节点的className；\r\n* 使用临时变量保存DOM节点，而不是每次都直接对DOM节点进行操作（减少元素节点的读写），在JS性能与浏览器性能方面都能得到一些优化；\r\n* 尽可能修改层级比较低的DOM，缩小操作的影响范围；\r\n* 放弃使用table进行布局，一个很小的改动都会造成整个table的重新布局\r\n\r\n## 绘制\r\n在绘制阶段，系统会遍历整个渲染树，并调用API将渲染树的整个内容显示在屏幕上，这里涉及到操作系统原声GUI的API,暂时还没有深入。';
INSERT INTO shymean_article SET `title` = '学习jQeury的整理', `created_at` = 1464354286, `category` = 'JavaScript', `tags` = 'jQuery', `content` = '\r\n当勉强能够写静态页面的时候，我便很着急地直接学习DOM了，那时甚至都不知道Javascript的基础语法。《DOM编程艺术》用了几页简单介绍了一下JS，我一看，这不跟C++很像吗？（后来知道真相的我眼泪掉下来，一个巨大的坑）。反正就是直接用上getElementById这些了，然而每次获取一个节点都需要写老长一段代码，当时就想代码就不能短一点吗？\r\n<!--more-->\r\n直到开始学习jQuery的时候，才发现这！简！直！酷！炫！顾名思义，jQuery的查找方法非常强大。下面是学习的时候做的一点笔记，主要是关于前面的基础知识，至于Ajax和Jquery插件我打算单独写篇文章。总结的并不完善，参考[jquery官方文档](https://api.jquery.com/)\r\n## 脑图笔记\r\n![jquery学习笔记](/uploads/jQuery.png)\r\n## 锋利的jquery学习笔记\r\n\r\n层次选择器中+ ~比较少用的原因\r\n>使用$(\".one\").next(\"div\")代替$(\".one + div\");\r\n>使用$(\".one\").nextAll(\"div\")代替$(\".one ~ div\")\r\n\r\n注意选择器中空格是使用\r\n>有空格 在后代中寻找\r\n>无空格 在同类中筛选\r\n\r\nfilter()与find()\r\n>filter()相当于把一长串过滤选择器的条件单独作为其参数了，结果是一样的，即对指定对象集合进行过滤，过滤的是当前对象\r\n>find()是在指定对象集合下进行查找，寻找的是子元素\r\n\r\nis()方法的使用\r\n>是判断调用该方法的对象是否符合其参数（一个筛选器），如果如何返回true，多用做判断语句中\r\n\r\n区分部分过滤选择器索引值\r\n>eq(),gt(),lt(),even(),odd()等方法的索引值从0开始\r\n>nth-child()索引值从1开始\r\n\r\n区分删除节点的三种方法\r\n>remove(),删除调用对象及其所有子对象，所有事件/附加数据消失，返回该对象，可通过传参选择删除对象\r\n>detach(),同上，但保留事件及附加数据\r\n>empty()并非删除元素，而是清空该元素。\r\n\r\nchildren()、next()和prev()\r\n>children()只返回第一代子元素节点,而不会考虑其他后代节点及非元素节点。\r\n>next()与prev()方法返回的只是紧邻的那一个元素节点\r\n\r\n几个关于位置坐标的方法\r\n>offset()返回left和top相对于当前视窗的偏移\r\n>position()相对于最近的定位祖先的偏移,这两个方法都有自己的属性left和top\r\n>crollTop()/scrollLeft()滚动条顶端及左端距离\r\n\r\n合成事件hover和toggle\r\n>hover事件模拟鼠标移入及移出\r\n>toggle模拟鼠标点击并按顺序执行事件处理函数\r\n\r\nevent.which()\r\n>事件为鼠标时 1:鼠标左边/2：中键/3：右键\r\n>事件为键盘时 按键的名称\r\n\r\n动画回调函数的作用\r\n>将不能进入动画队列的方法放入回调函数，形成队列的伪效果。\r\n\r\nstop()方法及其两个参数\r\n>无参数：只会停止当前正在执行的动画任务\r\n>第一个参数：true清空包括正在执行的与尚未执行的全部动画队列\r\n>第二个参数：使正在执行的动画直接达到结束时刻的状态，通常用于后一个动画需要基于前一个动画的末状态时才使用，注意的是只是针对于当前执行的动画末状态而非整个动画队列的末状态\r\n\r\nstop()与is(\":animated\")\r\n>stop常用于解决光标移入移出得过快导致的动画效果与光标动作不一致“问题！\r\n>is(\"animated\")常用于”连续点击上/下一张按钮，只响应用户第一次点击动作“时使用。\r\n\r\nattr()与prop()的区别\r\n>只添加属性名该属性就生效则使用prop();\r\n>值存在true/false的属性应该使用prop();\r\n>官方的说法是：如果设置的是disabled和checked这些属性应该使用prop方法，否则在某些浏览器下会出现BUG\r\n\r\n## 最后\r\n众多前辈都说到，jQuery只是一个库，并不能完全依赖，归根结底还是要回到JS上面，因此我打算研究一下jQuery的源码，可是现在的JS功底烂的一塌糊涂，加油吧。目前能做的就是谨遵教诲，用好jQuery。\r\n';
INSERT INTO shymean_article SET `title` = '浏览器解析HTML的流程', `created_at` = 1487477422, `category` = 'HTML', `tags` = '浏览器', `content` = '\r\n\r\n很早之前就对浏览器加载整个页面文档以及相关的执行顺序十分好奇，但是却一直没有深入。尤其是JavaScript这块，只知道JavaScript是单线程模型，却对于这个概念却一直没有很理性的认识。想到之前看见一篇关于浏览器中定时器的文章，介绍了浏览器中setTimeout的机制，才发现自己对关于页面上JavaScript的执行顺序给弄混了。\r\n最近正重新阅读犀牛书，在第13章“Web浏览器中的JavaScript”中，终于得到了一些答案。\r\n\r\n<!--more-->\r\n\r\n参考文章:\r\n* [JS 和 CSS 的位置对其他资源加载顺序的影响](https://lifesinger.wordpress.com/2012/02/03/performance-impact-of-js-css-loading-order/)\r\n* [JavaScript 的性能优化：加载和执行](http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/)\r\n* [你应该知道的setTimeout秘密](http://ghmagical.com/article/page/id/H61NOVU0RZ9Y)\r\n\r\n## 处理网页\r\n\r\n根据我的理解，浏览网页的过程可以简化为：在浏览器地址栏输入地址，访问某台主机（通过DNS域名解析或直接是IP地址），通常这台主机上运行着web服务器，根据我们输入的地址调用相关路径的程序（可能是某个.php文件），这个程序会调用数据库，然后使用返回的数据生成HTML页面，最后返回给发起请求的浏览器，浏览器解析这个HTML文档，并呈现给用户。\r\n整个“从地址栏输入地址到看见整个网页”的过程非常复杂，这也是我这几个月以来需要弄明白的东西。这篇文章可以算作是了解这个流程中“浏览器接受到HTML文档到呈现出整个页面”这段时间发生的事情。\r\n\r\n浏览器接收到HTML文档之后，会经历三个阶段:__加载__，__解析__和__渲染__，最后才呈现整个页面。令人头疼的是，这三个阶段并不是按顺序线性执行或者各自独立执行的，有时会出现交叉工作的情形。\r\n\r\n### 渲染页面\r\n浏览器需要解析HTML构建DOM树，解析CSS文件构建CSS规则树（这个只是firefox下的一个概念，不过先拿来用吧），然后再关联DOM树和规则树，构建渲染树，接着对渲染树中的每个节点进行布局，最后再绘制这个页面。\r\n浏览器如何渲染页面是也是一个很复杂的问题，今天的重点了解浏览器是如何加载和解析外部文件的。\r\n\r\n### 加载外部文件\r\n通常，一个HTML文档不仅仅只是文本，还包含样式表，js脚本和其他多媒体资源，其中：\r\n* 样式表需要加载和解析，样式表可以使用style标签嵌套在页面内，也可以使用link标签的href属性引入外部样式表\r\n* js脚本需要加载，解析并执行，js可以使用script标签嵌套在页面内，也可以使用script的src属性引入外部脚本\r\n* 其他如img，video等多媒体资源需要被加载\r\n\r\n### 解析样式表和脚本\r\n当浏览器从上到下解析整个HTML文档时，\r\n* 如果遇见内联的样式表，就会立即解析（但不一定会立即渲染出样式）；如果遇见内联的脚本，就会立即解析和执行；\r\n* 如果遇见外部URL资源，就会发送请求加载对应文件（貌似现代浏览器可能会同时发送多个请求加载文件）。\r\n\r\n但是！需要注意的是，在遇见普通的script时，不论他是内联脚本还是外部脚本，都会阻塞浏览器进一步解析HTML文档（即暂时无法处理这个脚本后面其他需要加载的URL），而必须等待该标签代表的脚本文件执行完毕（如果是外联的脚本，甚至需要等到这个js文件加载成功并执行完毕），浏览器才会继续解析后面部分的文档，具体原因下面一一道来。\r\n\r\n## 浏览器中的JavaScript\r\n\r\n浏览器中的JavaScript最主要的功能就是DOM编程\r\n\r\n### 嵌入方式\r\n前面提到，可以直接在script标签中书写JS代码（内联脚本），也可以通过指定script标签的src属性来加载外部js文件（外联脚本），当然，这两者不能同时使用一个script标签实现，带有src属性的script标签会忽略标签内部的信息。\r\n此外，还可以通过放置在URL中的javascript标识来表示一段JS代码\r\n```html\r\n<a href=\"javascript:window.history.back();\">返回</a>\r\n```\r\n或者在html标签的事件属性中执行JS代码\r\n```html\r\n<button onclick=\"alert(\'hello\')\">click</button>\r\n```\r\n后面两种嵌入JS代码的方式现在已经很少使用了。并且他们需要在某些特定的情形下才会执行，后面会提到，我们先关注最普通的JS代码。\r\n\r\n可以把普通的带有src属性的外部script标签看作是外部文件的JS代码内容直接出现在标签内一样（当然需要外部文件加载成功），浏览器从根据script标签的出现顺序依次解析和执行相关js代码，整个文档上的全部script标签，共用一个window全局对象，共用一个document对象，共用全局变量和函数。\r\n\r\n### 运行机制\r\nJavaScript是单线程执行的，这里的单线程指的是任意时间都有且只有一个线程运行javascript代码。具体来说，JS程序的执行有两个阶段：\r\n* 第一阶段，在载入文档阶段（即文档没有被完全解析），script中的代码通常是按照他们在文档中出现的顺序执行，即从上到下，按照他在条件，循环，以及其他控制语句中出现的顺序执行。\r\n* 当文档载入完成，且所有脚本执行完成之后，JavaScript执行就会进入他的第二个阶段，这个阶段是异步的且有事件驱动的。通常是由第一阶段注册的事件处理程序来响应异步发生的事件。\r\n\r\n此外，在第一阶段调用的诸如定时器之类的也会再第二阶段执行（详情见:[你应该知道的setTimeout秘密](http://ghmagical.com/article/page/id/H61NOVU0RZ9Y)）。\r\n```javascript\r\nvar start = new Date();\r\nvar end = 0;\r\nsetTimeout(function() {\r\n  console.log(new Date() - start);\r\n},  500);\r\n\r\nwhile (new Date() - start <= 1000) {}\r\n```\r\n如果将这段代码放在头部，并且文档内容比较庞大的话，可能打印得到的结果会远远大于所指定的500ms，原因不仅仅是while的同步代码占用了1000ms，且解析文档也会花费时间。\r\n也就是说，JavaScript必须将全部的同步代码执行完毕，才会进入第二阶段执行异步的代码。所谓的定时器，是指在全部同步代码执行完开始，最快将在指定的时间间隔后调用相应的回调函数，但是并不能保证肯定就是这个时间段开始执行，如果两个定时器具有相同的回调函数和时间间隔，他们的执行也不是同时进行的。\r\n\r\n经常看见的一种做法是\r\n```javascript\r\nsetTiomeout(function(){\r\n\t// todo\r\n},0)\r\n```\r\n相当于改变了函数体内代码的执行时机，使同步代码转为异步执行，然而浏览器默认有最低的时间间隔（一般不低于4ms）。\r\n\r\n\r\n### 脚本阻塞\r\n加载js脚本会阻碍浏览器继续HTML文档最主要的原因是，JS可能影响后续的文档，可能向文档流中插入信息，也可能改变后续script脚本的全局变量。因此浏览器干脆在解析和执行script标签的时候，阻塞后续文档的解析，\r\n\r\n举个例子，普通的JS脚本无法操作出现在他后面的DOM结构，他只能通过`document.write()`方法来生成文档内容。如果先解析后面的文档再执行前面的js脚本，则可能导致后面文档解析没有意义（比如后面的指定下载的资源是没有必要的），为了防止在JS中可能包含的`document.write()`方法影响后面的文档内容，所以浏览器会在遇见同步的script脚本时，阻塞后续文档的解析和渲染。\r\n\r\n这种机制带来的最大问题是，如果需要加载和执行的脚本文件很多，则页面在渲染完成之前会出现长时间的空白，如果是需要加载外部文件然后再解析和执行的js脚本来说，阻塞的时间可能会更长，这也是为什么大多数教程说将script脚本放在页面底部。\r\n\r\n实际上，还有另外两种解决脚本阻塞的方案：使用__defer__（延迟脚本）和__async__（异步脚本）。\r\n一般地，defer和async属性都只能用在使用src引入外部脚本的script标签上。两个属性都像是对浏览器声明：这个script标签里面不包含`document.write()`，不会影响文档流，关于变量作用域的问题我们也已经考虑了，你尽管加载这个文件并同时后面解析文档（不用等待这个脚本下载并解析并执行完毕了）。其中：\r\n* defer表示推迟脚本到整个文档载入和解析完成之后再执行（最后还是按脚本引入的先后顺序执行）。\r\n* async表示异步加载脚本及解析和执行，而不阻塞后面文档的解析（外部文件下载完成后尽快执行，多个异步的脚本是谁先下载完谁先执行，因此是无序执行）\r\n\r\n如果同时存在async和defer属性，浏览器将忽略defer属性。\r\n\r\n### 小结\r\n现在我们了解了普通、阻塞的脚本，也了解了延迟、异步的脚本，并且知道了JavaScript执行的两个阶段，现在，让我们总结一下页面中整个JavaScript脚本从加载到解析再到执行的整个流程（摘抄自《JavaScript权威指南》13.3.4节）。\r\n* 首先浏览器创建了Document对象，然后开始解析Web页面，解析HTML元素和它们的文本内容添加Element对象和Text节点到文档中。此时document的readyState属性的值是`loading`;\r\n* 当HTML解析器遇到没有async和defer属性的script标签，它把这些元素添加到文档中，并执行行内或外部脚本，这些脚本会同步执行，并且在脚本下载和解析时解析器会暂停，这样脚本就可以使用document.write()来把文本插入到文档流中，在HTML解析器恢复工作之后，这些文本将成为文档的一部分。此外，这些脚本也可以操作他们之前的DOM结构。\r\n* 当浏览器遇见设置了async的脚本，它开始下载文本，并继续解析文档，脚本会在他下载完成后尽快执行，但是解析器没有停下来等他下载；当浏览器遇见设置了defer的脚本，他开始下载文本，并继续解析文档，但是defer脚本即使下载完成也不会立即执行\r\n* 当HTML文档完成解析，docuemnt的readyState属性变成了`interactive`（这个词的意思是互动）。此时所有设置了defer属性的脚本，按照他们在文档里的出现顺序执行，意味着延迟脚本可以访问完整的文档树。此时，可能存在刚下载完毕的async脚本，他们也会执行。\r\n* 所有的脚本执行完毕（不包括async异步脚本）,document对象触发`DOMContentLoaded`事件，这标记着JavaScript运行从第一阶段（同步执行阶段）转换到第二阶段（异步事件驱动阶段）。此时，虽然文档已经全部完成解析，但是浏览器可能还在等待其他内容载入，如图片等，当这些内容完成载入，且所有的异步脚本都完成载入且执行完毕，document对象的readyState属性改变为`complete`，window对象触发`load`事件。\r\n* window对象触发onload事件之后，开始调用异步事件，以异步响应用户输入事件，网络事件和定时器到期等\r\n\r\n## 样式表阻塞\r\n还必须注意的一个问题是，当HTML解析器遇见一个style标签时，会按顺序解析里面的样式；当HTML解析器遇见一个link标签，会发送一个外部样式表的请求。这样的后果是到导致后面的后面的JS代码：\r\n* 如果是内联脚本，则必须等待前面的样式表加载和解析完成才会执行\r\n* 如果是外部脚本，浏览器会发送下载外部脚本文件的请求（CSS文件和JS文件可能同步下载），即使文件已经返回，也必须等待前面的样式表加载和解析完成\r\n\r\n这么限制的原因是JS执行依赖最新的CSS渲染（或者说最精确的样式信息）。浏览器心想我这里正在加载一个样式表，不做点什么的话，万一后面的脚本向我要这个元素的宽度，我还没解析，啥都都不知道，怎么告诉你嘛，干脆JS先别执行，等我知道最新的样式了你再问准没错。这样，即使后面的脚本不去查询元素的样式，脚本的运行还是会被CSS文档的加载阻塞。因此有些对性能要求非常挑剔的页面，是通过内联样式表的形式来加快速样式的解析和脚本的执行的。\r\n\r\n好吧，上面的情形是我YY的。这个结论是我在[JS和CSS的位置对其他资源加载顺序的影响](https://lifesinger.wordpress.com/2012/02/03/performance-impact-of-js-css-loading-order/)这里看见的。我需要学习开发者工具的Timeline面板来查看具体的时间信息了，这里待我回头补充。\r\n需要注意的是，CSS文档的加载和解析，阻塞的是脚本的执行而不是脚本的加载。而同步JS脚本的加载解析和执行，是会影响HTML解析器的工作，导致后面的所有资源都无法被加载。\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '正则表达式之捕获', `created_at` = 1474899953, `category` = 'JavaScript', `tags` = '正则', `content` = '\r\n最近刚好搞定CSS选择器命名的问题（勉强能够心平气和的写样式表，姑且算作是解决了一个疑问吧），然后开始阅读jQuery源码，虽然很早之前就曾经打开看过，当时看见弟六十几行定义的几个正则，然后一脸蒙蔽，悻悻然关闭了编辑器。然而，jQuery源码迟早是要读的，正则也是必须要掌握的，最重要的一点是：并没有什么知识是不可能学会的！既然如此，那就先从正则入手吧。\r\n<!--more-->\r\n## exec()方法\r\njQuery前面定义的这几个正则用来进行快速匹配和单标签匹配：\r\n```javascript\r\nrquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\r\nrsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\r\n```\r\n可以看见中间的(?:)。那么，这个带括号的问号究竟是什么呢？经过一番折腾，终于对正则表达式的__\"捕获\"__有了一点认识。这是参考的[一篇文章](http://www.cnblogs.com/yakun/p/3795589.html)。\r\n在前面的[《初识正则表达式》](https://tangxiangmin.github.io/2016/07/18/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/)这篇文章中，对于小括号的作用只是进行了简单的描述：改变限定符的作用范围和分组\r\n```javascript\r\n// 改变作用域范围\r\nvar re1 = /(a|b)c/;\r\n// 分组\r\nvar re2 = /(ab){2}c/;\r\n```\r\n这里的分组，实际上是创建子表达式，提到子表达式，就不得不再提到一个更重要的正则对象方法：exec()。exec()方法用来返回字符串中符合对应正则表达式的子字符串。\r\n```\r\nvar re = /\\d{2}/;\r\nconsole.log(re.exec(\"asd78aa\"));//[\"78\", index: 3, input: \"asd78ss\"]\r\nconsole.log(re.exec(\"asdaa));//null\r\n```\r\n可以看见，如果匹配成功，实际上exec返回的是一个数组arr，arr[0]表示所匹配到的文本，index表示该文本的索引值，input即为原字符串。但是，这个返回值并不仅仅有这些属性，如果正则表达式中存在子表达式的时候：\r\n```javascript\r\nvar re = /(\\d{2})aa/;\r\nconsole.log(re.exec(\"asd78aa\"));//[\"78aa\", \"78\", index: 3, input: \"asd78aa\"]\r\n```\r\n则对应的arr[1]为正则表达式中第一个子表达式所匹配到的值，如果存在多个子表达式（也就是多个分组括号），则从左到右依次将子表达式所匹配到的文本存放在对应索引值位置\r\n```javascript\r\n//从arr[1]开始，依次存放子表达式匹配值\r\nvar re1 = /(\\d{2})(aa)/;\r\nconsole.log(re1.exec(\"asd78aa\"));//[\"78aa\", \"78\", \"aa\", index: 3, input: \"asd78aa\"]\r\n\r\n// 嵌套情况下也是从左到右\r\nvar re2 = /(\\d{2}(xyz))aa/;\r\nconsole.log(re2.exec(\"asd78xyzaa\"));//[\"78xyzaa\", \"78xyz\", \"xyz\", index: 3, input: \"asd78xyzaa\"]\r\n\r\n// undefined\r\nvar re3 = /(\\d{2})|(xyz)/;\r\nconsole.log(re3.exec(\"asd78xyz\"));//[\"78\", \"78\", undefined, index: 3, input: \"asd78aaxyz\"]\r\n```\r\n上面的undefined是什么鬼？这是因此没有设置全局模式的缘故，第一次返回匹配结果(78)的时候，并没有匹配到第二个子字符串(xyz)的文本，因此使用undefined进行填充（注意，这里是理解捕获与非捕获十分重要的一点，也就是说，实际上无论匹配是否成功，默认都会对对应索引值元素进行填充）。\r\n```javascript\r\n//加上全局模式\r\nvar re3 = /(\\d{2})|(xyz)/g;\r\nconsole.log(re3.exec(\"asd78xyz\"));//[\"78\", \"78\", undefined, index: 3, input: \"asd78xyz\"]\r\nconsole.log(re3.exec(\"asd78xyz\"));//[\"xyz\", undefined, \"xyz\", index: 5, input: \"asd78xyz\"]\r\nconsole.log(re3.exec(\"asd78xyz\"));//null\r\n//此时lastindex重置为0\r\nconsole.log(re3.exec(\"asd78xyz\"));//[\"78\", \"78\", undefined, index: 3, input: \"asd78xyz\"]\r\n```\r\n也就是说，可以通过判断返回结果是否为null，可以获取整个字符串中完整模式匹配信息。\r\n\r\n## 捕获\r\n### 定义\r\n使用小括号指定一个子表达式后，匹配这个子表达式的文本（即匹配的内容，也就是上面的arr[1],arr[2]...的值）可以在表达式或者其他过程中进一步进行处理，这个大概就是捕获的定义。\r\n所谓的进一步处理，实际上是使用子表达式的结果来限定实际正则表达式（整个正则表达式）的输出结果（限定这个词是我自己理解所想到的词儿，若有错误还请指正）。这些限定包括：非捕获组(?:)，前查找(?=)，后查找(?<=)。\r\n### 非捕获组\r\n在某些情况下：比如需要使用某个限制条件匹配正则，但是又不希望在输出结果中看键这个限制条件。这时，就可以使用非捕获分组来达到这种效果。\r\n```javascript\r\nvar re = /(?:\\d{2})xyz/g;\r\nconsole.log(re.exec(\"asd78xyz\"));//[\"78xyz\", index: 3, input: \"asd78xyz\"]\r\n```\r\n可以看见，虽然存在子表达式(\\d{2})，但是并没有在exec()输出结果中看见该子表达式对应的匹配（前面提到，即使没有匹配到结果，也会使用undefined进行占位）。使用非捕获组的用途，大概就是为了去除输出结果中无效的undefined的吧（有可能不是这么回事儿）。\r\n\r\n### 前查找\r\n仍然考虑一种情况：我们需要匹配的目标字符串，是通过其后面的文本特征进行匹配的（比如找到后三位是xyz的目标文本）。这种情况下就可以使用前查找(?=)。\r\n```javascript\r\nvar re = /\\d{2}(?=xyz)/g;\r\nconsole.log(re.exec(\"asd78xyz\"));//[\"78\", index: 3, input: \"asd78xyz\"]\r\n```\r\n如果是连续的字符串匹配会发生什么情况呢？\r\n```javascript\r\nvar re = /xyz(?=xyz)/g,result;\r\nwhile ((result= re.exec(\"asd78xyzxyzxyzxyz\")) != null) {\r\n    console.log(result);\r\n    //[\"xyz\", index: 5, input: \"asd78xyzxyzxyzxyz\"]\r\n\t//[\"xyz\", index: 8, input: \"asd78xyzxyzxyzxyz\"]\r\n\t//[\"xyz\", index: 11, input: \"asd78xyzxyzxyzxyz\"]\r\n}\r\n```javascript\r\n通过查看index属性可以看到，每次匹配结束后的下一次匹配，是从刚才匹配过的(xyz)结尾的字符开始的（有点绕，实际上第一次匹配，只是确认目标字符串存在指定的那个限定条件，并不影响该限定条件位于的文本参加下一次匹配）。\r\n实际上前查找还有一种写法(?=\\d{2}xyz)\\d{2}\r\n```javascript\r\nvar re = /(?=\\d{2}xyz)\\d{2}/;\r\n// 实际上跟/\\d{2}(?=xyz)/是等效的\r\nconsole.log(re.exec(\"asd78xyz\"));//[\"78\", index: 3, input: \"asd78xyz\"]\r\n```\r\n看上去这种写法并没有前面那种表达式直白，毕竟前面的写法更能表达“目标表达式后面存在XXX限定条件”的意思。\r\n再来一点有意思的：如果要匹配“目标表达式后面不存在XXX限定条件”这样的文本该怎么做呢？只要把\"=\"换成\"!\"即可，也就是(?!)：\r\n```javascript\r\nvar re = /\\d{2}(?!xyz)/;\r\nconsole.log(re.exec(\"asd78aa\"));//[\"78\", index: 3, input: \"asd78aa\"]\r\n```\r\n只是跟前面的限定条件完全相反，其他是一样的。\r\n\r\n### 后查找\r\n故名思意，这个捕获需要匹配“其前面存在XXX限定条件的目标表达式”，然而！！！JS并不支持后查找(?<=)，呃，这特么就尴尬了。也许将怎么字符串反转，再将目标表达式反转，然后再使用查找....-_-||好麻烦的样子。\r\n上论坛然后有之前的讨论里面提到了[这篇帖子](http://blog.stevenlevithan.com/archives/mimic-lookbehind-javascript)，用以参考。\r\n那么如何实现后查找呢？（待我挖个坑，后面再回来填）。\r\n\r\n\r\n\r\n\r\n\r\n\r\n';
INSERT INTO shymean_article SET `title` = '浮动与清浮动', `created_at` = 1465128194, `category` = 'CSS', `tags` = '布局, 浮动', `content` = '\r\n浮动是布局中一个非常非常非常重要的概念，刚开始学的时候以为只要写了个float:left就已经掌握浮动了。直到后来遇见了各种莫！名！其！妙！的问题，是时候扒一扒浮动了。\r\n<!--more-->\r\n\r\n## 文档流\r\n学习浮动，首先需要明白文档流的概念：文档流是默认的网页布局模式，是文档中的对象在排列时所占用的位置。在文档流中，块状元素从上到下排列；内联元素（及内联-块状元素）从左到右排列。\r\n对于块状元素而言，如果不设置其宽度，在默认情况下（非浮动、绝对定位等），会在水平方向上自动填满外部的容器；如果设置了宽度，块状元素仍然以行的形式占据位置。也就是说不论如何，普通的div都是独占一行的。\r\n\r\n## 浮动\r\n有位前辈说，“不管多么复杂的布局，其最终目标是都为了在同一行排列多个div元素”，因此，鉴于普通块级元素独自霸占一行的做法，我们就需要对它做一点事，使之变得“不再普通”，也就是常说的使块级元素脱离普通文档流，从而达到布局的目的。使元素脱离文档流一般有浮动和定位两种做法。当然会这篇文章的主角儿肯定是浮动啦。\r\n元素（不论是块级元素还是内联元素），加了浮动属性之后会脱离文档流，并按照指定的方向移动，碰到其父容器边界或者是另外一个浮动元素才停下来。\r\n浮动元素的影响可以分成三部分：\r\n* 对于自身的影响；\r\n* 对于其他的同级非浮动元素的影响；\r\n* 对于其他的同级浮动元素的影响。\r\n\r\n### 浮动元素对自身的影响\r\n浮动的元素会触发形成BFC，具有BFC的一些布局特性。\r\n* 由于块级元素的流动特性可知，在不设置宽度的默认情况下其宽度会尽可能铺满一整行。而当块级元素浮动之后其宽度由预先指定的宽度或其内容决定。\r\n* 浮动的元素都会变成类似于块级元素的状态，也就是说可以为一个浮动的span设置宽高（但是并不会在其style中显示display:block）。\r\n* 浮动元素在竖直方向上会尽可能的向父容器上方壁靠拢，当然具体的位置需要参考“对于其他的同级浮动元素的影响”这一点。\r\n* 浮动元素的\"pading\"\"border\"\"margin\"属性仍然存在，这是显而易见的，毕竟这些都是盒子模型的一部分，且不会发生外边距折叠。\r\n\r\n### 对其他的同级非浮动元素的影响\r\n根据浮动元素会”脱离文档流“的性质，其原本在文档流中的位置会被后面的非浮动元素上移所占据。\r\n这里会发生一个很有意思现象，跑上来的块元素的背景色会被这个浮动元素“部分”遮住，但是这个块元素里面的文字内容并不会被遮挡，从而出现文字环绕浮动元素的现象。（甚至于当浮动元素完全遮挡移动上来的块元素，其内容也不会被遮挡）。此外，如果浮动元素后面是内联元素也不会被遮挡，而是围绕在浮动元素周围。\r\n因此，这里有很重要的一条结论：虽然浮动元素脱离了文档流，但是仍然会影响布局。\r\n\r\n### 对其他的同级浮动元素的影响\r\n根据浮动元素“照指定的方向移动，碰到其父容器边界或者是另外一个浮动元素就停下来”的特性，浮动的元素在其指定方向上浮动时，如果前方有另一个已经“浮动完成”的元素，他就会停下来。\r\n如果浮动元素所在的那一行（按前一个已经浮动完成的元素高度计算该行高），所有浮动元素的宽度之和已经超出了容器的宽度，那么最后那个浮动元素会另起一行（紧贴着上面那一行高度的下面），重新朝指定方向浮动（我只是瞎猜的这个过程，具体发生了什么我没有查到相关资料），如果仍然碰见了另外一个浮动元素，则重复上面的过程，直至最后停靠在某个浮动元素的旁边或者是指定方向的父容器壁（除非浮动元素其本身设定的宽度就大于父容易的宽度，那么他就直接浮动在没有任何浮动元素且尽可能靠上方的那一行）。\r\n资料上一般就几句话，我这好像还给他弄复杂化。这也是经常出现浮动的块没有出现在预期位置的原因，很可能就是宽度没计算好，多了那么一两个像素的缘故。这段话表述的很混乱，但是只想表达一个意思：弄明白一个浮动的元素最后摆放的位置。\r\n\r\n## 清浮动\r\n在实际的布局中，经常不设置父级盒子的高度，而是由内容自动决定的。在这样的前提下就可能发生子元素浮动脱离了文档流，导致父级元素高度塌陷甚至消失的情况，这样就会使容器内的内容溢出到外面，甚至发生布局破坏的情况。此时就需要进行清除浮动处理。\r\n清除浮动主要有两种做法，一种是采用clear属性，这是真正意义上的清除；而另一种是使父元素正确计算其高度，也就是使父元素触发BFC。\r\n### clear\r\nClear属性属性值为left right both none等，表示具有该属性的元素其对应方向侧边不靠着浮动元素。因此利用该属性可以清除左右两侧的浮动。一般的做法是为父容器内最后增加一个带有.clear{clear:both;}的块，但是这样做会增加很多无语义的标签，增加代码量，所以又有了利用:after 伪类的做法\r\n```\r\n.clear { zoom: 1; } \r\n.clear:after { content: \"\";display: block; clear: both; }；\r\n```\r\n\r\n### bfc\r\n由于BFC可以包含浮动的特性，因此，只要使父容器触发了BFC就可以解决高度塌陷的问题。当然BFC也不是全能的，比如两个元素浮动之后处于同一行，则BFC计算的高度就是两个元素中高度较大的那个。具体如何取舍需要看具体的要求吧。';
INSERT INTO shymean_article SET `title` = '选择器中的空格', `created_at` = 1465136446, `category` = 'CSS', `tags` = '选择器', `content` = '\r\njQuery的选择器跟CSS十分相似，在学习的时候发现之前忽略的一个关于CSS选择器问题：选择器中的空格。尽管在写CSS样式的时候并没有在这个问题上犯错，但是之前学习选择器都是抱着“概念我看看就行了，记那些干什么”的“不求甚解”的态度，然后在使用jQuery的时候就进了不少坑。现在就来说一说选择器中的空格。\r\n<!--more-->\r\n## 区分\r\n首先，不带空格与带空格所组成的选择器是完全不同的。拿p.red{color:red;}和 p .red{color:red;}来讲：\r\n* 前者在样式表中没有空格，表示带有.red类的p元素字体颜色为红色，用逻辑运算符来说就是“&”的关系。再比如.red1.red2{color:red;}，只有class=”red1 red2”同时带有这两个类的元素其字体才为红色（red1 red2顺序可以交换），这种不带空格的选择器是多类选择器。\r\n* 后者在样式表中有空格，表示的是p元素的所有后代中带有red类的元素其字体显示为红色。选择器之间的空格是一种结合符，可以解释为“...在下面的...”、“...作为...的后代”，这种带有空格的选择器是后代选择器。\r\n\r\n好了，这原本就只是两个概念，并没有什么好说的，需要注意的重点大概是选择器权重值的计算（权重值点这里）。但是！当在jQuery中碰见过滤选择器的时候，我发现我真是天真啊。\r\n## 过滤选择器\r\njQuery中除了最原始的基础选择器与层次选择器之外，最为强大的便是过滤选择器。具体又细分为索引号过滤、内容过滤、可见性过滤、属性过滤、后代过滤、表单过滤等情形。在过滤选择器中，使用空格与不使用空格，获得的结果是迥然不同的。对于过滤选择器加上了空格的来说，它所获取的是其子元素的过滤；而对于过滤选择器没有加上空格的来说，它所获取的是其自身元素的过滤。\r\n在上述的过滤选择器中还有一个蛋疼的子元素过滤选择器，比如下面的例子：\r\n```\r\n\t.r {\r\n    \tcolor: red;\r\n    }\r\n\r\n    <ul>\r\n        <li><span>111</span> <span>xxx</span></li>\r\n        <li><span>333</span> <span>kkk</span></li>\r\n    </ul>\r\n```\r\n$(\"li :nth-child(1)\").addClass(\"r\")(有空格)表示每个li下的第一个span元素字体变红了，没错；\r\n$(\"li:nth-child(1)\").addClass(\"r\")（无空格）表示li为其父元素下的第一个子元素的那个li字体为红色。（这里在增加一个ul会更加明显）；\r\n但是！我在测试这里的时候遇见了一个问题，当使用$(\"ul :nth-child(1)\").addClass(\"r\")（有空格），按照理解应当是ul下的第一个li元素内字体变红，但是第二个li下的第一个span其字体颜色也会变红。我正在找原因（原因已经找到：空格表示的是所有的后代元素，这里的选择器表示ul下所有为其父元素的第一个子元素都会增加.r类，符号该条件的元素有ul下的第一个li子元素，li下的第一个span元素，因此弄明白__空格表示全部的子元素是十分重要的__，如果需要达到前面的要求，应当使用第一代子元素操作符\">\"）。\r\n子元素过滤选择器的目的应当是操作目标元素下的子元素（即使用空格的版本）。此外注意表单过滤选择器之间是必须要加空格的。\r\n\r\n## 最后\r\n这种加空格并不是可有可无而是生死攸关的，至于为什么现在才发现这个问题，反思了一下，我特么好像就没有使用过多类选择器啊！！！习惯性的元素之间换空格，导致学习jQuery进到坑里面去了。这个加空格的方式让我想起了python中强制缩进的规定，天知道我怎么把他们扯上关系的。不过加空格与不加空格没有多大区别这个先入为主的观念大概是学习运算符的时候为了规范代码格式而造成的。这件事最大的收获不是知道了有空格与没有空格的区别，而是提醒了学习中的东西不能”想当然“的去看待！';
INSERT INTO shymean_article SET `title` = '负margin值', `created_at` = 1470141440, `category` = 'CSS', `tags` = '布局', `content` = '\r\n最近在看bootstrap源码的时候发现栅格系统.row类的默认设置了左右各自-15px的外边距，十分好奇，虽然之前就知道在标准中外边距是可以设置为负值，但是一直都没有深入思考负margin值的作用，然后在搜索这个字段的时候发现网上已经有不少出色的文章来介绍负margin的用途。在经过简单的demo测试后整理了这篇文章。\r\n\r\n<!--more-->\r\n\r\n这是参考的两篇文章：[负margin在页面布局中的应用](http://www.cnblogs.com/jscode/archive/2012/08/28/2660078.html)和 [CSS布局奇淫巧计之-强大的负边距](http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html)。\r\n\r\n## 外边距\r\n首先需要简单的回顾一下外边距：\r\n外边距是盒子模型中的组成部分之一，即围绕在元素边框之外的那段空白区域。margin是支撑div布局的基础属性值，我们平常看见文档流中的两个元素之间的距离，就是由这两个元素在对应方向上的外边距之和。也就是说，在文档流中，元素的最终边界是由margin决定的。\r\n那么当margin为负数时会怎么样呢？margin为负的时候就相当于元素的边界向里收，文档流认的只是这个边界，不会管你实际的尺寸是多少。\r\n思考一下，负的外边距的意义是什么呢？\r\n\r\n## 负的外边距\r\n前面提到，我们看见的两个元素之间的距离（这里就不考虑定位的问题了），是由这两个元素在对应方向上的外边距代数和决定了，如果该代数和为负值，即代表他们之间的距离为负值，在这种情况下两个元素部分覆盖的现象。\r\n但是使用负margin值形成的元素覆盖与使用浮动或者定位形成的元素覆盖是不一样的：\r\n* 浮动的元素，会脱离文档流并按照指定方向漂移，并覆盖停止浮动时原本位置上的元素；\r\n* 使用定位的元素，是通过制定z-index设定层级并进行元素覆盖的；\r\n* 而使用负magin值，会影响文档流，却并不是像浮动和绝对定位那样完全脱离文档流，也不是像相对定位那样完全占据原本的文档流位置。margin只是一个基本属性，负margin值也只是一个完全符合标准的属性值：\r\n\t* 元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向，覆盖之前的元素；\r\n\t* 设置margin-bottom/right为负数，元素并不会向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。\r\n\r\n## 作用\r\n由于margin也是盒子模型的一部分，因此利用负margin值，可以减小盒子在文档流所占据的空间，从而达到理想的布局效果。正是这个原因，利用负margin值可以很简单的生成一些经典的布局。\r\n### 清除子元素右边距\r\n最近某个项目里面的商品展示，每行三张图片，每两张图片中间有固定间距。这种布局在移动端还是十分常见的，大致思路就是使用浮动来实现，但是由于浮动需要为元素预留足够的宽度，否则元素会换行。之前的做法是使用:nth-of-type(3n){margin-right:0;}来实现，但是需要考虑nth-of-type选择器的兼容问题，因此这里使用负margin也不失为一种办法：\r\n```\r\n\t//css\r\n    ul,li { list-style:none; margin: 0; padding: 0}\r\n    .wrap { width: 320px; height: 300px ;background: #ccc; }\r\n    .wrap  ul { margin-right: -10px ;}\r\n    .wrap  li { \r\n        width: 100px; height: 100px; float: left; margin-right: 10px;\r\n        background: red; \r\n    }\r\n    //html\r\n    <div class=\"wrap\">\r\n        <ul>\r\n            <li></li>\r\n            <li></li>\r\n            <li></li>\r\n        </ul>\r\n    </div>\r\n```\r\n只需要为ul设置一个负margin值就可以完美解决这个问题，上面提到过，将magrin-right设置为负，并不是让元素向右偏移，而是将更右边的元素向左拉进并覆盖现有元素（即使实际上更右边并没有这个元素）。\r\n### 竖直居中\r\n众所周知，水平居中是很容易就可以实现的，比如text-align:center;和margin:0 auto;这两个样式就够用了，但是竖直居中就比较麻烦了，在不知道父容器高度的情况下，实现竖直居中曾经是一件非常困难的事，但是使用负margin值可以轻松实现。\r\n```\r\n    .wrap { \r\n        width: 320px; height: 300px ; \r\n        position: absolute; top: 50% ;left: 50%;\r\n        margin-left: -160px; margin-top: -150px;\r\n        background: #ccc;\r\n    }\r\n```\r\n在某些不知道具体高度的情况下，可以使用transform:translateY(-50%)来达到竖直居中的效果。\r\n\r\n## 最后\r\n当然负的margin还能在其他的一些布局样式中大展身手，但是，鉴于负margin值对于文档流的这种不确定性影响（根据其数值大小），我觉得使用的时候还是应当慎重一点，此外，负的magin值也是存在一定的兼容性问题，这样的话更应该小心一些。\r\n最后，关于负的margin值，还有两个小细节：\r\n* margin值如果设置为百分数，具体计算数值是相对于父元素的width计算的;\r\n* 如果没有设定width属性，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样，具体原因目前并没有找到。';
INSERT INTO shymean_article SET `title` = '闭包函数', `created_at` = 1467730194, `category` = 'JavaScript', `tags` = '闭包', `content` = '\r\n理解闭包，首先需要理解JS的作用域链（简单理解JS中的变量作用域）。前面这篇关于JS作用域的博文是大概一个多月前刚接触JS的时候写的，内容十分粗糙，当时用的是一个“变量仓库”的概念来理解JS的作用域。最近刚看了《JS高级程序设计》这一块，知道了执行环境的概念，发现之前的理解居然算是歪打正着。接下来就是理清这些知识点了，其实主要的内容也就是一个函数从创建到结束调用整个过程中的细节问题。\r\n<!--more-->\r\n## 函数的流程\r\n\r\n### 创建函数\r\n在创建函数的时候，会创建一个预先包含包含全局变量对象的初始作用域链，这个作用域链保存在函数内部的[[Scope]]属性中；\r\n\r\n### 调用函数\r\n* 在函数被调用时，会创建一个__执行环境__，这里可以大致地将执行环境理解为函数作用域。执行环境定义了变量或函数能够有权访问的其他数据，并决定了他们各自的行为;\r\n* 完成执行环境创建之后，会复制函数的[[Scope]]属性中的对象，并构建起该执行环境的__实际作用域链__；\r\n* 完成作用域链创建之后，执行环境会创建一个表示函数内部变量的变量对象，并通过参数来初始化这个函数的__变量对象__，所有在该执行环境中定义的变量和函数都保存在这个变量对象中，作为该对象的属性和方法。（需要注意的是每个函数在调用的时候会自动取得this和arguments这两个变量，而该函数的变量对象不包含这两个特殊变量，取而代之的是一个arguments属性，该属性引用参数类数组对象）；\r\n* 完成变量对象创建之后，该变量对象会被推入执行环境作用域链的前端，因此，作用域链的本质是一个指向变量对象的指针列表。\r\n* 函数的执行过程中需要注意的细节是就是变量声明提前，这里不再赘述。\r\n\r\n### 执行完毕\r\n在一般的情况下，当函数执行完毕之后，局部变量对象就会被删除，内存中仅仅保留着作用域链末端的全局变量对象，但是在闭包函数的情况下就不一样了。\r\n## 闭包函数\r\n闭包函数指的是有权访问另一个函数作用域中的变量的函数，因此在一个函数内部所创建的函数就是一个闭包函数。\r\n定义的内部函数会将外部函数的变量对象添加至内部函数的作用域链中，即此时初始化的作用域链保活外部函数的变量对象与全局变量对象这两个变量对象，闭包函数的两个特点：\r\n* 第一个就是作用域链的特点，由于外部函数的变量对象包含了外部执行环境中定义的全部变量，因此内部函数就可以访问外部函数的变量；\r\n* 第二个的特点是当外部函数执行完毕之后，其执行环境的作用域链会被删除，却不会删除其自身的局部变量对象，因为其变量对象仍然保存在闭包函数的作用域链中，只有当闭包函数被销毁后，外部函数的变量对象才会被销毁，相当于延长了外部函数变量对象的生命周期。\r\n由于闭包函数的作用域链中保存的是外部函数的变量对象，因此只能获取外部变量的最后一个值（还记得那个老土的“变量仓库”的比喻么？后定义的值会覆盖先定义的值，同名函数会覆盖同名变量的值），比如下面这个例子：\r\n\r\n```\r\n    function out(){\r\n        var arrF = [];\r\n        for (var i = 0; i < 5; ++i){\r\n            arrF[i] =  function(){\r\n                return i;\r\n            }\r\n        }\r\n        return arrF;\r\n    }\r\n    var a = out();\r\n    for ( var i = 0; i < a.length; ++i) {\r\n        alert(a[i]());//这里输出的全部都是5，而不是0，1，2，3，4\r\n    }\r\n```\r\nJS中的匿名函数的执行环境具有全局性，所以其this通常指向window（这是书上的原话，且貌似是ES3时代的故意设计，[具体看这里](http://www.zhihu.com/question/21958425)，因此暂时没法深究。）。在闭包函数中调用this就可能出现问题，比如下面这个例子：\r\n```\r\n    var o = {};\r\n    function out(){\r\n        var x = (function(){\r\n            return this;\r\n        })();\r\n        return x;\r\n    }\r\n    o.f = out;\r\n    alert(o.f());//object Window\r\n```\r\n\r\n## 闭包的应用\r\n呃，就是这样，闭包就说完了！也不知道我理解的对不对，反正写下来就这几句话。闭包在JS中有如下几点应用：\r\n\r\n### 创建块级作用域\r\n可以模仿创建块级作用域，具体的做法是创建并立即调用一个函数，这样就可以避免全局变量污染，并且看着也十分高大上的样子,貌似有三种这样的写法：\r\n```\r\n    \"use strict\";\r\n    (function(){\r\n        var i = 1;\r\n        alert(i);//1\r\n    })();\r\n    alert(i);//报错\r\n\r\n    !function(){\r\n        var i = 1;\r\n        alert(i);//1\r\n    }();\r\n    alert(i);//报错\r\n\r\n    +function(){\r\n        var i = 1;\r\n        alert(i);//1\r\n    }();    \r\n    \r\n    (function(){\r\n        var i = 1;\r\n        alert(i);//1\r\n    })();\r\n    alert(i);//报错\r\n\r\n    !function(){\r\n        var i = 1;\r\n        alert(i);//1\r\n    }();\r\n    alert(i);//报错\r\n\r\n    +function(){\r\n        var i = 1;\r\n        alert(i);//1\r\n    }();\r\n    alert(i);//报错\r\n```\r\n就改动这么点东西居然写了三段代码，因为我想凑字数...第一次看见这些写法还完全不知道是什么呢！\r\n\r\n### 创建私有变量\r\n闭包也用于在对象中创建私有变量。对于在构造函数中定义的所有变量和方法，并不是公有属性和方法，因此无法被实例对象所访问，可以通过闭包的方式访问这些变量，并对他们进行操作。\r\n```\r\n    function Bird(){\r\n        var num = 0;\r\n        function fin(){\r\n            alert(\"private function\");\r\n        }\r\n\r\n        this.foo = function(){\r\n            num++;\r\n            fin();\r\n        }\r\n    }\r\n    var o = new Bird();\r\n    o.foo()\r\n```\r\n\r\n## 最后\r\n好吧，关于闭包大概现在就能写这么多，现在掌握的只是语法知识，距离实际使用还隔上十万八千里呢。刚工作十来天，一切都很忙，看书的效率变得好低，加油吧。';
