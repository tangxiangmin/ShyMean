---
title: 浮动与清浮动
date: 2016-06-05 20:03:14
tags:
	- 布局
	- 浮动
categories:
	- CSS
---
浮动是布局中一个非常非常非常重要的概念，刚开始学的时候以为只要写了个float:left就已经掌握浮动了。直到后来遇见了各种莫！名！其！妙！的问题，是时候扒一扒浮动了。
<!--more-->

## 文档流
学习浮动，首先需要明白文档流的概念：文档流是默认的网页布局模式，是文档中的对象在排列时所占用的位置。在文档流中，块状元素从上到下排列；内联元素（及内联-块状元素）从左到右排列。
对于块状元素而言，如果不设置其宽度，在默认情况下（非浮动、绝对定位等），会在水平方向上自动填满外部的容器；如果设置了宽度，块状元素仍然以行的形式占据位置。也就是说不论如何，普通的div都是独占一行的。

## 浮动
有位前辈说，“不管多么复杂的布局，其最终目标是都为了在同一行排列多个div元素”，因此，鉴于普通块级元素独自霸占一行的做法，我们就需要对它做一点事，使之变得“不再普通”，也就是常说的使块级元素脱离普通文档流，从而达到布局的目的。使元素脱离文档流一般有浮动和定位两种做法。当然会这篇文章的主角儿肯定是浮动啦。
元素（不论是块级元素还是内联元素），加了浮动属性之后会脱离文档流，并按照指定的方向移动，碰到其父容器边界或者是另外一个浮动元素才停下来。
浮动元素的影响可以分成三部分：
* 对于自身的影响；
* 对于其他的同级非浮动元素的影响；
* 对于其他的同级浮动元素的影响。

### 浮动元素对自身的影响
浮动的元素会触发形成BFC，具有BFC的一些布局特性。
* 由于块级元素的流动特性可知，在不设置宽度的默认情况下其宽度会尽可能铺满一整行。而当块级元素浮动之后其宽度由预先指定的宽度或其内容决定。
* 浮动的元素都会变成类似于块级元素的状态，也就是说可以为一个浮动的span设置宽高（但是并不会在其style中显示display:block）。
* 浮动元素在竖直方向上会尽可能的向父容器上方壁靠拢，当然具体的位置需要参考“对于其他的同级浮动元素的影响”这一点。
* 浮动元素的"pading""border""margin"属性仍然存在，这是显而易见的，毕竟这些都是盒子模型的一部分，且不会发生外边距折叠。

### 对其他的同级非浮动元素的影响
根据浮动元素会”脱离文档流“的性质，其原本在文档流中的位置会被后面的非浮动元素上移所占据。
这里会发生一个很有意思现象，跑上来的块元素的背景色会被这个浮动元素“部分”遮住，但是这个块元素里面的文字内容并不会被遮挡，从而出现文字环绕浮动元素的现象。（甚至于当浮动元素完全遮挡移动上来的块元素，其内容也不会被遮挡）。此外，如果浮动元素后面是内联元素也不会被遮挡，而是围绕在浮动元素周围。
因此，这里有很重要的一条结论：虽然浮动元素脱离了文档流，但是仍然会影响布局。

### 对其他的同级浮动元素的影响
根据浮动元素“照指定的方向移动，碰到其父容器边界或者是另外一个浮动元素就停下来”的特性，浮动的元素在其指定方向上浮动时，如果前方有另一个已经“浮动完成”的元素，他就会停下来。
如果浮动元素所在的那一行（按前一个已经浮动完成的元素高度计算该行高），所有浮动元素的宽度之和已经超出了容器的宽度，那么最后那个浮动元素会另起一行（紧贴着上面那一行高度的下面），重新朝指定方向浮动（我只是瞎猜的这个过程，具体发生了什么我没有查到相关资料），如果仍然碰见了另外一个浮动元素，则重复上面的过程，直至最后停靠在某个浮动元素的旁边或者是指定方向的父容器壁（除非浮动元素其本身设定的宽度就大于父容易的宽度，那么他就直接浮动在没有任何浮动元素且尽可能靠上方的那一行）。
资料上一般就几句话，我这好像还给他弄复杂化。这也是经常出现浮动的块没有出现在预期位置的原因，很可能就是宽度没计算好，多了那么一两个像素的缘故。这段话表述的很混乱，但是只想表达一个意思：弄明白一个浮动的元素最后摆放的位置。

## 清浮动
在实际的布局中，经常不设置父级盒子的高度，而是由内容自动决定的。在这样的前提下就可能发生子元素浮动脱离了文档流，导致父级元素高度塌陷甚至消失的情况，这样就会使容器内的内容溢出到外面，甚至发生布局破坏的情况。此时就需要进行清除浮动处理。
清除浮动主要有两种做法，一种是采用clear属性，这是真正意义上的清除；而另一种是使父元素正确计算其高度，也就是使父元素触发BFC。
### clear
Clear属性属性值为left right both none等，表示具有该属性的元素其对应方向侧边不靠着浮动元素。因此利用该属性可以清除左右两侧的浮动。一般的做法是为父容器内最后增加一个带有.clear{clear:both;}的块，但是这样做会增加很多无语义的标签，增加代码量，所以又有了利用:after 伪类的做法
```
.clear { zoom: 1; } 
.clear:after { content: "";display: block; clear: both; }；
```

### bfc
由于BFC可以包含浮动的特性，因此，只要使父容器触发了BFC就可以解决高度塌陷的问题。当然BFC也不是全能的，比如两个元素浮动之后处于同一行，则BFC计算的高度就是两个元素中高度较大的那个。具体如何取舍需要看具体的要求吧。